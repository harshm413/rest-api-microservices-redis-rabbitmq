So in this video we're building a

complete backend application with

microservices.

So we will have an API gateway that will

act as the single entry point for our

client request. Then an authentication

service that will handle our user

registrations.

Our login and JW2 token management

as well. So the authentication service

is going to be using MySQL database.

Next, we're going to have user service.

So, this is going for this is going to

be managing our user profiles and user

data. So, for the database for user

service, we're going to be using

Postgress SQL for this one. And finally,

we're going to have a chat service. So,

this will handle conversations,

messages, and this will use two

database. It will use MongoDB and also

it will use ladies for caching. All of

those services will be communicating

through lab MQ for event driven

messaging ensuring they stay decoupled

and scalable. Okay. So we're going to be

using TypeScript for the safety for the

type safety. ExpressJS for our list APIs

and we're going to also use PNPM monor

to manage everything efficiently as

workspaces. So the entire stack we

learns in docker containers. So it will

make it easy for us to deploy later.

We're going to be selfhosting this. I'm

going to show you how you can self-host

this later. And I will show you two

deployment approaches. So the first one

is with Docker Compose which we'll be uh

deploying on our local development and

testing. And then after tested on our

local machine, we're going to deploy to

the production using dock pro which is

for our self-hosted option. So you we're

going to get our own VPS and we can host

this ourself. So without relying on some

crowd providers. Okay. So if you're

ready, let's go ahead and start building

this together. See you guys in the

video. All right. So let's go ahead and

get started with this. Uh the first

thing I have to do is setting up our

project. So we need to set up this

project. Um so we need to install NodeJS

pinp and docker and yeah etc.

So we don't have a starter code. Let me

do this. This I prime this before I

actually decided to start from scratch.

So I'm going to be setting up everything

you

can use whatever you already have. So

yeah actually just going to do this. All

right. And uh uh let me see. Okay. So,

we're going to set up this um pinp

uh let me go back to my browser

actually. All right. So, I'm going to be

using pinp for this project. Uh you can

use whatever you want. And we're going

to be using this pin pin workspaces

and I'm going to show you how everything

works. All right.

Okay. Or you can just check out the

documentation of uh pnpm.

So if you don't have npm already

installed, you can go ahead on the

introduction and on installation page

here you will find out the options for

different operating systems whatever you

have. So for Linux systems and windows

you can for Windows you can use this one

and for Linux systems you can use this

one.

Okay. So I already have pinpoint

installed. So what I'm going to do, I'm

going to initialize this project

actually. And for my editor, I'm going

to be using Visual Studio Code. So let

me go ahead and open my terminal now.

And we can go ahead and start working on

uh this project. All right. So I have my

uh terminal open. I can go ahead inside

of here. And uh let me just check if I

have pin pin. I changed my keyboard uh

version. So this is the version I have.

I think this is actually the current

version that is supported. Right. So

this is the um version. All right. So

I'm going to go ahead and create a new

folder and I'm going to call this folder

um chat app since this is a chat

application and you can see this chat

app. Okay. Uh chat app.

So I'm inside of this application. Now

we can do um pinpit.

So do pinpit

and uh for now let me just open this

with

my visual studio code and here we go.

Let me make this full screen and also

let me zoom in a lot so you can see

well.

All right. So we have the package the

JSON

and uh also we need to set up the PNP

workspaces. So let me go to workspaces

and see what you need to do and actually

let me check my documents and uh okay

instead of JS we already have this and

actually we can go on ahead and mark

this as done since we are um

uh all right and let's go back to this

one. So let me go to this uh chapter

three which is setting up the workspace

and shared etc etc. All right.

So for the workspaces all we have to do

is uh easy. So let's follow this

documentation for a bit. So we can have

different uh okay referring workspace

package through the relative path. Okay.

So we need to create uh let's change to

true workspace protocol. All right. So

we need to create this file here

workspace.y

uh okay and here I can just do create a

new f file can create pnpm

and workspace and I can call it um yl.

All right.

Okay. So inside of this we need to

define uh where we have our different

packages.

So we can have you know spaces with two

packages.

We can also have dependencies that will

be okay.

Great. So inside of this one I can

define packages and inside these

packages I'm going to have um first one

is going to be uh diary. So we're going

to be having um

services folder. So we're going to have

services folder where we have all our

folders,

our services I mean and also we're going

to have our packages. All right. So this

packages we actually include uh like the

things we're going to be using

throughout this project. So the things

we can share between each service. So

for example inside of the authentication

service uh we can have the types and

those types can also be used inside of

uh user service. So instead of creating

u the types of inside of the

authentication service and have having

to create again from scratch a new types

for user service. We can just put it

inside of this package folder and they

can be used through anywhere we want

basically. So that's the whole idea. All

right. And also uh for now this is

enough. So we we're not going to have

anything so complex but this is already

enough for us. Okay. So we have we have

this service folder and we have this

packages folder. All right. So let me

check our document again. So workspace

setup shared. Okay. So that's what what

I was meaning. And also we need to

create a shared uh TypeScript config. So

that means we need to install uh

TypeScript inside of this project. All

right. So let's go ahead and do that. Um

I can go ahead back to my terminal and I

can just do um ppm install

uh TypeScript.

I hope this is correct.

PNPM install TypeScript.

Yeah, I was

uh ending dependencies to the workspace

fished

make. All right. So, since we have uh

actually Yeah. Yeah. This is good. Uh

this this is this message is good. But I

think this is what we want because um we

want to have our loot file. Uh I want to

have this loot to include all the the

packages that we're going to be using

for all of them. So, TypeScript is one

of them, it can be inside of the loot.

Um, so yeah, that's fine. So, since we

have defined this workspaces for

actually that's why we're getting that

kind of warning. So, because if you have

workspaces, you can actually when you

install, you have to put some type of

flags so it can install in a specific

folder. But I guess yeah, I think that's

the reason why we're getting this type

of u warning or this type of error. Uh

so for now I can just actually let me

run the command again. This what it say.

Yeah. W flag. Okay. Yeah. So we need to

inside of this uh folder. And uh while

we're still here I can also add another.

We're going to be needing

uh

um

actually let me install everything as

div dependencies.

So we're going to add this dash uh

whatever you call this slash dash d

slash dashd I guess typescript since

this is our dev dependencies. So all of

these will be used as our for

development purposes nothing else and

also let me add types

slash

node and also we are going to need um uh

what else do we need? We're going to

need the TS6.

Uh we're going to need um actually let

me go ahead and install everything that

we need. So we we finish with this.

We're going to need pressure. We're

going to need as/js

[Music]

as js and we're going to need the

typescript. So, TypeScript

TypeScript come on TypeScript and this

is going to be as

slash ESLint

and it's going to be the plugin for

TypeScript.

Okay. And also we're going to need

another one. So, TypeScript

TypeScript. And this is going to be as

well as so as

slash persona

and um it's decent enough. So we have

tcript we have typescript plugin we have

typescript

person and also we need eslint itself.

So as lint yeah es lint that is fine

and uh pre yeah that's fine we have the

typec script okay good we have the types

and um

yeah for now yeah for now it's good so

let's right was fast so we have inside

of uh package djson sorry we have this

types

installed.

So this is the versions I'm using in

case you want to have the same version

as me, but it shouldn't matter so much.

Type script doesn't change that much.

And um yeah, put it as well. That

shouldn't make any problem just in case.

Can go ahead and use the same uh

versions as me if you want. All right.

And also need to configure this. So let

me close this for now. inside of this

script. Let's go ahead and remove this.

So, we need to configure like when we're

building. So, for the build command,

we're going to use a specific command.

So I'm going to use pinpm

and a slash l and we're going to have

slashwork

space and this is going to be load and

we're going to use this is going to be

uh false and uh we're going to also say

um learn beard. Okay.

All right. So, so let me add another

one. And this one's going to be for the

div command. So, the dev command is

going to be we're going to use pnpm

and / l workspace force and land div.

Perfect. And for the lint uh since it's

let's also

yeah let's also do this. I'm going to

I'm going to explain everything.

So let's say pnpm-l

workspace loot it's going to be force

landl

and and also we need to run the format.

So format pin pin workspace load format

perfect and uh for the test we can say

test test sorry test. So the same thing

ppm airspace root force- test. Yeah yeah

yeah that's fine. All right so now that

we have this uh ready what do we have

like what what what is this we just

typed? So it's your first time uh seeing

this. So this build command uh this is

just a script. So in our penp workspaces

and this pnp with this / l or uh the

word is actually this is just short name

for the u recursive recursive I don't

know if I'm saying that right. So this

will learn the command in every package

of this workspace. So this is what we

we're saying it and this one here we're

saying workspace loot equals to false.

So this we're just saying exclude the

loot package from the execution. So uh

like uh only the child packages we learn

this uh view script. So that that

applies basically for everything else

here. So yeah, that's was the idea of

this and uh now we can go ahead and uh

uh actually continue uh with this. So

the next thing we need to do so that now

that we have our workspaces kind of

ready uh we can go ahead and set up the

uh TypeScript config and um

just to avoid uh wasting so much time on

this I'm going to create a new file.

This is going to be uh ts config

dot uh base. So this is our base uh test

config settings. And this settings we

we're going to use them uh with other u

services as well. So this is just the

base. So we're not going to type this

again. We're going to be using it inside

of other uh tests config files. I'm

going to show you how you can do that.

Uh but yeah, so this is the settings I

have. Uh you can pause the video and uh

copy them if you want or you can just

get the code from my uh GitHub uh

repository. All right. So this is what I

have and now let's go ahead and set up

the our test config for our loot folder.

So inside of the loot directory we're

going to create a loot folder

config for our script. So let me call it

this config and it's going to say

JSON.json JSON and uh instead of this

I'm going to

have this and I can say extends. So

we're going to extend our what we're

going to extend this base. So this is

our base settings. So we're going to

extend them for on this test config

JSON. So we do not have to write the

whole thing again. And this test config

we use these settings that we just

added. but a expression that we're going

to be adding some other settings that we

don't want to add here. So, I hope you

get the idea. And inside of this one,

I'm going to say um just give the uh the

path of this folder file, sorry. And

it's just over here. So, this config

pson

and here we can go ahead and add other

settings that we want to have for our

loot folder file folder. Yeah. So for

our compile options, we're going to say

compass

and this is going to be to true. And

outside of the compile options, just go

outside, we can say files.

Uh for now, it's going to be an empty uh

alge and we can say reference. And this

reference we're going to say uh where

our files or our folders are uh based.

So inside of object we can say path

and uh we're going to have inside of

packages.

So packages are going to have common.

Okay. And uh let me just do this. And

now I can just paste copy paste this one

here.

Okay. So we have the package JSON uh

packages. Inside the packages we have a

common folder. And after this one, we're

going to have Sorry, let me just delete

that once.

Yeah. So, uh, inside of workspaces, we

said we're going to have services as

well. So, let me add services. So,

services.

And we're going to have instead of

services, we're going to have how many

services? The first one is the user

service. Uh, just user service. And, uh,

let me paste it here. And the second one

is going to be uh uh the gateway

the gateway service.

All right. And also another one is going

to be um chat service. Chat service

and we're going to have also the

authentication service. So these are the

services that we're going to be having.

So gateway service, chat service of

service and user service and also don't

forget our common file folder where

we're going to be having our reusable uh

packages throughout this uh this

project. All right, perfect. And uh let

me see if this is all we need to do

inside of this one. So we're setting up

we set up the test config. Okay, pmpp

more expensive. Uh yeah.

Yeah. Actually, I think that's uh that

should be all.

Uh let me see the second one. What do we

have to do? Yeah. The second one we need

to create the common. Yeah, we need to

create everything. I guess yeah, I guess

this will be everything that we need to

set up actually in this one. Um so maybe

we can go ahead and do that as well. So

let me uh go ahead and mark this as

uh done.

Perfect. Uh wait, this is a long one uh

recording actually. And then we mark

this as done. So now let's go let's go

to this the fourth one which is uh

creating the common and also setting up

uh like everything we need to use such

as the logo errors hands and types etc.

We're not we are not going to create

everything in this uh uh go but we're

just going to set up uh the essentials

that we need. So let me go ahead and uh

start working on that.

All right. Uh let me open my terminal.

Uh actually not terminal but my editor.

All right. Uh so inside of this one I'm

going to create the uh com packages

folder. So packages and inside of this

one I'm going to create a common folder.

All right. So if you remember that's

what we uh we said uh inside of here. So

we're going to have packages. inside

packages we want to have common folder.

So inside of the common folder uh we

need to initialize this project this um

uh actually we already initialize this

but we don't have to like I'm going to

show you how this works actually but

first of all uh inside of this folder

I'm going to add a test config settings

that we already have uh let me see if we

need uh no we don't not going to use

this one uh let me create a new inside

the package packages not inside of uh

inside packages inside of the uh common

I'm going to create this TS config file.

So ts config dot uh JSON

test config.json.

Okay. And the settings for this one are

these are going to be the settings for

this test config. So it's also going to

use our based settings. You see the

useful of using this config. We don't

have to uh use everything. We just need

to change uh some stuff that we don't

have to have inside of this one. All

right. All right. So now let's go ahead

and start installing the packages we're

going to be using inside of our

packages. And uh yeah, let's go ahead

and just do that. I want to install uh

from this common folder. And uh we

already have the log file. So there is

no need for it to create a new one. And

since we're using the PNP mock spaces,

we can use the filter uh flag to uh

filter where we want to install this

from. So let me go to my terminal again.

Uh here it is and for in the terminal I

can install the uh what I think that I

will need. So the packages I think I

will need for the logo we are going to

use pino and also for the validations

we're going to use z. So I can do PNPM

add and we can do um the package name

which is sort

so and also pino

and we can add finally we can add the

filter and we can say common.

So I hope this works. Uh if it doesn't

work we're going to try to fix it but

yeah let's try it.

All right. Uh so it's saying there's uh

no project matches sh inside of this

one. So it's not fighting uh fighting.

It's not fighting. Oh, it's not finding

it.

Um let's see what's the problem here. So

we say this

and also let's fix this stuff.

Uh we don't have a main for file inside

of our L directory. So we can remove

this. We don't have a lot one for the

description. You can give it whatever

you want. And also this is going to be

private

to true. Uh okay. This uh the version

can be this one. The name can be this

one. For this one is fine. That is fine.

Uh let me try learning this again and

then let's see if this will fix

something. But

I don't think so. But uh yeah, let's try

it. Okay. Uh ppm add filter common.

Okay. Yeah. So

yeah

was so obvious. We need to initialize

this first.

Yeah. Whatever. So we go inside of cd

packages uh common and we can learn the

pinp in it command and now we have the

uh package JSON file. Yeah. Wow. All

right. Uh so uh let's rename this and uh

how I'm going to rename these packages.

So let me say I'm going add and I can

say chat

the name of this chat app common. So

this how I'm going to be naming um all

of my virus. So so this one is going to

have a main one. The version description

uh is going so to be uh private.

Uh private is going to be true, not

false. It's going to be true. And the

main one inside of this one, we're just

going actually going to have this folder

when we build and also the indexer. And

we're going to have types.

So for the types, we're going to be also

inside of list. And we can put it inside

of index.t.ts.

And uh yep, for now this is okay. Uh we

can go ahead and install the packages

where we're trying to install area. So

we can do pin pin this time. Uh we can

do this. So fa packages don't come on.

Okay.

Uh

okay. Come on.

Uh

uh all right.

All right. So all we have to do is

actually uh specify this as common

nothing else. So pm

uh workspace p and that's because we are

already inside of the common folder.

I don't know what's going on. uh the MCD

back.

All right. So we have the packages that

we wanted to add and also inside the

common folder let me create a new folder

going to call it src

and uh let me check my what we have to

do. So it's okay the types. Yeah.

Uh for the types should we start with

types or we can start with our logo. So

we can use it. Uh we actually added the

logo. So let me start with the logo. So

inside I'm going to create a new file.

I'm going to call it logo.ts. So this is

the logo I'm going to be using

throughout this project. So let me

import uh pino and it's going to be from

pino and also let me input the types

from this. So, import

type and I think we need to install

never mind. And also we need the logo

options.

Perfect. And here I can define a type uh

we're going to hit the create

uh logo

uh options. So we're going to create the

options for this logo that we need. And

let's extend with this one. So options

and we can instead of this one we can

give it a name which is going to be a

string.

Okay. So each logo we have to give it a

name and so export cost. We're going to

say create logo

and let's say create export cost. We're

going to call it create

logo. So this is what we're going to be

using. I'm going to show you how to use

this as well. So, we're going to take in

the options which is the create logo

options on top and it's going to extend

this one.

All right. So, that's because we need to

return something actually. Yeah.

Yep. And inside of this one, I'm going

to say cost and I'm going to get in the

name and also uh the list or you can

just call it. Yeah. So it is going to be

from the options and here we're going to

say cost uh transport.

So this transport is going to depend on

the process.

NV. So if it's cost is if it is equals

to development we can uh just let me

open this object. We can say the uh

target is going to pin pretty and from

options inside of this one you can say

the color to be true and translate uh

time or you can use uh this one and

outside of this otherwise can just be

undefined. So we don't want to show so

much stuff if it's outside of the

development uh environment.

All right.

And outside of this one, we can just

return and uh let's say pino. And inside

of this one, we can turn the name uh the

level. So level it's

bending. We're going to get it from the

uh environment variables. So log level

or otherwise the default is going to be

this one. Click in the transport and

also the list. All right. So this is

actually everything for this logo that

we're going to be uh uh using. So this

is like everything we need. So outside

of here, so inside of the src folder,

I'm going to create an index f file. So

this way we're going to be exporting

everything that we need to use. And uh

we can actually uh start by importing

so everything uh from

uh our logo. So the logo.

Uh okay.

From import from logo, right?

What what's the file name? So import.

Oh, let's use export actually.

Export from logo. Yeah. And also let me

export the types of this just in case I

need it. So uh let me call it logo from

pino.

Okay. And uh what do we need to do next?

Uh we also need to set up our

environment variables. So since we need

to validate them. So we're going to use

a new tool here. So let me call it. I'm

going to show you how everything is

going to work out together finally. So,

import and uh we're going to use Z. So,

we need Z as well. So, let me import

uh Z object

and also uh Z

uh low shape. So, we're going to use Z

with the environment variables as well.

So for the M we're going to say M

options.

So inside of this one we're going to

have in the source

which is optional of NodeJS process. M

and also going to have the service name

which is type of string.

Okay. And here going to type and we're

going to be schema and output

and to have the T schema I guess

we can call it the schema.

Yeah. And also extends

the sword low shape.

All right. Uh so let's use object as

well and let's create again t schema.

All right.

So the output what's the issue here?

Output is duplicated.

Okay. What do we need instead? Use it

says use type of schema instead. Okay.

Uh but for now it's fine. We can use

this. So export let's go to cost and we

can call it create

am

create environment. So it's going to be

type of schema extend the row low shape.

Okay. And inside of this one, we're

going to define the schema which is t

object t schema and also the options

which is theions

can be default this one. And finally

here we can just say schema output goes

to this one and uh instead of this one

we can just get the

the source which is going to be from the

process. Envy the service name. Uh for

now we can call it the service

options. Okay. And here I can just call

it cost and we can call past. Yeah, that

was good. Go to schema save pass and get

in the source. And here we can validate.

So if there's no uh if it's not succeed

also if

is not success

what do we need to do inside of this

one? Uh we can say cost

formatted

uh errors. Yeah formatted errors equals

to past error and instead of errors we

can say format.

Okay. And here I can just scroll

new error

uh from new error and inside of this one

we can say um yeah this one is fine. So

service name uh variable validation

fired and we can use the JSON string

file and otherwise here we can just

return past data past data and here we

can export

type

export type

and schema

and goals to T- shape can call it T-

shape and extends

So Z low shape and also here Z object

the shape and we can remove this one

actually.

So this is what we're going to be using

to help us um when validating

uh this one. So what's the issue here?

Oh, this cannot be option.

We're going to be using this when we're

getting our environment variables. Um

later on I'm going to show you how to

use all of these. So now you can go back

to our index file. So instead of index

uh for now just preparing what we're

going to be using actually. So I I hope

you're getting the idea. So export uh

not from the errors but from the M.

All right.

So we have this now. Uh what's next that

can we use? Uh so we have the logo

uh we have the environment variable.

Actually I think for now this is enough.

So we can go ahead and use them when

setting up our service.

So we cannot mark this as done.

Yeah, we cannot mark it as done. But we

can go ahead and set up a little bit of

this. Uh but actually you can mark it as

done. But

yeah, it's not really done because we

come back to it. But we are setting up

is fine. So let me just go ahead and set

up uh one service. So we can set up

user service or authentication service.

Uh which one is better? I think

authentication service would make

much sense

in this case since we um

we need authentication before anything

else. So I guess authentication service

make

more sense than uh this one.

Yeah,

let's set up authentication service. So

let's get a further call services. All

our services will be inside of this one.

Inside of the services, we're going to

have off service.

All right. And now we need to uh set it

up as well. So inside the packages, let

me copy this uh test config, put it

inside of this one. And uh uh we I don't

think we need to change much since uh we

can just say let me see. So everything

can stay the same over here. Um

but yeah we need to change how we import

stuff. Uh actually let me take this one.

So this is the settings for our

authentication uh authentication service

settings. So it's getting the settings

for common and also the way we're going

to be importing this. We're going to be

using this ad signane when importing

things.

All right. So okay. And uh next thing we

can do we can instead of this one let me

open my terminal.

Uh we can do uh pinp

uh in it. Let's try the filter

the filter to be instead of

uh services and also of service.

Yeah.

Yeah. I I I

knew that would not work. So I see the

um uh services

but I think there's a way to do this. Um

I'm not sure. Okay, it's fine of

service. Let me just see into this. I

can pinp in it.

All right. So we have the package JSON

and uh let me see the packages. Yeah, we

just have the package. We don't we don't

have the log cuz the log f is already

inside the loot folder. Uh so that's

fine. And um

and now instead of this one we need to

set up some settings as well. So just

like I said I to be naming this as chat

app.

Yeah. So this going to be naming stuff

and it's going to be private as well.

True. and description. Uh let's make the

type to be

uh module

and uh the main uh main file is going to

be inside of this

and it's going to be index.js

the types as well.

So types it's going to be inside of

this. So just the same thing we did uh

inside of the packages index.t.ts.

of the packages index.t.ts.

All right.

All right.

So for setting up our project what we

So for setting up our project what we

need just for setting up we need the

need just for setting up we need the

express js fer. So ppm

express js fer. So ppm

esta

esta

um we can say

um we can say

we can say express

All right, we have the express.

Okay, that is fine. Let's there is

enough actually for us to get started.

Actually, no, we need so npm pin.

[Music]

Envy

[Music]

env.

All right. So this is enough for us to

get started actually.

Yeah. Uh this is enough for us to get

started with this. So we're going to be

very organized this one. So inside of

the authentication service, I'm going to

create a new folder which is src as

always. And inside of the s I'm going to

create a new folder call it utils.

And inside the I'm going to create the

first one which is logo. And of course

we're going to use the logo that we

created. But uh this is how this is

going to be using it. So we're going to

import the create

logger.

Uh this should be automatically

uh showing us the input since we have

everything else.

Um yeah

uh it's not showing up. What's the

issue? Did I set up everything wrong?

Should be showing. Uh, no, it's not

showing up. Let me do something. So,

inside of the

uh services, the package JSON file, I

can go to the dependencies. I can do

this. I can just say

shut up and let's get the common. I

don't need to add the version.

Just do this.

Okay,

I hope this works. Uh I'm not like uh

like I'm not really familiar with so

much with the PNP mock spaces. So I'm

I'm experimenting just like you guys. Uh

but yeah, hopefully we get this through.

So now let's import this. Shut up.

Common.

Uh yeah, it's not going to let us. Uh

should we build uh this?

Uh wait, let me check this out. Build

npm workspace.

Uh take

the

cd packages

common

pose.

Uh-huh.

Uh but script m to present in

um missing script. Yeah, we don't we

don't have the script to view this

type. We need to add in the script to

view the package packages.

So let me call this build and let me let

me remove this. uh this is going to use

uh for TS sake

and you can say project

it's going to the ts config

test config

uh it's no it's just test config JSON

okay

uh yep now let's try joining again.

Oh, I'm already inside of this. So, pin

pin and J.

Okay, so it was bu successfully

and uh

let me go back.

Uh pinp install.

Let's run the install command.

Yeah. Okay. This fixes it. So we just

need to specify just need to specify

this as a package actually. Yeah. Makes

sense, right? So inside of service, we

just need to specify this uh where is

it?

Oh, not packages. instead of services

packages soon. We just need to specify

our packages where it is at. So, and

everything is good. Yeah, I told you

guys we get through this. So, all right.

So, this is the first thing done and

we're importing our create logo right

here. And here we can also import the

type of logo that we exported if you

remember. So, type export import type

logo from not Winston. I don't know why

you think I'm using Winston

shut up common. Yep. And uh we can do

export

con logger and equals to loger and

create logger and here we need to

provide a name. So but must be inside of

this. So and this is going to be

authentication services. So inside of

the logo we will have this one. So this

is the logo that we created inside of

our packages and this is the one you are

seeing like here.

Okay. So this is done and now we need to

create our uh main entrance file that we

need to uh log all of this. So instead

of stream inside of s let's create an

index

ts file

index.ts file. And let me close this. So

I'm going to do con. It's going to

create main. And over here I can just

say a sync. And inside of this one.

Yeah, this was fine. So this one I'm

going to have a try catch.

This is where I'm going to be uh

connecting most of the stuff. But over

here I can just scroll the main.

And for now I can just uh have the app

and also

um

and also the log the uh file or log the

port that we're running on. So let me

create a new file actually. So I'm going

to create a new frame inside and this

going to be app.ts.

Okay, it's going to be app.ts ts and

inside of this one um I'm going to have

so I'll do export

con and it's going to be uh create

app I'm going to use create app and here

I am going to have this application

from

uh from express so just one second so

this is going to be equals two

and let's input the so input

uh this is going to be import express

and also type

application from express. Yeah, we need

to install the types for this.

So we need to inside these types

and I think we can just do pinp install

dash d

types and we can do f

and uh this is going to be instead of

packages

packages

and not packages services

and authentication service.

Yeah, that works. So that's how we can

install it. So we have the packages

installed now.

And inside of this one, we can just say

uh con app equals to express

and we can we're going to come back to

set up the uh some middle that we need.

Uh

but for now actually this I think just

for us to test our log and everything

that we created. I think this should be

all that we need. I'm going to come back

to this obviously but for now let me go

back to the index file.

And here inside the try catch can do

cost app cost to create

app that we just imported.

Uh let's use this add sign. This is what

we set up to use. So why not use it? I

can also import

um I'm going to use import um create

server from the HTTP.

So let's import that. And here we can

just say con server equals to create

server and taking the app. And here we

can just say con the uh port is going to

be um

so let's say uh we need to create also

the in file

uh

should we set that up now or should we

wait until we have yeah let's set it up

so let me show you how we also want to

use the m stuff we just created inside

of here inside the src let's create a

folder. I'm going to call it config. And

inside of config file, I'm going to

create a new f file called config m.ts.

And inside of this one, I'm going to

import.

So, this import

config. And here I'm going to import

what we created earlier. So, import uh

from

uh this going to be shut up common.

And we're going to use create M and also

sort.

Uh did we we did not expose sort uh

that's why it's showing as error. So let

me go back inside of my packages inside

SLSC inside of index. We need to export

Z as well. So export

and it's going to be a Z from S.

So we can stop having the error that we

currently have

and um yeah go back the M file. So now

we don't have errors anymore.

So let's keep working on this M file. So

inside of this one we can do a con f

schema

contobject

and inside of this one we can have the

uh what we need for now or maybe let's

start with the node environment it's

going to be zam and you can have as many

as you want. So for example development

uh test production and uh we can also

set the default. So the default is going

to be development.

All right. And also uh let's have

authentication service of I'm going to

call it of service port of service port.

And for the port uh it's not going to be

like this. It's going to be use this.

Okay. U

number

and it's going to have uh int

and it's going to have zero

and no it's going to have so

dot number dot int and after that int

we're going to have dot minimum.

So minimum should be uh

zero and also the

max it's going to be between 6,5

and also of like 53 and by default the

authentication service is going to be

running on port 20 403

43 this is the default port all All

right. So that's enough for now. So

let's also do type uh M type.

It's going to be Z. Infra type of schema

and export cost.

F is equals to

F type and we're going to use our create

M file F and this is not how define it

and we just use the create. So export

con M equals to M type create M I'm

taking the M schema

and also you can just uh the service

name it's going to be authentication

service

and here I can do export

type

M

goes to type of M

Yeah. So, this is how we're going to be

using our utilities that we have created

uh earlier. So, we're going to see it in

action just real quick. So, let me go

back to my index file here. So, we can

uh keep working on it. So, we have the

port and now we can actually use the M

we just created. So from our config and

now we can get the

authentication uh of service port and uh

let's use again once again let's use

this.

All right so we have the port now

and uh we can just do server dot recent

to the port

and uh here we can just use our logo as

well. So logo we created inside of the

YouTube we can call info

and uh we can give it a port

and the message can say

of service is running. So this is the

uh logger file that we created inside of

this utils. So let me also add this as

well.

All right. So the logo as well this is

fine. This is fine. And um

yeah, for now this is everything for now

is okay. We just want to try the the

what stuff we created. So for the

errors, let's log this as error and also

process.exit.

Yeah, actually I think we can make this

as void main.

All right. All right. So um I'm guessing

this is for now for us to test what we

created if everything actually lands. So

it's okay. So instead of just keep

working on stuff that we're not sure

that lands and uh before we go ahead

actually uh instead of the services of

service let's actually create the in

fail and we need to add these two we

added so node m

and also the

port.

All right. So for the this ones going to

be development and for the port it's

going to be 2003.

All right.

So what do we need to do next? Okay. We

need to go inside of package.json

for the scripts. We need the one that

can learn uh the

div commands. So I'm going to add the

whole script that we're going to be

using inside the through all the

services. This is the thing we're going

to use. We're not now we're not going to

change anything. This is all we're going

to be using. So for the dev command,

this is the command the script for

starting for in and this is what we're

going to be using through all the

packages JSON of this project.

Okay. And also um just while I'm still

here. Okay. We see we have it. That's

fine. All right. Okay.

Uh that's fine. And now let's go ahead

and test this and see if it will learn.

So I'm going to go here

pinp

div and we can do beta and uh let's say

since I'm not inside of the

I want to do so I can just say

um what do I what do I say packages

uh services and authentication service.

So let's start it and see.

All right. So uh I finally figure I

finally figured out what was the issue.

Uh so inside of our packages in the

common folder and in this package the

JSON we forgot to add this type module.

So make sure to not forget adding this

in every package. JSON that of folders

we have in here. And also let's make

sure that we have it inside of the

authentication service.

All right. So type modules and also uh I

installed a package which is just this

pin operator though. So first we install

just pino but we also need to install

pin operative for uh our logo to work

well without uh some issues since we're

using it uh right here.

Okay.

So yeah that that that was everything

and now let's start start the server

again and the brief for starting this we

can just learn

uh we don't need to go inside of the uh

folder that we need to start uh we can

just do like pnpm and we can do dash f

or you can say filter and you can go

inside of the ch uh the name of our

application and we can go to of uh

service

uh of service. Yeah. And we can say def

ppm uh div.

All right. So I guess we cannot use that

this uh

ppm dash

filter. Let me say filter.

And uh we can go inside of um services

and also let's say authentication

service. So let me choose authentication

service and finally say div.

Perfect. So you can see our login now is

working and also our NV is being loaded

um by the tools that you have set.

inside of the config and we are using

the create.fm and also the Z package we

have imported inside of our packages the

common ones that we need right and also

we can see the name we gave it and also

the logo inside of uh index

uh over here. So the logo info this is

the info we gave it and of service is

the u name we gave it inside of this

logo we created.

Perfect. Perfect. So everything is

running. Let me stop it. And now I can

go ahead and keep setting up this this

uh server. So let's finish setting up

this uh not finish like finish but let's

set up what we need to get started. So

inside of the app.ts. So let's check out

the index as well. Let's see if we need

to add anything else. So inside of the

index we already have the app. We also

have the

uh the server, we have the port. Um

there's also just in cases sometime

maybe um

like let me show con shutdown. So con

shutdown it's going to be a sync

and it's going to take in the uh it's

going to be a sync doesn't it doesn't

need to be a sync. Let me remove async.

And inside of this con shutdown, we can

just log an error. So we can say

logger.info shutting down the service.

And here we can use uh promise.

Promise. Is fine.

Uh yeah. All right. Yeah. Promise.

And um

uh we can say

for now we can leave this as list and we

can go outside of this one. We can say

dot catch we can get the error. We're

going to come back to this when we set

up some other things that we need to uh

let me give it type uh we can make it

Wait, what's going on? Uh let me give it

type. We can make it unknown for now.

And inside of this one uh we can just

say

um

we can just say logo

uh

so error give you this error

and after we can also say maybe finally

and um finally

finally instead of this one we can say

saver.

Saver. Uh instead of we can just say

process dot uh exit with the code of

zero.

And uh

yeah, that's basically it. And also can

this code. So passing this shutdown we

created. We're going to come come back

to this one later on. But uh yeah. So

this is just for example. So let me run

the server again

and let me try to create.

Okay.

Okay. I guess so.

Yeah. So for like for example if this

code may uh when I hover it doesn't say

but

this will help protect us from uh

unexpected or to shut down like grace

for you or something.

All right. Um so uh over here we have

mostly of what we need to add. Uh we

also need to add some middle inside of

our app.ts. We need to add some

middleware. So let's also finish setting

up this one. So we have the create app.

We have the express. Uh let me go ahead

and install what we actually need. So,

we're inside of the um we are inside of

the authentication service and we need

to install some um

we need to inert

we need to install a package inside of

this. So, we see inside of our

directory. So all we need to do is pinp

uh we can add and we can a package uh

the packages we're going to use

uh for middle we're not going to use so

much uh different stuff we're going to

need corals for corals and also need the

hermit.

So let me add hermet

and um that's basically it like yeah so

we can just say that

so and we can go inside of our uh

services

and inside of the of service npm add and

we're going to add this. So let me

insert them inside of the here. Perfect.

So this is installed and we can import

them over here. So import and we can say

uh cause it's going to be from course uh

I guess we need the types as well but

let me finish and also for the airmet.

Yeah we need to install the types for

cause. So let me just copy this name and

let me bring back the command and let me

just come here.

Let me add it as div dependencies. So

I'm going to say

um dashd

pasting the name

and install this

instead of authentication service.

All right. So that is done and now we

can come back here. So after the app

express we can say app dot use uh we can

use the airmet and also for the course

we can just say app dot use

um maybe we can say course but uh we can

give it also some settings. So let me go

inside of this one. So we just need to

allow origin for now can allow

everything and we can say credentials to

be true.

All right. So that's the basic settings

of this and also for express we need to

add the JSON so we can support it and

also can use app dot use express you are

encoded extended to be true and we're

going to come back to add one one more

middleware to protect our uh APIs. So

yeah, I'm going to show you what I mean.

And we can add a little uh app use.

We can call it

just for testing

uh request. We're not going to use

request, but for response, we're going

to use response. So inside of this one,

uh what I can say is just rest status

400. And uh this is whenever someone

make a call to the um API that we do not

have. So they're going to see this uh

message.

All right. So we got most of most of the

stuff we need

and um

yeah. So let me check grants again my

documents.

So we are setting up actually the

authentication service.

Um

yeah I need to update this. It's not up

to date. Um

yeah.

Okay.

All right. Uh that's fine. Uh so we have

this. I'm thinking what we can do next.

Uh restart it again to see if everything

still runs as should.

Yeah, everything still runs well.

Uh

okay.

So what's next step can we take?

Uh should we add the louds? Um

but for the loss uh we also need to like

kind of handle

uh some

um yeah let's set up a handing. So let

me close everything. Let me go back

inside of um the packages the common and

inside of common inside of src

I'm going to create a folder. I'm going

to call it errors

and inside of errors I'm going to create

HTTP and we can say error dots.

So this is going to be for HTTP error

and we can say export

uh let's do a class export class going

to call HTTP error extends the error

and inside of this one we can say uh

constructor and inside of the

constructor going to have public

uh le binary. So we're not going to be

able to modify this

outside. So message uh is going to be a

string and also a public of read only uh

details. This can be like this can be uh

actually uh record

string

I can make it unknown.

So I make it unknown. And here I can

just say super message and also I can

say this dot name I can give it name of

httpl.

All right. So this is what we need. Uh

now we need to make sure that we build

this again. So uh not inside of

but inside of packages

not packages and the common. So make

sure you build this. Whenever you modify

our packages, we need to build it again.

So let's do that. Build.

Okay. So I guess we have updated

dependencies now. And now we can open

our let me close this. We can open our

services. Uh yeah, our services

authentication service. And we can add a

middleware. So middleware

folder and inside of this middleware

folder I can create uh error.

So error.ts

TS

and instead of this I'm going to input.

So let me import what we just created uh

from and it's going to be uh from the

command folder packages and it's going

to be the HTTP. Did we export it? No, we

did not. So that means we need to export

it inside of our index bash. This

shouldn't be the case because

uh because if you check Yeah, this

should be the case. We did not export it

yet. Uh export

uh export and everything uh is a string

everything from and this should be from

t from tag eras

and this should be

uh eras. Yeah, this is a folder and we

have this http and I Yeah, I think now

we need to build it again.

Uh maybe not. Yeah, we need to build it

again since Sorry guys. Let's build it

again.

Perfect. And now we should be having we

should be good. I hope so. Uh let me

close this. And now we can have HTTP.

Perfect. We have it.

So uh after this one I can do input

and uh what do I need? I need the type

of express from express. So I can just

say put type and this is going to be uh

from express.

Okay. So what type I need? I need the uh

error request

handra

and also I need to import the logo we

created uh but not this one the one we

have inside of this one the one we have

customized to work with our

authentication service. So you

lo

uh

right wait

I'm inside the services

sorry guys this should be inside of src

for f for the

yeah this should be inside this

middleware should be inside of src

folder not inside of the loot

authentication service yeah that's why

it was getting the error Um, now I can

go over here. I can do export

cost and I can call it Android. And

we're going to extend the error request

that we just imported. And we're going

to take in the error request and

response with next. But I don't think

we're going to use next. So for now,

what I can do, I can just make it like

this.

And inside of here, I can add logo dot

uh logo. yellow

and we can say the just send the error

not the request and the message can be

anything. So we can say error occurred

but also let's get the con error. We try

to get the error and we're going to say

equals to error is instance of uh http

error.

Uh it can be http error. We're going to

give this one otherwise we can just be

um

uh for now let me actually make it

undefined cuz I don't want to uh expose

something I don't want to expose. Yeah,

but yeah. So for now make it undefined

and con and it's going to be status

code. So

status code

and uh here I'm going to get the error.

Um I may use this actually

status code otherwise going to be just

500 by default and also let's get the

message. So con message

uh it's going to be uh if the status

code

okay so let's check this. So if this

test is good and 500

can say uh internal server error

otherwise we can just say uh error we

can give this message to get or can say

the unknown error by default.

So con payload al so let's get the

payload this is going to be dot uh if

you remember all this details so in the

details we can get the message

message and it's going to be the details

uh

details so the message details equals to

oh we can no we have the message and

also we have the details yeah So we have

the message and details goes to early

details and otherwise it can just be

this one. Uh what's the issue with this

one? Cannot find name. Did you mean wait

did you mean message? What did I export

again?

Uh I messed up, didn't I? Oh yeah, I

have I have many s I should have just

two.

So now I need to build this again.

Boom.

Should be fixed right now. Uh any

second.

Yeah. Okay. Just time for it to I guess.

Uh

message message.

Wait, let me reload this. So,

TypeScript

is that server

see not working.

Oh, I think yeah. Okay, it's just here.

But yeah, also this one was just

supposed to be two. So, is fixed and we

can come here. We can say is dot status

pass in the status code. The JSON can be

the parod and uh maybe let's uh use the

next just in case

uh next. Yeah.

All right. So, this is our hand ring for

this authentication service and I think

it's going to be pretty much the same

for all of our services.

Uh yeah.

Okay. Uh let me go inside of app.ts and

on the bottom. So at the end we can say

app dot use and we can import this uh

Android from the middle just like that.

And uh let's use this sign.

Let me make sure our server still start

without any problems.

All right. Uh it says authentication

service is running.

Uh perfect. So that is fine. It runs.

Uh let's stop this.

Yeah. So this you can see it says

shutting down the authentication

service.

So that is fine. Uh, yep. So, we have

the middle here with I don't think

you're going to come back to this one.

Uh, we can also set up uh the lots

that we're going to need.

And uh yeah, let's set up the loads and

maybe even

let's set up the loads for now and uh

we can test it. But

yeah, let's set up the louds and test a

little bit of it so I can go ahead and

actually

keep working on this. Uh so for the

layouts I'm going to go inside of s

folder and I'm going to create

folder

and inside the uh I'm going to uh since

this is just for authentication so I'm

going to have dot uh

ts

and inside of this loads we're going to

have some couple of loads that we're

going to be needing but we need to

validate those um request that comes

from come from this one. So we need to

validate the request that is sent. So

making sure that it follows what we have

said.

All right.

So what do we have to do? Okay. So let

me close this. Since we're going to be

using this validate request uh all from

all our services, I think it's a good

idea to put it inside of packages. So

inside of the packages common inside src

let's create uh

a new folder I'm going to call it http

inside of http I'm going to create uh

validate

uh validate request

and ts

validate requestts

and this one I'm going it's going to be

uh really long but yeah stay with me so

let's import zod. We're going to be

using zord for this one as well. So from

z

and we're going to import the http error

we just created. So we're going to use

that as well. import

what we call it http

http error we just created.

Uh yeah I going to use this one and also

we're going to do we have express inside

inside of this one. Yeah, going to use

express as well since it's going to be

viating from express. So we don't have

express installed,

right? Let's install it. So let me find

the command.

So this is the command. But we need to

update most of these.

Should just type delete. Uh

like

let's start with the express types.

Uh no let's just let's just inside

express

and we can say

and we can go inside of packages

and

actually this is kind of taking a long

time to type. Um I'm going to do one

thing. So I'm going to open this

terminal and I'm going to go cd packages

cd

common right

and another one we're going to cd

uh services

cd authentication service so that we can

just go inside of the command for

example and we can say ppm add express

without having to go instead of

uh Yeah.

All right. Yeah.

Okay. Maybe that's not a good idea.

Yeah. All right. We have express inside.

That's fine. So, let's go back to our

request and uh let's import what we

need. So, we need let me close this. So

we need a type which is uh uh from from

express. Yeah, from express. And it's

going to be uh we need the types.

I knew this uh types express.

So pinp

express.

So what types do we need? We need the uh

next function.

We need the uh request. We need the uh

response.

And also we need another types from Z.

So import type from Z. But we're going

not use this one. We're going to use any

uh object.

Wait, do they have this any?

Uh, yeah, maybe they don't.

Oh, yeah. I think I using a sword 4

version.

What is the Oh, we're using a newest

version of sword. That's why I was

wondering

um

I uh in Z 4 the unobject areas from is

no longer exported to export accept

directive for example

yeah

you want to accept

yeah okay so they have the error as

Yeah. Um uh okay, this is fine. Uh Z

type.

Yeah, but this any Z type uh I wanted to

use

uh

should I

just install this the version three of

the All right. So I think I'm going to

uh install the version I used before.

Uh so for that uh let me go inside of

this. Let me actually close all these

terminals.

Let me open this one and I can do ppm

uninstall. I hope this is the command.

So pmp is done and uh the package I want

to remove is z and it is inside of 3- fa

and it's going to be inside of uh

packages

packages and inside of the common h. So

let's remove this.

All right, it's removed

and now we can go ahead and uh install

uh a new version. As you can see, this

one is removed. So, we can go ahead and

install a new one. All right. So, now

it's inserted. So, let me bring back

this command, but instead of answer, I'm

going to say

add and I'm going to give it a version.

So, version three, I guess.

Yeah.

All right. So, this is the version we're

going to be using for Z.

And uh this time I I hope uh we have

what we actually need.

So, it's over here. And I was looking

for

any any object. Perfect.

And also we need some type of so let me

let me say uh let me say type and this

is going to be the schema. So the schema

of of this

and uh I can make it to be any object

uh or it can be the

can be the z type of any

uh it can be this one z type or

h so we have the z type let me actually

import it as z type any Yeah, perfect.

So, this is what we have first. And the

second one is going to be uh the type

and this going to be the palams. So,

let's say palams

uh record. Okay, paral record. And this

is going to be a record of

string uh not schema but also a string.

And the third one is going to be type.

And this is going to be this is going to

be query liquid. But let me see. So we

have the string and also it can be just

uh unknown.

All right. It can be just unknown.

Uh wait a second.

Okay. So this is the types that we need

first.

And uh here I can go ahead and um

export. So let me export this going to

be the interface. So this is the

interface going to call it request

and you can say uh validation.

Yeah, this uh request validation

schemas. Yeah, that is great. So let me

go inside of this one. going to have the

body which is a schema the palams schema

as well and a query as well. So all of

them are optional.

All right perfect. So now we can go

ahead and do con we can say formatted

uh error. We can create error and we can

take in the error which is type of s

error.

Uh and instead of doing an object I can

just say

uh let me leave a space I can say error

dot uh dot errors and you can say map we

can get an individual issue or an error.

So what's the issue? We can get it in

here and inside of this one get the

path.

Okay, the path of this

and here I can say uh you can say

issue.path join with dot a dot and also

the message the message is going to be

uh issue dossage.

Okay, so this is the how we're going to

format our errors that we get from our

responses or our requests whatever and

export we're going to say export con and

we can say uh validate validate request

which is going to take in the schemas

and which is the request validation

schema that we just created the

interface we created and inside of this

we're going to return so we're going to

uh return uh request of type request.

Yeah. So, we have the request of type

request

uh response of type response. But I

don't think you're going to use

response. So, for now, let me uh just uh

make it as

Yeah. Uh response. Sorry. Yeah.

Response. Come on.

Like response. Yeah.

Let me check. So you have imported them

over there. That is fine.

Uh let me fix this.

Okay.

All right. So now we can go ahead and

finish this. So inside of this lean

uh we can try a catch. So try catch and

inside of this we can say if um schemas

dot uh schemas do body and here I can

say um con

uh past body perfect so pass body equals

to schemas body.pass and we pass in the

request body and we can say it as

unknown. Okay,

perfect. And here we can just say

request do body equals to past body.

All right. So outside of this if the

schema is body we can also check if it's

paralams. So if schemas dopalams we can

go inside of this as well and we can uh

get the con pasts.

So pass palams equals to

schema.palams.pass

pass in the request.palams.

And this one I think we have uh the

palams liquid. So we can use this

uh yeah palams liquid. And after this

one we can say request palams equals to

pass palams and also we can pass it as

request and pass in the palms as well.

Okay. And u

let me see. Okay, so we're checking if

the body if is paral and also let's

check if it's query. So if query

we can do the same thing. So pass query

equals to uh schema.query pass query and

pass in this uh type we created

and over here inside of this one we can

say requestquery equals to pass query as

query as requestquery.

And finally we can just say uh next

over here we already doing lat so we can

just call next here and if there's any

issue we can check. So if Ella is

instance of uh Zella

um so we don't have ZA installed

imported or we can just import this.

Yeah. So that error is imported and

inside of this one uh we can say uh next

we can return the new HTTP error. So new

HTTP that we have created here

and um so we can the status code can be

uh 422

and we can say uh

[Music]

hello

uh for the message you have radation

request failed and for the formatted

error I'm not going to do it this way

I'm going to create an object

And you can say issues. So formatted

error and pass in the L just like this.

Yeah. And also I don't like how I don't

really like when I like when I press

save and it format my things like this.

I don't I don't really like this. Uh I

think we can go ahead and set up u uh

where is it? Is it prettier? Yeah, it's

prettier that it's doing this. So we can

go ahead and I think configure it as we

actually want it to be. So let me do

that. So instead of my loot directory

here I can go ahead and create preier

uh preier. Yeah pretier dot case we can

call it config dot JSON.

So preia

doconfig uh not JSON we can just say

CJS. Yeah.

CJS and here we can uh create some

module export

and request to be equals to. So how do I

me for me this is my settings I like to

use. So for the semi semicolons I like

to set them to true and for the single

quotes as well uh I like to set it to

true. Okay.

Sorry about that. uh

single quote I as well I like to set it

to true and trailing comma all and for

the print width I like to set mine to


all right and uh yeah 100 and for tab we

use two now let me try saving okay maybe

not it's not applying I spot uh

my settings are not applying

Let me try to restart this. Um,

okay.

Yeah. Um, yeah, that's fine though. But

I just don't like how it's it's

formatting this like like this. I don't

like seeing I just like seeing things

like on the line, single line. Uh, but I

guess that's fine. We can live with

that. Maybe uh I will I will load it

later on. But yeah, for now this is the

settings I have my prettiest. So

config.js.

Um

yeah.

Um for for now we don't need eslint

settings. Uh we can leave with what we

have and yeah I guess that's like that's

really okay. Um yeah, so we have our

validate request here done. So this is

all we need to do to validate our

request. But uh before we forget, uh

let's make sure to return here. So

return

and outside of this one, we can also

return next with the error.

Ah, it's fine. Let me just format it.

All right.

So uh now let me cross this. And I think

this is pretty much all we will need for

this one.

Uh so that means we also need to create

the schemas to validate all of this like

the schema tool like when user is

logging in we need to validate the the

correct schema like the email the

password is is it full digital errors

etc etc. Yeah, actually. So, uh what we

can do now?

Um

should we connect to our database?

Yeah, we should connect to our database

actually. So, before I can be able to

start anything else, we should be able

to be connecting to our database.

And uh

uh yeah, so let me connect to my

database.

So uh for the authentication service

uh which database do we need to use for

authentication service? I think we can

use um MySQL for authentication.

Uh yeah for for I think we can use MySQL

for authentication but for other

services

uh we can use different different

databases. So for now we're going to use

my SQL for connecting to a database. So

let me go to Docker Hub.

Docker Hub.

All right. Uh we can search for MySQL.

This is the official image. So we're

going to be using uh MySQL for this one.

And we're going to use it, of course,

with Docker. So

yeah.

All right. Uh tech take tech take tech

take tech take tech take.

Um

all right. Uh so let me create a

database. So let me create a file. I'm

going to call it docker uh compos

yo. Okay. And inside of this one, I'm

going to call

create a database. So I can say

services.

And the first one we need to use is for

our MySQL.

And the version we can use version 8. I

think it's the

uh the stable one

that I'm sure that will not give us

error. So I prefer to use something I'm

not sure about that will not give us

error. Uh we can already give it a name

actually. So let me give it uh of DB. So

let me call it uh of DB. So for the

authentication we're going to use uh the

image is going to be um MySQL.

The version is going to be version 8.

So version 8.

And we're going to give it a container

name. So container name is going to be

uh chat up

and we can create with DB chat up

authentication database

right and for the environments we're

going to use

um

let me remove this let me check what

environment we need to use actually for

this one so the password I think

all right so we need the database. This

one, let me copy it.

Add it here.

And it's going to be uh hold on. And

we're going to get this from

our authentic uh our environment phrase.

Uh

yeah. So of DB name or if you don't know

how have it or if you do not have it we

can just get uh we can call it chat app

uh off and uh probably can just say

service

service

shut up of service.

Okay. So we're going to get it from our

configurations. And what's next one we

need? We need the user.

We need the user.

So let me give it this this one as well.

So of DB user or here we can just say I

want to keep adding the chat tabs. I'm

sure. So I'm pretty sure about what I

doing. So chat type of and um

yeah that's fine. shut up of user

and also need the password.

So we need this password

of DB password and here we can

uh shut up of password. Make sure to use

a strong password of course.

Okay. And uh we do need load password.

My SQL load password. Yeah, let me add

it as well.

password. It can be um

yeah, let's leave it like this. Okay.

So now we can also add a command. So

make sure to

uh go outside of environments and

stay on this line of image. Uh we can

give it a command. So command is going

to be this one. And we're going to say

uh MySQL.

So MySQL D. Okay. And we're going to

check. So let me add here.

Let me check. Actually do. to this need

this

like

take

[Music]

cuz last time I used it um

okay

I'm just going to add it anyways so if

if it doesn't work uh I will remove it

so default and it's going to say

authentication

uh authentication

authentication and we're going to say

plugin. So we're going to say get this

plugin

equals to my SQL

native

and uh underscore password.

So my SQD equals to default

authentication authentication plugin

equals to my SQL native password. Okay.

So now we can also define the ports. So

ports

it's going to be of GB port. By default

it's this one for my SQL. This is the

port it runs on. And we can set the

volumes.

So for the varium we can create this of

GB data and we can put it inside the val

lib MySQL

and we need to create a network so that

we're going to be using throughout.

So let me call it chat app network.

Okay. Uh so this is the authentication

database. Uh now we need to create the

network we just added and also the

volumes we just define uh the volume we

just added here. So let me go over here

and we can say the volumes is this one.

So the of data

of DB data we're going to add more if we

have and also for the networks we can

define this chat network and the driver

is going to be bridge.

Okay. So for now, this is what we have.

Let me open Docker. So if you don't have

Docker already installed, you can go

ahead and install it. It's pretty easy.

And uh now it's open. So

uh close this

close this stuff. And um

uh let's try to learn this. So I'm going

to open this. Can do docker compose.

docker compos

app dashd.

So let's try to run this and see.

Okay, so the port are not available.

What is learning? Uh

oh, this one is try to learn.

Do I have anything learning? Uh

no, I do not.

I do not have anything running.

So response are exposing portp

and address use

uh which oh okay uh I think I know what

is using this port. So let me go to my

settings

and I can just go to I have my SQL

server running over here. Um I can stop

this. Let me stop this my SQL server and

I can give it my password.

So yeah, I just stopped it

and uh cross this. Now let's try to

learning this again.

Compose app. Perfect. Seem like it's

started. So let me go inside of this

one.

Um

okay. So plug in lady for connection by

address.

Okay. Uh

Mhm.

Yeah. So chat use access to schema. All

right.

Yeah. This will be deprecated. So please

use caching. Okay.

That is fine.

We have our database ready and we can go

ahead and and we can go ahead and uh

start connecting to this password. So

also for connecting to our password

we're going to be using uh secretize

uh

what is the name securize?

Yeah, we're going to use this one to

connect to our uh my SQL databases. So

let's click on get started.

Uh we need to install this inside of our

um this one. So let me copy the name

and I can learn the command. So let me

do pinp add secret

and I can do filter

and we can go inside of my u services

of service.

Okay.

So we have the squares added and also we

need to configure NV for all the

databases that we just added. So inside

of my services of service inside of N

file. So we have this lady. This is

fine. And now we need to add the O and

we can say DB and we need just the URL.

Uh now let's show you how to get this

URL. So okay. So this is how it will be

like. So we need to add the name which

is my SQL that lands on the uh user. So

this now we need to add the user.

Uh okay. Uh so user password. So the

user is this one. Shut up user.

And now we also need to add in the

password.

So

MySQL password.

So let's add in the password.

And we need to specify where it's

learning at. So it's learning at local

host on this port

and the database name. So the database

name uh this is the database.

Yeah, this is the database.

All right. So, this is the URL

type user shut up with password local

host and uh that's fine. And for now, I

can set the O and we can say

uh DB and SSL equals to false for now.

All right. So, this is done and now we

can go to our config file. So we can be

able to add this. So inside of sic

config m file

uh we can add uh the remaining. So we

have the m file we have the port and now

we can add the URL. So of db url which

is of string and this is going to be dot

URL. Okay.

All right, that is fine. And now we can

go ahead and start connecting to our

uh database. So inside the src, let me

create a new folder. Create db or maybe

you can put it inside the config folder.

It's fine. Let's create a new folder and

inside of this one. Let me close this.

And I'm going to create a new file. I'm

going to call it uh

sec. So let me make sure I get this name

correct.

TS. So S E A S. Okay, that is fine. And

now let's import it. So import uh tech

importize.

So what do we need? We just need to get

the secret.

All right. So now let's import also our

MV file. So let me put it here. So in

import

all right uh so config

why is enough finding it again.

Wait wait wait wait. What's going on?

They do not we're already using this as

it is.

Uh

oh, there's a space. Okay.

All right. And also let's import our

logger. So logo and we got this. Now we

can do export

con uh con. We can say secretize equals

to uh new SQL. Let me just accept this

for now. But this is going to take in

just a m dot oft URL. So yeah, that's

all we need. And inside of this

we can say delet we're going to use not

posgress but we're going to use what?

My SQR. So my uh my uh

my SQL

so this is what the password and for

logging

uh we are going to we can depend also em

if it's cost to if the node m is equals

to uh development so if it's called

development

we can say

get a message so

message

with type of unknown

equals to to

say logger debug message and just to be

sure that we know it's from our our

database. We can just do it this way

otherwise we're not going to log

anything at all. And here we can define

so define

some settings.

So we're going to say uh underscores

underscore we're going to use to true

and uh freeze table names going to be to

true

and here I can do export con. We're

going to create connect database.

Okay. And this is not going to be a

promise of void

otherwise. Yeah, just like this. And we

can say await

authenticate. And here we can just log.

So

info

connected uh of database or I can say um

of database

connection

established successfully. Yeah, I guess

that's right. And also this another one.

So what cons we're going to create cross

database

and uh as sync.

Yeah. So this is basically it what we

need to do. And now we need to use this

inside of our

index.ts file. So cross this inside of

index.

And uh after actually let's try connect

to our database first. This is the first

thing we need to do. So we can do await

uh connect

uh connect to database.

Let me scroll down.

Connect to database. That is fine.

And let me use

this one.

Okay. Okay. So, this connect to database

and if everything is working well, we

should be able to connect to our

database.

Uh, and if our database is running, it's

learning. So, let me try to learn this

pinp.

Um,

okay.

Oh,

okay. Okay. So we we need to learn uh we

need to install this. So please install

my SQL2 package manually.

So let's install this package

pen pim.

Wait, let me just do that. So just just

to avoid to add

this again

my SQ

P again.

Perfect. So database is running it's

connected and you can see that I just

did pinp and it it know that we have our

services that need to be none. Okay. So

ppm rundev we can also do pland div uh

filter

and we can say uh to

services

of service.

Yep that's fine. Uh so our database is

connected successfully.

Authentication service connected and

also our port is running over here.

Great. So we have our database connected

which is my SQL database

and um the next possible thing that we

can do is uh actually

is create the user tables. So before we

can actually be able to create anything

else, we need to create user tables.

Yeah, let's do that. So for

authentication service, um inside of

models folder. So let me call models

folder. And inside of this one, I'm

going to create a user. And we're going

to create credentials.

user credentials dot model uh

model model.ts

user credentials.ts. So this is the

model that we're going to use for our

authentication

and uh let's import so import

uh let me just get it. So from

uh securize right so we're going to need

uh the data types data types sorry data

type types yeah data types and also need

the model

and we need the type of uh optional

this one.

All right and we need to import the

score. So import the one we just

created. Import securize.

Make sure to import it from the one we

created, not from the packages we

installed. So just go to uh here and

import it from DB and squize. So let's

importize.

Okay. And here I can do export. Uh we

can set the interface. So interface uh

we're going to use user credential

attributes.

Perfect. And inside of this one, I'm

going to have ID of uh we're going to

No, we're not going to use number. We're

going to use a string.

And here also, we need the email we made

the user, which is a string. We need the

display name of string. We need the

password hash. So, let's do password

hash of string. We need the created that

which is a date. Updated that which is a

date. And let's now make them optional.

Okay.

And here we need also to export uh this

time type. So type user credential

creation attributes. All right. Perfect.

Pass in this optional. So user

credentials creation attributes. Pass in

this optional. And we're going to pass

in the one we just created on top here.

And we're going to add uh ID

created that and updated that.

All right. And here we can do export

class.

Yeah, let's do it. Crash user cr user

credentials. This that's how we're going

to do it. Cut it. And we can uh let me

see

just a second.

So extend model user creation attribute

user credentials attribute and also the

user credential creation attribute and

implements user credentials

attributes. Okay, perfect. And inside of

this one we're going to have so uh come.

So we're going to declare this id which

is a string also the email which is a

string. So basically everything is going

to be uh a string a string for the

password for the created that is going

to be date and for the updated that it's

going to be data as well.

Okay

perfect.

And now we can go ahead and actually

start defining our tables. Okay,

so user credentials.init

and inside of this one we're going to

define our tables. So uh just a second

and here going to say ID. The id is

going to be um

type. So the type equals to data types

id uh it's going to be a primary key. So

it's true and default value is going to

be data types

version 4.

And for the second one which is the

email. So for the email uh we need to

say type data type string and allow n is

going to be to false.

Okay. And um unique is going to be true

for the email. And for the validate we

can use

uh is email is going to be to true. So

I'm validating making sure that this is

an email but also we're going to

validate again with s. So this is just

to be safe. So on the safe side uh let's

go outside of here. We need to do the

same thing for the password hash. So for

the password hash we're going to have

the types equals to data type string

alone. n is going to be false and for

the display name

uh we're going to have data types of

string as well and alone null is going

to be uh false as well and now let's go

ahead create that so for the created

that uh it's going to be data types dead

uh default type is going to be now so

same thing for the updated that so alone

now is going to be for as well and

outside of here but inside of this one

we can say uh secretize and also table

name give this table name as user

credentials.

All right.

Uh

okay.

All right. So

[Music]

all right. So we have this now and um

take we need to create a new file. So

going index

ts and this is where going to import all

of this stuff. So let me get what I need

first. Uh, for example, this I need this

again. I need to use it here. And I need

to import the model just created. So,

uh, I like to use it.

Uh, come on guys. Uh, DP

take take

not on models.

uh yeah models and user credential

models. So now you can do export

con and you can call it init uh models.

So this is going to make sure that our

models always there can do await uh

securize dot sync.

Okay. And I'm not going to I'm not going

to set any settings here.

But here I'm going to export

uh user credentials.

All right. So now we can go inside of

our index. So our main index folder

file. And after this one we can say

await

uh init models.

So make sure that our models actually

exist

and we can just yeah inside the models.

So this will make sure that our models

exist. We can just run it quick to see

npm rundev. And this one is going to

create these models we just defined. So

yep. So everything is running still

running as it should be running.

And now let me close this. Okay.

Okay. So we have this ready. you have

most of stuff we need

um inside of when we shut down I need to

make sure so shut down the database

correctly so cross

database so we have it now so we can

just call this one so cross database as

well when we shut down our server okay

perfect so we have our models

Um

this is okay. Uh but we also um

we also need another table here which is

going to be for our refresh tokens. So

refresh tokens and user credentials are

not going to be in the same uh stuff. So

we're going to create a new one. So

refresh

and I'm going to call it refresh token

dot models do just model.ts.

Okay.

So uh this is going to be similar to

this one. So you can import this to

settings over here.

And also we need to uh get the uh where

is it? We need to get this user

credentials because we're going to

somehow connect this to it. So models

user credentials.

And now you can do export uh interface

refresh token attributes. So we add the

ID. We need the user ID. We need the

token

ID which is a string. We need the

expires art, created art and updated

art. All of them are going to be dates.

Okay. So, we can do export and we can do

type and we're going to be refresh token

creation attributes. Okay. So, it's

going to be optional.

And inside of this one, we're going to

have uh refresh token attributes.

And now we're going to have this one. So

ID created that and updated that.

All right. So now I can do export uh

crash refresh token

and same thing we did before. Um

so do this one. We're going to have so

extend model refresh token attributes

refresh token creation attributes

implements refresh token attributes. And

inside of this one we can create the ID

the user ID string the token ID expire

that created that and updated that

so it's basically the similar thing we

just did but this is for different model

so refresh token in it and inside of

this one we're going to define what we

have so ID for the ID

uh it's going to have the type of U ID

primary color primary key is going to be

to true and the default is going to be

version four. For the user ID, we're

going to use um the type of U ID allow

equals to false.

And outside of this one, I'm going to

take the token ID

and token ID is going to be type of um

let's use let's use UID as well. UID

and Alona is go to force

expert that

it's going to be uh dead alone now is

going to be for as well

and uh created that

like

uh

wait

me remove this. Yeah, the default is

going to be now

I don't first. So, same thing for the

update that

boom. Yep. So, this is it. And now let's

go outside of this one.

We need to say the score and also need

to give it table names. So, refresh

tokens.

Okay. And now we're going to connect

those. So let's say um

user uh user credentials dot um has

wait has many passing this refresh token

and inside of this one we can say the

frame key is going to be user ID

and it's going to be this user ID. Okay.

And as

we can just say uh refresh tokens

refresh tokens and also can on if we do

this we're going to cascade this we're

going to delet it with it. So let's make

sure that user ID is the same one as

here.

Perfect. And we can do the same thing.

So the first belongs to user

credentials.

And inside this one we can say friend

key user id as user. So this will

connect it together.

All right. So now we can go back to our

index file. So let me open this. Inside

the index here I can also uh

import the refresh token. Uh but I need

to of course to take

uh uh take uh uh uh uh uh uh uh uh uh oh

okay actually uh it's not in the same

thing. So I need to import it

separately. So

import refresh token over here and you

can just add it.

Okay. Uh so we have this ready

and um next thing we can do

is to type uh like what can we do? So we

have the models ready. We have our

database connected. We have the models

ready as well. Um next product thing I

think

is to create

uh

what is it to create the service to

create this or can we just validate them

like creating the the actual types that

we're going to need. Um

yeah let me create the types that I'm

going to need so we don't have to come

back to this. So inside of sic inside

that you folder

and I'm going to create

ts.

So export uh interface and this is going

to be for the logist

register input.

So we're going to have email

of string password

and we're going to we're going to have

display name. So display name of string.

So we're going to do export interface

login input

email and password

and also we're going to have export

um interface.

interface is going to be a user

user data.

It's going to be ID string image string

display name string created out of date

and also export uh interface

going to be the off token

and um going to have access token of a

string and also the fresh token of

string

and finally we're going to have export

uh interface.

This is going to be of response

extends

the of uh token.

Wait, what did I call it? This should be

of tokens

of tokens.

And inside of this one, I'm going to

have the user as user data.

All right. So now we can go can probably

go and um

create the service we need. So inside of

here I'm going to create a new folder.

I'm going to create services or services

and inside the services I'm going to

have and I'm going to call it dot

service.ts

of service.ts. this and uh

I need to import stuff I need but first

of all let me do export

con and this is going to be for

registering user so register is going to

be a sync and we're going to take in the

input

which is of the register input we just

created so register input

from the types and this is going to

return uh a promise

of void or we can use our off response

we created as well.

Perfect.

And inside of this one I'm going to have

so check con existing. So we're going to

check if the user exist. We can check

our user

credentials from the the input from the

models we created. So user credentials

dot

uh find one. So find one and we can

check. So where

the email is equals to

um

how do I want to do this? So let me use

this and you can check

need to import this from the securize

and equals equals to input.

So make sure you import this from

square.

Okay.

Operators in unique symbol. Okay. So

import.

So if this is not the case or if this is

the case so if existing

what we need to do we can throw a new

error. So throw new uh instead of uh

errors we already created an util http

error. So let's use that pass in the

status code of 49.

Uh you can say user if this email

already exist

and here we can do uh can say so we can

start close transaction

uh if the user is not there so I wait um

securize let me put secretize

from DB so make sure you put score from

DB the one we created and you can say

transaction

okay so this start our transaction.

Okay.

All right. So after this one, we can do

a try catch.

Instead of the try, I'm going to do con

uh let's get the password. So con uh

password

hash is going to await

uh secret

uh wait. So I'm going to use await.

We need to create a method to hash this

password. So

let's create some UT function. We can

use this. So instead of putting

everything inside of here, let me create

a new inside the we have the logo. Now

let me create a new file. I'm going to

create token. So here we're going to add

all our that we need for the tokens for

hashing password etc etc. But first of

all they need install. So, pam

add pam add uh bcrypt

and I'm going to add it inside of um

services of service

like wait did it uh

ppm add okay I think I need to try

finish this command

beta Uh

all right so I just added it and also I

need to add in the uh JWT token while

I'm still here. Let's add it. So JSON

web tokens we can just say uh JSON web

token.

All right. So that is done. Now let's

import them. So import

uh brypt

brypt from brypt

import JWT from JWT. Uh we need to

insert their types as well.

Uh let's do that. So let me bring this

command again.

Let me add this as the dev dependencies.

So is to reinstall them as dev

dependencies. So the

and also for the

brypt as well.

All right. Uh that is done.

That is done. And uh now we need to add

more uh environment variables that we're

going to be needing for this.

So let me add let me add them while we

are still here. So

the first one is going to be JWT secret,

JWT experts in and JWT

uh uh take JWT

refresh secret not in but refresh

secret and JWT refresh expose in

for this one we can make it 1 day or 15

minutes.

Uh but that's fine. So let me go inside

the M file inside of authentication

service.

So inside of this M

we need to add them as well. So over

here after our database URL we can say

uh we can get the GWT secret

and this is going to be a string

uh going to be a string and uh we can

set

yeah minimum is going to be 32.

We're going to have GWT express in.

Okay. Uh this is going to be Oh, let me

accept this. So JW secret JW expressing.

Okay,

just making sure it's the same.

Okay. Uh so we have GWP exping the

default is one day

secret 32 GW2 refresh expassing string

default is 13 days 30 days.

All right. Uh that is fine. That is

done. Let's go back to token.

And now we can do cost. Um let's get the

access token. So access

uh we can call it token.

Say token. It's going to be of type

secret.

So we can import secret from uh JWT. So

let me show you. We can say

type and we can say secret

and also we can say type and we can get

the sign in uh options.

We're going to use this. So let me

create secret. And instead of this one

just

from our settings and you can call it

JWT secret.

refresh secret uh GWT refresh secret and

also need the cost uh access

uh we're just setting this ready. We're

not going to use them now but options.

So we're going to use sending options

and we have the expires in

equals to M express in and here we can

cast this as

uh sign wait

let's sign options

express in

okay so also refresh options so same

thing

exposing.

Okay, that's fine. And now do export uh

cons. Let's create the method to hash

password. So p password it's going to be

uh async.

Async is going to take in the password

of string. It's going to return a

promise of string. And you can do

consult lounge. It's going to be uh

we're going to use 12.

And here I can do uh return

brypt.

So password and pass in also the source

lounge. Okay. So this is what we need

for us to be able to hash the password.

So let's go back over here. And now we

can start after this transactions

transaction we can do await uh hash

password

from the ut and we need to pass in the

input dot password. So this is the

password we're hashing.

We can do con user equals to await

uh user credentials dot create uh create

So we create this user with this

details. So email input email display

name input display name and password

ash it's called password ash

and let's pass in this transaction. So

transaction.

Okay.

Perfect.

All right. And uh after this, so after

we have done creating this, we also need

to create the refresh tokens from our

models.

So for that to happen

I need to create a new method

uh over here still inside of

authentication service

uh I think again let me see uh okay uh

let me create an outside of this one let

me create a new method so let me call it

con

uh con and you can call it create

refresh H token

and this is going to be uh a sync

and it's going to take in the

user uh

user ID of type string

and also a transaction which is optional

and it's going to be type of transaction

transaction from a secret.

Okay. And inside of this one, I can cost

uh

expire

which is new date and expire dot set

date expire. Get date 30. Uh we can

actually use our M file. So instead of

doing this can say refresh

uh

like not add that uh on top over here.

Let me add a new. So I can do con

refresh token

uh refresh token. I can say t

and

underscore

uh where is it? Uh

I'm getting tired.

There is ttl

instead. Yeah, it's TTL.

All right.

So, let's go back here and we can use

this here. So,

instead of hard coding it like that and

over here uh so this is just

30 days from now

and here I can do con and you can create

a token ID. So token ID is going to be

crypto.landom random UU ID

import crypto actually. So import crypto

from crypto. You do not need to install

this

from random EU ID. And here we can

create the record. So con record

it's going to await uh refresh token. So

the refresh token from models docreate

and pass in this data. So user ID,

token ID and expose that and also pass

in this uh transaction

and here we can return uh not here but

yeah we can return code. This is now

going to be creating our tokens as well.

Uh so now we can go back and use it

here.

So after creating the user

um after here creating this user

uh okay so after transaction over here

still inside of the try catch we can say

con uh refresh token record equals to

await create refresh token pass in the

user ID and also the transaction

and here I can say await transaction dot

commit it. Okay. So, committing the

transaction.

All right. Um, so we need to use this

token we created. Um, and we need to

sign them. And also

same thing for the refresh token. We

need to sign them.

Okay. So for this we need to create new

methods. So for signing access and also

for the refresh token. So let's go back

to token the ut file we created going

create a new file method con um

uh yeah let's create this verify

password so we can finish with this one.

So verify password. It's going to take

in the um async password as string hash

password of string. It's going to return

a promise of boolean. And here we just

need to return this

uh brypt compare password. So that is

done and now we can go ahead and start.

So export

uh interface

and we're going to get the access

token. Uh we can say access

uh access token

and we can call it

payload

access token payload and here I can do

sub is a string

email

which is a string. Okay. And let's do

the similar thing for the refresh token.

So

uh take so refreshing token period sub

and also the token ID.

Okay. So now we can create the this test

export cost and we can say sign

access token. We're going to take in the

payload.

So access token

we usually return a type of string. And

you're going to return

GWT

sign payload access token and also with

the access options.

Same thing for export coins sign refresh

uh token. So refresh token payload

refresh token payload string sign

payload refresh token and last method is

to verify. So the export cons and let's

verify this

uh verify access token

verify

refresh token.

Yep. And I'm going to take in the

payload

payload

and the string

this. So payload refresh secret as

refresh token payload.

All right.

So we have this. Now let's go back to

our authentication service. So after

this transaction commit we can say cost

and access token. So let's get the

access token. is going to be equals to

uh sign

access token

and we can get the sub which is the user

id and the email user.mmail.

Okay. So cost

refresh token

sign access token uh take

uh refresh token send access token

uh this is we already have this me uh

refresh token.

So sub= to user id token id is got to

refresh record token record and get in

the token do ID the one we created over

here.

Okay.

And here let's create a user data. to

cons user

data

because later on we need to publish this

data to our user service with um a bit

MQ

uh events. So email

goes to user uh email display name user

display name created that

created

at

okay user that's created that and let me

let me say to

[Music]

string

all All right. So here we can add a

little to-do to-do

publish event user registered.

All right. And here we can do return

and we can turn the access token

refresh token

and the user is going to be user data.

What's the issue here?

Uh

user is a of response.

Okay. Uh so ID take user data.

What's the issue? Let me go to my types.

So instead of the

uh types

uh we have the user data we have the ID

string string

and oh this is supposed to be just a

string sorry.

All right. So that is fixed now.

And uh what's is the issue?

Um this should be good. So inside of the

catch we can say our transaction. Lord

bike and also throw an error.

Okay. So this is just we are booting the

transaction if something goes wrong.

We're we're going to come back to this

to add our like publishing this event to

the BTMQ uh events. So the user service

can know that we have a new user just

registered. But this is the whole idea

for creating the user for registering.

We're going to come back to add uh one

more for logging in for and etc etc.

Yeah, this is not done yet

and we're going to test it.

But I think

uh

we can maybe create the controllers for

this as well.

Uh let me close all of this so we don't

get confused. So inside of the services

src

and we create controllers

and we're going to use the off dot

controller.ts

and here I can do export

cost and I can say uh call it register

register.

Let me call it register which is going

to be equals to

uh request. We need to import that. So

request

uh request 100 just a second. Let me

import that. So import

from express

and we're not going to use this async.

We're going to create our custom async

handra.

Uh let's actually do that. Uh it's going

to be inside of our common since we're

going to be using it everywhere.

So let me close this. Inside the

packages common inside of s http folder

I'm going to create a new one. I'm going

to call it async andra.ts.

Okay.

So I'm going to uh import

the uh all the types I need from

express. So index function request

handra. And here I can go to export

type and this is going to be of async

Andra and it's going to take in the

request of type of request

okay request response of response next

of next function and it's going to

return unknown okay

promise of unknown and here I can do

cost

to uh error

And it's going to take in this error and

it's going to be unknown.

And let's turn this error. Inside of

this one, we can say return

error instance of instance of error

equals error new error string error.

And you can say con uh forward forward

uh error. And inside of this one, we can

take in the next function.

Next function, she's going to be

taking the

uh let me get error for

I take

uh

we need to create this type. So

type error for it shows which is equals

to wait for now let me do this which

taking the error for of error of type

error actually

and it will return void. So error for

weather and also we can get this

error of type unknown

and inside of this just next function to

error. Perfect. So now let's create our

actual method that we need. So export

con

async

and we're taking the handra of asyncra

and also the request hra

inside of this one we can return

request response and next and we open

this. So let's use void.

So void uh hra and click in the request

response and next.

So also next dot catch error and uh take

do I not do this catch error.

Yeah. Uh but let me actually do this

first.

So let me get the error. Okay.

But I'm going to open it like this as an

object. And also let me cast it as a

noun.

And inside of this one you can say for

error equals to next

as error for weather and also the error.

Okay. So this is our async handra and we

need to do

uh packages

and come on

what's going on.

Uh,

I'm sure we was we were using this

command before,

right?

This is the build command.

Oh, we don't need to

uh

Okay.

Okay, maybe I'm doing something wrong.

Um, I'm really tired, guys.

Uh,

did I forget to export it?

Uh, okay.

Export everything from HTTPS.

Uh, yep.

Uh, all right.

Let me open this again. Uh

okay, this is done.

Uh yep, that's fine. That's fine.

So the services of service controllers

of controller and I can remove this we

added here and we can use our async

handra from the common directory and

inside of this one I need to pass in the

async

and

uh take tech I think sync.

Yep. So this going to be using it. And

here I can get the con payload uh con

payload

to request body dot as register input.

So the type we created.

Okay. And also con tokens

to await uh register

uh take

register. So from the services of the

service pass in the service and we can

do rest dot status

and we can pass in the status of 201

JSON. All we need to pass in is the

tokens.

So that is all we need to do for this

like this is everything for our

controller. So most of the stuff happen

is inside of our service and we just use

the controller to uh call it.

Okay. Uh so last thing before I stop

this and continue recording other time I

need to go inside of my louds. I need to

create louds.

We already have the folder but we didn't

created also the file but we did not

really uh start working on this

and this will ask us to also validate

uh so let me import this two

validate request who created this why is

he not

why is he Not.

All right. So, let's import uh the LA

from LA

and let's create. So, export

cost

of LA is goes to LA.

It's going to be type of FL

and here you can see

dot post.

The first one is going to be on register

but we need to validate the request of

this. So for now, let me do uh validate

request uh validate request.

I believe we created this.

Uh

shut up. Come on.

Wait. Okay.

Did we not export it as well? Um,

yeah, we probably did not, did we?

Yeah, I did not.

So, make sure to export it over here. Um

take

and this is going to be from uh

take val request.

Okay, let me let me build this again.

Request.

Okay.

I'm so dead, guys.

But I really want to finish this before

I can do anything else.

We need to pass in the schema. We don't

have the schema now.

I will add it. I will add it like next

time. But for now, I just want to finish

this register uh 100 from our

controller.

And next time we're going to be adding

our schema for this to validate all data

we are sending. So uh let's finish this

up. Let's create a new file inside of

routes index.ts.

And here I'm going to export

cost

uh credit register

uh loads

register notes. Yeah, taking the app

of type router from express

and this is going to just be app dot use

and we're going to use offload

from authentication loads

or if you prefer we can just use this

one

uh like

okay hold on

H

don't

uh let me do loads out and loadouts.

All right. So this will be our main and

now we can go inside of app

um

inside of our index. No inside of our

app.

Uh yeah, inside of our app finally

that's this going to this. So after this

middle we can do

register routes passing the app.

So this is all we need to do. Next time

we just need to add we add them there.

But let's just pinp

to see if nothing is broken.

Yeah, it is. There is nothing broken.

Uh what are we missing?

JWT secret is missing.

JWT secret is missing. Take. So this is

our validating our AMV um M container

Trist.

Mhm.

JW secret. Do we not have it inside of

ENV?

Oh okay. That's because we have we are

saying that we need more than uh 32

characters.

Uh here we can use um

uh

JWT key. Okay. Uh we need to

uh

copy and I can go inside of my M file

copy this

also. Let's refresh another one for the

refresh again.

Yep.

Pimp man div.

Yeah. Now everything's running. So you

show you saw how our validating works of

our uh secrets when we are not they're

not matching what we have defined over

here. You saw the message you get.

Uh yeah, it's pretty cool, right?

All right. So, I'm going to stop here,

guys. Uh but for you, you will see a

full video, but for now that it's very

late. It's like Yeah.

All right. So, I'm stopping here and uh

we continue with this one. But we're

already making some progress which is

good thing. Uh we made some mistakes but

yeah that's part of the journey and um

yeah let's go ahead and finish up this

authentication and uh and create some

more interesting stuff. So yeah let's go

ahead and finish this.

All right. So anyways uh let's continue

now and um

uh so we have our loads. So we have this

inside the loads

we have this validate request but

there's no schema yet. So we need to

validate uh of whatever we want to

validate how I want stuff to be like. So

still inside the loads I'm going to

create a new file. I'm going to create

of schema.ts.

And inside of this one, I'm going to uh

import Zord. So let's import Z from our

common packages.

So Z and it's going to come from

from chat app common.

Okay, that's all we need to import. Now

let's export cons. The first one is

going to be register schema. So let's

make it small capital

register schema. Yep. And

inside of this one, the Z object, going

to have a body. So, let's have a body.

And inside of this body, it's going to

be Z object as well. And inside of this

one, what do we need? We need the email,

which is a Z string. And email. We need

the password. Okay. So, we need to have

the password, which is a Z string. And

the minimum we can have uh not six but

maybe let's make it eight. So this

depends on you on what you want. And

finally we have the display name. So if

you remember this is the only thing we

need since this is just for registering.

So registration

service we do not need so much

information. This is pretty enough. Now

while you still here let's create

everything we need for now for logging

in. So the login schema is going to have

the body as well.

And inside of this one, I'm going to

have the email and just the password for

logging in.

Okay. And uh next one. So export cons.

This is going to be for our refresh uh

schema. So refresh schema Z object as

well.

And inside of this one, I'm going to

have in the body Z object.

And I'm going to have um just one thing

which is a le token of type of string.

And uh yeah,

this is pretty much all. And lastly,

let's do export con. This is going to be

for revoking the token. Sorry. Uh the

schema rework schema which is object and

inside of this one type I'm going to

have the body Z string

and inside of this one I'm just going to

pass in the user ID. So user ID

Z string and it's going to be type of VU

ID. Okay. So now we can go ahead and use

these types or these schemas inside of

our LS. Actually let me close everything

over here and I can go inside of the

clouds. So we have this valid request.

Now we need to pass in the schema that

we need to have. So register

uh register schema.

Uh oh, we need to first um

pass in as body. body and we pass it

register schema

register schema uh schema. Yeah.

Yep. And we can get the shape and also

the body.

Okay.

So body register schema shape. Okay.

appreciate the shape and inside the

shape we have this uh we have defined.

Perfect. So this is all we have for now

and uh while I'm still here let me just

get this um it's inside of

inside of the

inside of this one. So the loads

inside the

Yep. So this is all we need to do and uh

take loads of schema.

Fine. So we have the loadouts and also

the loads we are ready loading them

inside of my index ch not index but

app.ts we are registering these loads

that we have added. Uh let me make it as

loads as well.

Uh not just the let's see

right this should be good

and um

yep so actually this endpoint I think

it's working

we can test it um but for testing this

just for now but we are not done we want

to call this from our API m uh gateway

not inside of this um thing inside of

this like just direct you to the service

but just for us to test and also let me

learn my database again

and instead of this one I need to should

I use Postman or should I just use

um directory inside of Visual Studio

Code I'm thinking

now

yeah let me for now just to test let's

use Vis Visual Studio Code

But make sure you have this extension.

Um

what is the extension again? Rest client

where I think is this is the name. So

this client

yeah make sure you have this extension

uh for for you to test

uh inside of the API course inside of

Visual Studio Code. You can use this

extension so you don't have to install

something else. And also let me make

sure my

thing is running. So this is my

database. Let me start my database

and uh table press. So I'm going to be

using table press to uh see my data.

Um

yeah. Okay.

So this is what I use. Uh and I need to

create a new database. So let me go to

connection

uh new

and I'm going to choose uh my SQ using

my SQL for authentication service create

and let me give it a name.

Uh the name is going to be wait what's

going on? Uh

okay. New MySQL create.

All right.

And uh we can call this we'll give it a

name so we know that it's from our chat

app and you can say

of uh service.

Okay. And for the host it's local host

that is fine. The port that is fine. We

did not change it but we need to fill in

the user and the pass user password and

the database. So let's get those inside

of our editor. We need to get those. Uh

let's go to the services

and file from our authentication

service. We need to get the username.

We need to get in the password.

Okay. And also need to get the database

name.

So that is fine. Now I can click on test

test and also I can just uh connect to

it.

All right. So now you can see that we

have our two tables. So we have the

refresh tokens and also we have the user

credentials one.

So refresh token is over here and user

credentials are created.

Now

guys, oh now let me uh create a new

file. So for you to be able to use rest

client you need to create a file in this

specific name. So let me call it request

request http. It must be named this way.

So don't forget to add http at the end

as extension. It can be anything based

on the name but make sure it ends with

HTTP.

And let me close this. And um the first

thing you need to define uh we need to

define our lo but just to test. So let

me call it post and inside of this one

uh can give it a

I forgot how this work. Um,

well, how do you use this again?

Uh, uh, let me check the extensions

again. This grand.

Oh, yeah. So, you have post. Let's check

actually this example. Let me paste it

here.

And I'm going to change to what I need.

So, this is the URL. Let me start my

server.

Uh let me start it again. So pinp

div

my database is running on this port. So

local host port 3000.

So HTT uh I can just say

HTTP and here I can say local host

and the port is 3000 register. But if

you remember inside of our services

uh src

loads

of loadouts yeah we have this as

register but inside the index we also

added this so it must start off then it

goes to the register

so inside of here I must include this

one

and also I don't have to add this

and what do we need when we registering

so let's check our services.

Uh we need to add in

um the youer email display name uh email

display name and the password. Actually

I think that that is everything.

Uh yeah. Okay.

Yeah. Uh controls

register input. So the email password

and the display name.

So let me add those.

So I'm going to add in the uh email

uh display name

and finally you can have the password.

So I can say test

user atacample.com

and the password can be uh

no this is not the password sorry

uh password here and here I can say test

user

so our database is running our server is

running now we also don't have anything

inside of the table. So, both of the

tables there's nothing. Now, let me hit

the post request. Yeah, it's check if

it's the post

and inside the loads of loads is post

load. Okay.

So, I'm going to send the request.

Um,

oh, this is supposed to be 3,3

not 3,000 port.

Let me hit the request again.

Oh, wow. Look at that.

On the first try, it actually worked.

And the data we are sending. So access

token has created, refresh token has

been created and the user uh data has

also been created. Now let's check our

tables. So let me just refresh this.

So on the user credentials we have uh

this. Let me just arrange them

name.

All right. So let me just click on it.

We have the email password and also the

refresh token table.

You can see we have the ID, the user ID,

token ID and uh expire that created

that. Okay.

So let's check this user ID. It must

match the user we have uh over here. So

let's see. Let's end with A6BD

and the user ID over here it is A6BD.

So it's the same user from this tokens

belong to this user.

So so far our system is working as

expected. But this is not how we want to

use things. Um

but just for us to test this uh this

should be okay. or maybe even before you

even go further

will it be appropriate to set up uh API

gateway right now so we can go and build

on that on top of that as we go like

before go ahead and start building so

much stuff I think it would make much

sense actually to build the API gateway

and uh uh work our way on that but for

Now you saw that what we created is

working. I just wanted to show you that

it will work without any issues.

Perfect. So uh I'm thinking we should

work on the API gateway right now. Set

it up as we did with other services.

And yeah, let's go ahead and actually do

that. Uh so for the API gateway, it's

going to be uh pretty much the same

thing we did for the authentication

service. And as I told you, this is

going to be pretty much uh the same. So

for our services. So what I'm going to

do, I'm going to go inside of my

services and I'm going to create a new

folder. I'm going to call this get way

and service. Gateway service.

Okay. Uh just

Yeah. So get to service and I'm going to

do pinp in it

and I can say filter

um

filter. Yep. Uh filter and I can go

inside of services

and gateway service. Hope this work

p

doesn't work anyways. Uh let me see the

entries. So CD services

and uh gateway service

npm in it.

All right. Uh

okay. So we have initialized this and um

now we can take this uh settings for our

authentication service. Dts config. Copy

this file. Go to gateway. Paste this

file. And I don't think let me just

close this. And I don't think we need to

change much. Actually, do not we don't

have even to change anything at all. So

as I told you, it's going to be the same

config file for all. So this is all for

our au.

And um

after this we need to create the SCC

directory. So s

and also we need to add some packages

that we're going to be using. So same

packages we used. Uh so let me do npm

add. I need to add the course. I need to

add axios. I need to add express.

I need to add a hermit

and Jason web. Uh

not sure. Yeah, but it's fine. this web

tokens.

So let's add these.

Okay, those are added and I think you

can also add their types.

So let me bring back this command. I'm

going to start from the beginning.

I'm just going to add it as de

dependencies and I'm going to say types.

Okay. And here I'm going to add the add

tapes as well.

Add tapes.

Add tapes.

I don't think for JSON web tokens we

need any but

let's do it anyways.

That is done. And if we check now we

have these dev dependencies and this

this is everything we need to do but uh

let's go to the authentication service

package digestion we also need to get

use for our

workspaces

our package command folder. So let me go

inside the gateway. Let me add this as

dependencies

and that means we can also ppm install.

Okay.

All right. So now we need to set up the

server. Uh the start of the server it's

going to be pretty much like like

literally the same thing for

authentication service for the server

etc. So the app service this is not

going to change at all. Let me copy

copy this content of app service. Let me

go inside of the gateway src. I'm going

to create app.ts.

Paste this content.

And don't worry about the errors for

now.

Uh we need to add also the yeah don't

worry about these errors. Just follow

me. And now let's go back and we're

going to go inside authentication

service src index

and index as well. The same thing uh

expect uh we're going to remove most of

the stuff but copy the content of our

index

src and add index.ts.

Copy the past the content.

But here we're going to move um

these models. We do not have models. We

don't have database to connect to.

And for config, it can stay there. Let's

now remove this.

And uh this one for the shutdown uh we

don't have anything else to shut down.

So I guess I can just remove this

Let's remove this. And um

let's change the name. This is going to

be gateway service.

And

yeah, this is going to stay the same.

We're going to add our utails for the

logo as well. So the same logo we added

uh in our of service.

So let me go to of service src and

inside of YouTube

uh logo

copy this content

go back to gateway service create a new

folder inside of src utils and here I

can create logo

ts

okay and now inside of our index

I should be getting it Okay.

Yeah. So, let's change this. Uh, why is

the logo not? Um,

oh, we need to change the name as well.

This supposed to be gateway

where Oh.

Ah,

come on.

Close this. Make sure to be inside of

gateway service. Sorry, guys.

uh gateway service and um

okay index

the logo is not showing up yet.

Okay, the logo is there and for the N

file the same thing. So config m let me

copy the whole folder inside the gateway

src paste it

and for now this can be like this

uh we're going to add the ones we need.

So we need the uh node M. We need that.

Let me remove this errors.

So the node M I need to give the service

name change it to gateway.

So node M it's going to be this no

program. And for the port this is going

to be uh gateway port. So let me get uh

get port.

Okay. Now I need to add the service. I

can just leave it like this. Thanks for

the suggestion though. And we can paste

this on the bottom.

And this is going to be uh for

[Music]

this going to be the

service

port since it's the only port we have.

And make sure the default is going to be

on this port. And for gateway service,

it's going to run on 4 4,000.

Okay. And this is the authentication

service runs on this one.

So that is done. And let's go to index.

We don't have any more errors.

And this one should flow error. But I'm

not sure why still

of service port. Yeah, because we have

it of course. That's why instead of put

is going to be of URL

of service URL

and yeah of service URL string and it's

supposed to be URL. Yeah. So this is how

we're going to get our URLs for our

services inside of this one. So instead

of just saying uh so this is supposed to

be the gateway port. So

gway port

t that is fine and I'm pretty sure um

for the index jts file this is all we

need.

Yep. And now we need to finish our

app.ts as well. So we already have the

most of things we need. expect uh ex

just for the louds. We do not have this

yet, but we're going to create that. But

but we're going to use this. We're going

to use this. Nothing is changing. We're

going to use this as well. And for the

middle area, the error as well. I

believe it's going to be the exactly the

same thing for our authentication

service. So,

uh authentication service the middle. So

let me copy this middleware. Go to the

gateway s. Paste this middleware here.

Okay. And this is the error we're going

to have. Uh we're not changing anything

at all

and the test

uh etc etc. This is the same thing we're

going to be using

all over again. This is not changing.

Now let's go to app. The thing we are

missing is the routes. But uh let me

remove the routes for now. We're going

to come back to this one.

Yeah. So our server is set and now this

is fine. Uh let me try to run the

services. So pm n div. Uh let me cd back

cd

cd go to the loot pam land. And we're

going to land the both of the the

services.

Uh

okay.

Oh uh we don't have we don't have the

script set. That's why it's not

starting. So we need to also set the

script. So like I said last time inside

of the of service. This is the script

we're going to be using reversal. Let me

copy this one. inside the gateway

package.json

and the scripts I can just add this like

it's not going to change. So, yep, I

added this and now we can try to start

our services again.

And uh yeah, wait, what's the issue

here? Um

config.

Are we are we

okay maybe I need to add the M files.

So let me add it.

Uh I'm not sure about the issue I

getting here and I need to add in the

two that we are using. So the the

gateway is running on port 4,000 and

also we need to add in

our authentication service URL

which is going to be cost to http locost

and the authentication service is on

port 303. So let me try to run this

again. I'm not sure about the issue I'm

getting.

Okay. Yeah, it was the API uh keys

missing.

So pimp run dev now.

Okay. So our services are running here.

So we have this services and also the

gateway service running. Perfect.

Gateway service running.

Boom. Okay.

So our server is running

and uh we can go ahead and start

uh using this.

So let me just check how much time I

spent right now.

Yeah. So yeah, let me go ahead and uh uh

pause this and I'm going to come back

and we can keep working on the gateway

service so we can connect to our other

services. uh grace free and um we can

also set up protection. So like whenever

the service send a request to our

gateway they have to authenticate that

service and make sure that is the

service you are expecting like we don't

want to allow any service to connect to

us if you don't know about it. So we're

going to set up authentication for that

and all of those cool stuff we're going

to do that. So yeah, let's go ahead and

start implementing some of now. Let's go

ahead and keep working on this. So

there's uh a thing that we're going to

need. Um and I think the main main the

thing we made the main thing we're going

to be using is the

uh like authenticating or validating the

uh our APIs that they belong to this. So

like we need to validate if this um

service belong can make a request. So we

need to create some kind of uh

authentication uh middleware

uh that we can use. And I think the best

place to add that

uh is probably inside of the

uh packages.

So let me go inside the packages inside

of uh src

inside http I'm going to create a new

file. I'm going to call it uh internal

and

internal of so

we need to authenticate this. So I'm

going to import

import um the http error.

Okay. And here I'm going to import and

type.

It's going to be type but it's going to

be uh the request

handra from express

and I can do export con

uh interface

export not just an export export

interface and this is going to be

internal of options. Okay. So we're

going to need a header name. So we're

going to have a header name which is a

string

and also can be optional

and also uh there's some some u there's

some path that we don't want to protect.

So they're going to be ex exempt paths.

We're going to be a string of an array.

And here we can have con um default

header name. And we're going to call it

extern uh ex external internal and

address token.

Internal token. Okay. So this is a

default header name. This is our header.

And I can do export con. And we're going

to call it create uh create

uh internal of middleware. Yeah, create

internal of middleware. And here we're

going to say

expected token. So we're going to say

expected

token which is a string. So expected

token and also we have the options.

We have options

which of internal of options by default

they can be this empty and this is going

to return um the request handler.

So inside of this one I'm going to have

uh con to get the header name. So uh let

me do con header name which is going to

get from the options dot header name and

we can also make it to lower case. So to

lower case

okay and or by default we're going to

having this default header name we can

use this.

Yeah.

And next we're going to conce

this one uh we're going to have um so

going to check so If except paths we

have those from the request path we're

going to return next. So just next we're

going to continue. We're going not going

to protect anything.

Okay. So we're not we're not using this

one. We can just um add this. So if

there's this puff we're going to just

return. Okay. So we're just going to

continue. We don't go going to protect

those. But

outside of this so outside of this lean

outside of this uh let me see uh so

we're checking if so

actually still inside of this one. Oh

yeah, this latan here but outside of

this if okay after this if we can get

the so cost and we can call it provide

uh provided

uh here and we can call it from the

request do headers and get the header

name and next we can get the token token

is going to be cost to an array and

we're going to check is array passing

the provided

getting the first one otherwise just

getting this provided. Okay,

so this is

um wait

to do that. Okay, so here over here

we're going to check so if uh type type

of uh token is equals is not equals to

string. So it's not a string. Uh token

is expected token is not is expected

token. We're just going to return next

goes to uh new HTTP error

and anortorized.

And here we can just return uh this one.

And at the end here, we can just done

the uh uh the next which is the next

that which will tell us to just

continue. So I'm going to just explain

to you what all of this means. Uh let me

just go over here. So let me start on on

the interfaces that uh we have here. So

these are the uh the types and the

options. So for example the header name

which is a string and the except exempt

path or string array. So uh the header

name that means we can customize it. So

we have the name for each header and we

have this default header here. The

header name we can add another names of

the header we want. But this is going to

be our default header. And this except

path this is just an array of paths that

should skip this authentication just

like we said earlier. And yeah, that's

pretty much it. So, um, now I think we

can just move on. I hope you understand

what this the use of this is. And, uh,

we have next here. Make sure to return

here as well.

And, uh,

yeah.

So, we have the V request

uh, which is good. And um so let's

quickly create uh the schema also for

this uh gateway service for

authentication. So inside the s inside

of gateway we're going to create a new

folder and we're going to call this

validation

and inside of this one we're creating

the off schema

ts. Yeah, I know I'm doing a bit too

much of my editing, but I like to make

sure that my stuff is safe. So

and from um

add sign

and we have this

and uh for validating this uh it's going

to be a bit similar from the one we have

inside authentication service

allows

of schema

but we're not going to use the body and

actually uh it's a bit the same. Let me

copy this.

Go back to um gateway service validate.

Let me paste this.

This is going to be a bit same but we're

not going to have this body.

Okay, remove the body. And here I can

just

remove it.

And we have the email a string password

display name the same thing same thing

user ID refresh token. All right. So we

have the user ID which is a U ID. And um

yep. So this is all we need to add.

And uh next we can try to add

uh the services we need. and um also

yeah so let's add the services we need

but before we do that inside file so

inside of this M file we need to add

another stuff so let's add we're going

to be using internal API token so this

is the API token that we be expecting

all our services to come with when they

make request in the header so do we

expect them to have this API token so if

they don't have this we're going to

refuse close the the request and flow

some errors. Yeah, but for now, yeah,

make sure to add this. And also inside

the config m file, we're going to add it

inside of our M file as well. So after

the uh of URL, let me add this which is

going to be a string

and minimum is going can be 16.

Yep. Okay. So now let's go ahead and set

up our services for this. So inside of

gateway service uh gateway service src

I'm going to create services folder. So

services

and I'm going to create a new file going

to off and this is going to be proxy

and uh concrete service.ts

of proxy service. Um and if you remember

we installed uh we have installed Axio.

So yep. And now let's import also the M

file. So import

M.

Uh that's just M.

Yep. M from config. Now let's create the

client for the Axio. So con

is going to be Axio.create.

And here we're going to have in the base

URL which is going to be of URL and we

can give it also the timeout which can

be 5,000.

Now we need to pass in the header if you

remember. So of header

and here we can add the header that we

so we can say headers

and now we need to pass in the um the

name of the header that we have defined.

All right. So now let's check

uh wait let's check our uh request

validation that we just created to see

uh what we need to pass in the header

as. So over here inside the packages s

uh http uh yeah internal of we need to

pass in this x internal token.

So let me pass that proxy

and uh I need to pass it inside of my uh

axios when requesting. So

close this and we make it crypto

and internal

token

and it's going to be this

from the M API token and let's pass this

as cost.

All right. And uh next we need to define

some interface that we're going to use.

So after this we can say export

interface and we can score it uh user

data and this is going to have in the ID

the email

the display name and also the created at

all of them are strings. Next we can do

export

uh interface.

Interface is going to be of response to

extend

uh the of tokens.

Did we create that? I thought we created

it inside of

um okay let's add it before the user

data. So I can do export

interface

um

interface let's call it of tokens

and we're going to have access token and

as well as refresh token. So this is

going to of tokens.

This is going to extend those and we're

going to have the user and also the user

data as well.

Okay. And next we can have this. So

export

um export interface here. So export

interface and we're going to have the

register payload. So register payload.

And inside of this one I'm going to have

email uh password and display name. So

this is what we need when we're

registering. And here I can do export um

interface.

Uh we're going to have login payload

uh boom and it's going to have email and

a password only. So this is all we need

for logging in

and

can do so let's do all of them for now.

So uh refresh payload as well and we're

going to type in the refresh token as

string and here I can do export uh

interface

and we can call this leave work payload.

I think we taking the user ID

of type string.

Yeah. So that's all for our uh

interfaces of our types.

And we can go ahead and create or can do

con. We can call this resolved

take

resolved messages message.

And here I can get the yeah can get the

status

of type number

and can also get the data of type

unknown.

And this is going to return a string.

And inside of this one

uh we can say you can check if type

uh type of yeah if type of data is

equals equals to

object

and

I can say and end data

and end

message

and message in data. Okay.

And here we can just get the soest

message going going to be uh equals to

uh data

as record

of string and unknown.

And here we can just get the dot

message. Okay. And here I can check if

uh type of message is equals equals to

string

uh and end message dot trim

the length like that.

Perfect. Here we can just return the

message.

Okay. And uh over here we can return

uh status.

Yeah. So authentication service is an a

variable or we can just say uh an error

code processing the request.

Okay.

Yeah. Just like that.

Okay. Uh now let's handle also the

axios. So con

uh axious error here we're going to have

the error which is unknown and also

going to type is never. So we can check

if uh the axios

is not error. Okay it's not error. And

here we can just say

all

the error dot response. There's no

response. We can just throw

uh yeah just throw this new HTTP or

maybe you can just throw the error but

for now I guess that is fine.

Yeah. So let's get the status and also

the data inside of the error response as

um status number and data is equals to

unknown.

And here we can just uh draw new HTTP

error passing the status and also the

result message with a status and data.

Okay, perfect.

And uh now we can go ahead and create

the proxy service. So export

cons we can call it off proxy service

inside of this one. Uh the first one is

async

uh register which is going to take in

the register period and going to return

promise with off response. Here I can do

a try catch

and inside the try we can do con

response is equals to await client dot

post passing this off response

and

the endpoint is going to be here off and

register. This is what we set. Okay. And

also don't forget to add in the off

header. This is very important. So this

is the off that we are passing in uh

over here we have defined it here.

Okay.

And here we can just return response

data. And if there's an error we can

return

handle exos error and send this error.

Yeah. And this is pretty much it. So,

we're going to come back here and add

more, but we're going to use most of the

stuff in other services as well. So, it

will be easier. That's why we typed all

of them. But uh for now, this is fine

for the service. And um we can also

create the uh controller for this one.

All right.

So, instead of gway service, let me

create a new folder. I'm going to call

it controllers

and the file name is going to be uh oft

controller ts

and uh we need to import or we can just

do export con

um this is going to be register user

register user or we can yeah register

user is fine and get create the async

handra that we created before. If you

remember async

and it's going to have the request

response and also the next function and

here I'm going to do a try catch and

instead of the this one I'm going to do

con payload.

It's going to get it from the uh

register. So let's get the schema

register schema. Okay, from validation

pass and passing this request body and

so the con the response. So response is

going to be equals to await

of uh service proxy

and register passing the payload. Okay.

And here the rest do status going to be

201 and passing the response in the

JSON. And here I can just pass the next

with an error.

Yeah. So this is the how we're going to

be doing most of this is our setup. This

is how I like to do things.

And uh now we're going to come back this

this later as well. But let's go ahead

and set up our loads as well.

Right. So inside of my SL assist inside

the gateway I'm going to create the LS

and the first one is our offs. So off

louds

ts

and I can go ahead and import.

So import

and you can call it loader from express

and

and here

uh we can just say

uh to export con of LA and let's give

this

the type of L.

Okay. And now the first one is the post

loud. So of LA

post going to go to the register

endpoint. Uh we can say register is fine

but here also we need to uh validate the

request just like we did. So validate

request passing the

um the body

which is going to be equals to register

schema right so register schema from our

schemas

and finally over here we need to pass in

the uh so we can do use async handle as

well pass in the register

user

So make sure to add that.

All right.

So this is how we're going to use this

on this post request. And let's create

the index file.

So let me create an index.ts.

And inside of this one, I can input um

the route again

index.

But uh this time I can just import it as

a type. So

type

as this one. And here I can do export

con and I can say

register

louds.

And here I can pass in the app

and I can say loader and return of void

or can just remove it at all. And inside

of this one, the first one is our

offload. So import those and the main

endpoint is going to be on off. We're

going to come back to this when we add

more services. And it's going to be on

uh

slash loud.

Yep. And uh now we need to go back to

our index file. So not index but I think

it will be inside of our app.ts.

So app.ts we need to add handle the uh

loads as well. So after the middle here

we can do uh register

louds and we need to import this over

here

passing the app.

Yeah. And um

for now I believe this is all but we

need to go back to our

we need to pass the API the the the

other API token thing we said that we're

going to pass in through all our

middleas so they know we know that they

are the ones we need. So we need to

validate those as well. All right. Uh so

we need to go back. Let me close all of

these.

Uh we need to go back inside of services

of service src and inside of the apps.

Uh after this middleware we need to add

one more middleware we just created. So

app dot use and this one is going to be

the create

uh record it internal.

Yeah we need to export this don't we? Uh

I always forget that.

Uh yeah, let's do that. So packages

src uh index

and uh after this request we can do

export

and we can create from

from uh sorry from and this is going to

be and the

from inside of http

and it's going to be uh takea

It's going to be um internal of right.

What did you call it?

HTTP intern. Yeah, this is the name.

All right. So, we have it.

Uh create internal med. Yeah, let's add

that.

And um yeah, I think that's what we have

to add. But we also need to add in the

token. So, and it's going to be coming

from empire

from our config.

And it's going to be of taken.

But we don't have this yet. So, we need

to add it inside of my envile.

And uh let's add it after this. So, we

have the service

um

we have the service port, but you can

add it actually anywhere you want. I

don't know why I'm stressing this.

Let me add it here.

Yeah, we're going to come back to this

and set any token that we're going to be

using everywhere. So, anywhere you need

to make sure that you add the same

token. Um, yeah. So now you can go

inside the config and make sure to add

this uh internal token as well.

Okay.

So now we don't have the error anymore.

And um I'm not sure if we create we have

to create anything else to test this. I

actually think we can go ahead and make

a request to our gateway.

Yeah, let me try to start this. So, npm

land if this restart both of them.

Uh, yeah, we need to build the we need

to build this again.

Okay, so I hope that this works.

Okay. Uh, so we have our off service

running, we have our gateway service

running.

Now what I'm going to do, I'm going to

go inside my request. Instead of making

the request to the um to the offservice

directory, what I'm going to do, I'm

going to make it to the API gateway

4,000.

Okay.

And uh the path is going to still be

this one of and uh this one.

So let's make a request and see. Now I'm

going to click on send request.

Unauthorized. Interesting.

Let's see. Unauorized. This is the

message we get. Unauthorized.

So let's see where this message is

coming from.

So this which means we don't have the

same token as the one we have inside of

our gateway service. So let me see.

Yeah, see this is the token is not the

same thing as we have inside of our

authentication service.

Um, so that's why we're getting this. So

you see the useful of that. So that

means our services needs to know need to

have validated them. So I briefly are

getting this message from our internal.

Yeah, perfect. And now let's uh let's

generate uh uh tokens that we know that

we haven't used or in all our services.

So we're going to generate a secure

token that we're going to be using.

All right. Uh so I'm going to generate a

secure key. Let me open a new terminal.

And I'm going to use this command. And

we say that we want ours to have 32. So

I'm generating this key. and inside of

my services. So, let me start with

gateway service

and uh I'm going to use this token here.

So, let me paste it

and make sure to use the same thing

inside of of service.

So, let's add it here.

So make sure you have the same thing

inside of our service and also the

gateway service that the same token

otherwise

will not allow us to make request to

this service. So let me start again my

services.

So they all running and we have the same

token and now it should be able to uh

validate us. So let me go to a request

and now they make a request since time

we're using we're making a request

through the gateway service not inside

of the authentication service. So I make

a request.

Yep. Perfect. So this is working and we

already have this user that's why we get

this message.

Okay. And also we did not test very well

our

our validations. So let me try to make

request that is not with email.

Yeah we have the validation error and

the issues path email message invite

email.

Perfect. uh the

password. Let me try to make a request

about password

and we get password string must contain

at least eight characters. Okay,

this is pretty good. Uh let me add a new

password.

Yeah. And for the user we can use Jen do

and for the name we can use anything.

Jen do and now we're making a request

remember we're making the request

through the API gateway and we

authenticating with our

internal token

and now we have a new user

and we can open our table to check this.

So we have a new token for the gen user

and for the database we have this gen

user as well with their password.

Okay. So our our API gateway is kind of

working since we're making a request

through it and it's working uh without

any issues. Okay. And so uh what we can

do next um

we should go ahead. So we have our

services. So authentication service is

communicating with this gateway service

without any issues. Uh I'm thinking

should we uh set it up right now? Uh

what I'm talking about is like the bit

MQ. So whenever we make a request to the

service, it will send an event to other

services that we need or it will it will

publish or it will consume those events.

So uh yeah, I think it makes sense to uh

start working on labq. So you can be

able to use it as well. Uh yeah, so this

is cool. We we're going very well and

we're advancing slowly but we're getting

there. So yeah, let's go ahead and start

working on the lab MQ uh next. All

right. So we're going to be using uh bit

MQ as our message broker.

Uh so we're going to use this to publish

and consume some events between our uh

services. Okay. So the first thing we

should do is setting up. So, let me go

to the cab and I'm going to search for

uh the BMQ so we can get started

and we're going to use the official

version. So, this one

uh there is different versions but again

once again I'm sure the version I'm sure

about is the version from this one. So

this version number three and uh

management.

So let me close this and go inside of

docker compose

and maybe we should put it uh over here.

Let me put it on top.

Okay. And I'm going to call this uh just

a bit MQ. Okay. A bit MQ. And

I can give it Okay. So let's give it

this default. Let me give some space.

And it's going to use this. Let me see

the network we created.

Chat up network. Yeah, that is fine.

And here we're going to use this version

source management.

The container name going to have this

name for the port. So this is the the

port we connected to. And I believe this

is the UI port.

Uh we're going to check that out. And

for the password,

the user and also the password. So we're

going to have both guest as guest. And

we're going to use this network. So that

is all for the BMQ to start talking.

Make sure you have Docker running. And

now you can go ahead and uh let me

actually open it just to be sure. So go

to dashboard.

Okay. And I have it here.

I can just make it full screen.

And now I can start. So let me start all

my services. Do com local compose again.

Do local compose app.

and it's going to pull the rabbit MQ

image from the Docker Hub since we don't

have it on our local machine.

So that is done and now as you can see

we have two of them up and running and

let me try to open this uh yeah this one

the UI I think. Perfect. So this is the

UI one and the password we set is guest

and guest. So let's do that. Guest uh

guest I mean

also for the password

guest login.

Uh yeah that is fine.

I'm going to save this and yeah so this

is the U we're going to be changing. So

creating our channels our exchanges. For

now we don't have anything custom. These

are all the defaults. Um I don't see

anything I created

and um yeah so all of this is the

default one. All right.

Okay. So we have this. Now let's go

ahead and start working on what we need.

So the first thing I think we should do

is create the event types that we're

going to be using.

And uh we can do that by

going inside of our packages

and inside of the common folder and

inside of src

and

should create a new folder. So call it

events. So we're going to have all our

event stuff related over here. And the

first file we're going to create is

called event um event types.

We can just call it types actually.

Yeah, just types.ts.

Okay. And the first thing you need to

do, you need to export. So type export

type can call it event type

or event not event type but let me call

it event payload.

All right. And it's going to be equals

to record

record uh string.

And also this can be unknown. Uh make it

unknown.

And uh it's going to be or we don't have

to have this. You're just going to be

like this.

Okay. So this is just uh the type we're

using is uh uh like we're making this a

flexible type that can represent like an

object uh with a string and the unknown.

So we'll be using this as base for our

event data. Okay.

All right. The second thing we should do

is create some interface for our um

uh let me do that here. So I'm going to

do export interface and I'm going to

call this domain uh domain. Yeah, domain

event. That is correct. Domain event.

And it's going to have a t type

uh t type and it's going to extend uh

string and also going to have t payload.

Perfect. That is fine. Extends also our

event payload. Okay. So this is just a

generic interface which is representing

uh our domain event with uh these three

uh points we're going to add inside. So

we're going to add type which is going

to be t type. We're going to have a

payload which is t payload and also

we're going to add a cured art. Okay. So

each of these the type this is the uh

the event type for example it can be a

string uh uh like uh user created and

also our payload the event which will

follow uh the event payload uh structure

and this occurred at uh uh let me make

it actually a string just a string to

keep things simple this is just an ISO

time stamp a string like which will show

us when uh the event has happened.

Okay. And the second thing you need to

create is the another interface. So

export

um interface. We need to add some

metadata. So we can say event meta uh

metadata.

We're not going to extend anything. And

inside of this one I'm going to have

uh correlation ID which is optional of

string and this is just uh for tracing

or tracing related events across our

services and the second thing is caution

ID and this is just uh this we just link

event in the cause effect chain and also

the version. So version which is as uh

option of number. So this is just a

schema version of the event.

And uh after this one we can also add

another interface. So export

interface. This is going to be our

outbound

uh outbound event. So this is going to

be also t type. So t type

t type and it's going to extend

uh a string and also t payload

uh which is going to extends our event

payload. Okay, but we're going to also

um just go over here. We're going to

extend the main event

t type and t payload load and we're

going to go inside of this one. We're

going to add in this metadata

metadata and also event metadata.

Perfect. Um now the last thing we need

to do uh okay so yeah this is uh

outbound event this is just an event

that is being sent out from a service.

So it will extend our do our our domain

event and it will just add some optional

method that I used when publishing uh

events to other services. Okay. And here

I'm going to add another uh export so

export uh interface. So export interface

inbound

event. So the same idea. So inbound

event is going to have the type extends

uh string t payload extends event

payload and extends domain event and add

in this metadata but this time it's not

optional. So this inbound event and it's

just like the the

uh I don't know how to say it uh it's

just an event received by a service. So

it will extend so instead of out it will

just be receiving by a service. So it

will also extend our domain event and it

has uh required metadata. So unlike our

outbound event here uh this is just used

when consuming events from other

services. Okay. So this is everything we

have

uh for our our events. And now let's

also since we for now we just have um

our authentication

services. So let me create a new service

uh type event oof dot uh let's not use

that event.ts.

Okay.

And inside of this one, uh, we're going

to use so export con

and we're going to use this. We're going

to call it and

event

again

exchange.

Okay, so exchange and we're going to

call it off.vents.

Okay, so this is going to be our

exchange and also residual export um

uh cost is going to be of not clouding

key for now but it's going to be

uh user uh

registered right registered

uh user registered and it's going to be

for routing key and we're going to call

it off dot user dot

uh user uh uh also we're going to call

it off dot off user dot registered. All

right. Um so we have an event exchange.

So this uh the labbit m this is just a

lab m key exchange name which is we call

it off.vent this can be anything. So

this is where all authentication related

events are published. Uh okay so all our

service all services are subscribed to

this uh exchange to receive um the

authentication events and also the

second one is of user registered routing

key uh this is lab mqing key so we

called it off userregistered

this will just identify the specific

event type uh use it we use this to

filter which event service receive from

the exchange Okay. And uh here you can

go ahead and do export uh interface.

Yeah, interace.

And we're going to call this of user

registered

uh registered payload

extends. We're going to add our event.

So event

payload, we created that

inside of this one.

I'm going to have in the ID which is a

string email which is string. I'm going

to have display name a string and create

that of string. So this uh of registered

payload uh this is just the the data

structure that we want to contain uh our

details when maybe receiving the events.

Okay. And it's just extending the

payload to follow the our architecture

uh pattern. All right. And uh here last

we can do export

uh type and we're going to do of

uh registered uh event

register

event. Yeah, register event. It's going

to ex have out our outbound event we

created. So out outbound event and here

we're going to pass in

type of so type of and going to pass in

the routing key and also the of user uh

registered. So this is just uh of event

this will just complete the event type

combining. So we're combining

everything. So we're adding the type uh

which is the user registered routing key

the payload user registered payload and

uh we're also adding the outbound

events. So we've accord

and etc.

All right. Um I brief this is all we

need inside of our common folder. uh uh

we can go ahead and actually start

implementing this inside of for example

we have just the um so the

authentication service we can go ahead

and start using that there but before I

forget we can run the build command for

for this

sorry run build

and also we and uh install a package we

need. So pinp

and it's going to be pinp

um it's going to be

not uh let me check the package again. I

don't remember the name of this package.

So, npm

npmjs.

Uh, we're going to have

uh it's called amp

library.

Yeah.

Yep. This is the package we're going to

be using when working with rabbit MQ.

So add this and I can do free again.

Go to

services and uh of service.

Wait uh is it adding it inside of

packages?

I just realized that. Wait, let me check

something else.

Uh gateway service.

Oh no. Okay.

Okay. That's fine. It's adding just in

the package that we specify.

That is fine. And I think we also need

the types.

Uh do we need the types? Just let me add

them

just in case

this so I can add types.

Okay.

Make it

all right.

So now um we have that let's go to the

services

authentication service

and inside s

uh let's create a new folder going to

call it messaging.

Okay since here we are not going to be

consuming an event but we're going to be

publishing event. So let's create event

uh publishing. So pub uh with this

publishing

ts event publishing.ts Yes. And here I'm

going to import all the so input

from

here and we're going to have in the of

uh

yeah.

All right. I just remembered we forgot

to export

we forgot to export again uh our events.

So inside services

CC index

um I can add the events that we're going

to export. So, let me just

export everything from

and it's going to be from events

from events and it's going to be the

first one is going to be uh event types.

Okay. And the second one is going to

export everything from not even bus but

going to be yeah of events is better.

Now uh let's this again

and let's go back to our event

publishing. So instead of our services

of service src messaging event

publishing.

Okay. Uh

so now we can import

of exchange

and also of registered not key.

All right that is good. And uh so maybe

let's get the type. So type which is

going to be of uh registered payload.

All right. And now let's import some uh

import things we need from lab MQ. So

we're going to need the connect type

channel and also type channel model.

Okay. And also we need to import the

logo and as well as the M. Right.

Okay. So now we need to set up the

rabbit MQ URL.

So let's go inside of our ENV file

uh env file. Let me reload the

TypeScript actually.

So this is the TS server. So I stop

seeing that

error and inside of service MV file

we're going to add the raid m URL. So

I'm going to go on the bottom here and

I'm going to call this raid mq URL

and this is going to be this way.

So this is the the format. So we have

the user the password and where it's

learning at. Okay,

so that is everything

for a bit MQRL and I can go and also add

the URL inside of our env. So envirl.

Perfect.

So that is everything uh we have for

this and we can go ahead and continue uh

with our publisher. So let me close all

of this messaging event publishing

and here I can first of all I can def so

that

uh connection

can go this connection uh reference it's

going to have our channel model or null

by default it's null and so channel

and it's going to be type of

channel or none by default. So now let's

do export con. We're going to initialize

the publisher. So initialize publisher

going to be async

and over here inside of this one we're

going to check. So if uh env uh we can

check if the the env.

going to uh logger dot

one.

So we're going to just say lab is not

defined. We are skipping this uh event.

And here we can go ahead and return. We

don't want to do anything else if the

lab is not present. Okay.

Now let's go outside of the if and

having check if channel. So if there's a

channel

uh we are going to return.

Okay. And here we can do con uh sorry

we're going to do con

uh let's create connection. So

connection

and it's going to be await connect

MV and use datab M URL to connect to

this.

All right. And here we can do connection

left is going to have the connection and

also the channel is going to be uh await

connection create channel and we're

going to await channel dot asset uh

exchange and we're going to pass in this

of exchange and this going to be a

topic.

Okay.

And here we're going to add durable to

be true.

Okay, perfect. And here we can do

connection uh wait

connection. So connection on we're going

to listen to some events. The first one

is the error. So if there's uh not error

but uh let me let me use cross.

So connection on cross and instead of

this one we can have

uh what happened?

Yeah, connection and we're going to say

loga

loa do

just the warning. So M key connection

closed and channel is going to be null

and also channel F is going to be null

as well. Okay. And also going to do the

same thing for the error. If there's an

error, we're going to say logo error.

And here, let me just uh

move this and let me do the let me do it

this way. So pass in the error and also

um yeah the actually

uh

yeah uh let me see what what do I want

to do? Yeah, this is fine. Okay. And

here can also pass in a message. So

rabbit MQ connection error

and outside of this one we can say

logger.info

uh we can know that is coming from

authentication service. We can say I

publisher initialized.

Okay, perfect. So that is what we have

to do and now let's also create so

export

con uh the first one is publish the user

registered event.

So let's get create this one. So publish

user registered just registered and here

going to pass in the payload

payload and it's going to have the off

user registered payload

and inside of this one we're going to

check if there's no channel. So if you

don't have the channel we're just going

to log one and also return. Okay, we

don't want to continue. And here we can

do con event.

So con event is going to be equals to

this and going to have type which is

going to be of

user uh outing key

payload. It's going to just be payload

occurred

at

it's going to be new date to ISO string

and also the meta

meta data is going to be to have a

version can call it version one.

Okay.

And here we can say con

uh take con published equals to be

channel.publish.

And inside of this one we're going to

have lot event key of uh loting key and

also going to say uh buffer is going to

JSON stringify pass in the event.

Okay, pass in the event and uh over here

we can just pass in the persistent to be

true

and also maybe the content type uh

content

uh type content type to be application

JSON.

Okay.

Okay. And outside of this one going to

have so if uh it's not published

published inside of this one going to

have a logo one. So uh loa

do one to one. So we're going to say f

to publish

uh this one. Maybe I can just do it this

way even.

So failed to publish user registered uh

event and uh finally outside of so

outside of this one we can create for

closing. So export cost

cross publisher to be a sync and inside

of this one I can do try catch

and here I can get the channel con

channel it's going to be goes to channel

and here I can say if

the channel is there we're going to say

await channel and also we're going to

set the channel to be null and also can

do the same thing for connection ction.

So if there's connection await

connection cross connection reference

going to be null and here we can just

learn in so error is going to be one

error crossing key channel.

Yep. So this is everything we need and

now we need to go inside of uh our index

JS test and we need to

use these methods we just created. So

and uh let's do it after the model. So I

wait init publisher

import this and let me use just our uh

uh messaging

uh yeah there's a space again. All

right.

And uh also here when we when we promise

this we can pass in the cross publisher

as well. So import that.

Okay.

So now let's start this to see if we

run. So p and div.

Okay. So you can see inside the loggers

we have the authentication database

connection and also service publish

initialized.

Okay. And now let's check our uh s of UI

if the

there's anything created. Uh let's

refresh this

channels. Okay for now there's nothing

that is fine.

uh they will be created type brief when

we add

or use the those events we created.

Okay.

And these are the default one. Oh yeah,

we have it here. It's here.

Authentication event is created.

All right.

Okay. Great.

And uh next thing you need to do let's

use this. So inside of authentication

service we already left a to-do message

that will be um publishing this event.

So let me go to services of service

and here

I'm going to use this right here. So I

can say publish

uh user registered and here just pass in

the user data.

All right. So this is all we need to do

to publish the user event and this will

be consumed by our uh user services. So

our user services will listen to this

and it will do what it has to do.

And uh I believe that is all we need to

do for the Lab MQ for now. Okay.

And uh so maybe we should also

we actually set up the user service

right now so it can listen to this

event.

Yeah, I think it's a great idea. So we

can see how to use this.

Um yeah. So yeah, let's go ahead and

start working on uh the user service.

All right, so let's set up our user

service

and let's set up the basic

uh structure. So we're going to call

this user and service

[Music]

and uh we need to initialize this

project. So

uh let's do CD uh services and user

service.

So let's uh let me just do pinp in it.

Uh we have this and before we forget

let's check what we have inside of

service. So we can take the script. So

let's take the script first. It's got to

user service. Let's replace this with

this.

And also we need to change the type and

etc. Uh maybe we can just take this

and modify them.

This is going to be user service

and this will stay the same. And also

let's take

the common

package. So, let's add it. Um, okay, we

don't have the packages yet. We're going

to add those. That is fine. Okay, that

is fine. Uh, let me close this. So, I'm

going to install the packages that uh

I'm going to need for right now. Let me

open this.

Let's just do pinp add and we're going

to add

uh course

express

um

now let's add the package that we wanted

to add. So which is the common chat

common.

Let's add also their types. So

for this uh for this one I'm going to

add T and we're going to say types and

same thing for the hermit. So types.

All right.

Okay. So we have this and um

uh for now we can go ahead and start

setting up our server.

So as I said it's going to be the same

thing for all our services.

So let me add the s file

and also we need to add in our ts config

file which is going to be the same

from any service. For example let's take

this one from gateway service add it

inside the user service and there is

nothing is going to change. is going to

stay exactly the same.

And uh next thing is

the

uh the files that we're going to need

for example the app and index.ts.

So app.ts

and uh it's going to have the same exact

structure.

So we can go inside of gateway service

for example and inside of app.ts this is

the same thing. So let's copy this

content

set the user service

app tested

here

and also the for now we can remove the

loads

but the error hand is going to be the

same as in here. So let's copy this

middleware folder from our gateway

service. Go to SLC. Paste this folder

here. Okay.

And the error hand is going to be the

same. Yeah. We also need to set up the

logo and the MV file. So you already

know the drill. If you want to go ahead,

you can go ahead and do the same thing.

So let's copy the config folder. Go to

user service src. Paste this config.

Okay, so nothing's going. We're going to

change some stuff, but for now about it.

And uh next thing is the uh logo. So we

need to add the logo. So let me copy

this UT from our gateway service.

Let me paste it inside of here.

So this one is going to be our um user

service.

So user service. Now let's go inside the

app.

Now we don't have any errors anymore

for our express app. Uh this is fine.

This is fine.

Let's check the middle here.

That is fine. We don't need to change

anything here.

Uh let me close all of this.

So apps

and our app actually is pretty set. So

we also need to add the uh gateway

service. Then you need to add the index

file. So let's go to index.ts

from our gateway service. Let's copy the

content. Let's go to user service to the

src. Let's create the index.ts.

Let's paste this here.

And uh it look like we don't have to

change much. Just the port and also some

few other things we'll be adding.

Okay. And uh yeah, let's change this

gateway to be um

user service. user service.

Uh yeah, I also saw somewhere inside the

gateway service, we need to change this

to get a

gateway service.

All right. So, we need to modify uh the

env config

for our user service. So, we're going to

use a bit similar things, but not all of

it. So let's go to NV. Uh we're going to

have the node NV. That is fine. But

instead of the gateway port, we're going

to use uh

user yeah user service port. So user

service port user service port is going

to be running on 44,01.

We're going to have in um

a user DB URL since we're going to use a

user database. So DB URL which is going

to be uh a string

and also we're going to have the labit

murl

which is going to be a URL. Uh but this

also can be optional.

Okay. And we're going to use this

internal API token as always. So this is

needed. So we're going to be using this

as well. So these are all the the this

let me see MV user service put user DB

URL. Uh yep. So this is actually all we

need to do. Yeah. Let's change this to

be user service.

And now inside of our uh index dot

uh yeah we need to change it to user

service port.

Okay, that is done. That is done.

And um

uh we also need to create since this is

a user, this is not gateway. So we need

to add the middleware to protect uh our

service uh to authenticate our services.

So let's go to user service s

authentication service src and this is

inside of app. We need to use this API.

Use create internal middleware. Okay.

So, we're going to be using this for all

our services that we need to protect or

we need to be authenticated before

receiving any request.

So, let's add it right here.

Okay. Let's import this.

And uh let's also import our env

uh can do input. Uh wait, it's not

should I take

it's not coming from config, right?

Here's a service. Um

we have it.

Okay.

All right. Uh, so what did you call it?

Internal of

U.

Okay. What did you call from

authentication

intern? Yeah.

Okay.

And here is saying intern API token

of service

config

internal of token

gateway service

internal API token.

Um

maybe let's keep it to internal API

token actually.

So let's name all of them to be internal

API token.

Okay. And make sure to change it to our

app ts

as well.

Okay. So this is the first press that is

done inside of authentication service.

So make sure to change from our NV

change it to a pay token. Let's go to

the next service. The this one is

already correct.

This one is correct. And the service

we're using this so API token

and yeah

let's just keep it like this.

So the user service uh uh for now

this is okay but I don't want to protect

the hair louds so we can add some

optional and we can say uh exempt path

and we can give it to

uh for example users and earth

okay so this will not be protected ed by

this one. This it will skip this because

we don't want to protect if we want to

check the health of our

our

service. So we should do the same thing

actually for the uh authentication

service.

Yeah, but for now that is fine. So let's

start try to start this and see if it

restart. So let me c debug

and let me run all of my three services.

So 10 p.m. then div.

Okay.

Um,

which one is fail? Use a service. We do

not

uh do pinp

services

user service pin p.

Uh yeah, we do not install the NV pinp.

Now let's go back. I'm sure it shows

that

pinp and div.

Um oh yeah, we're missing the user DB

URL. The we don't have the env at all

actually.

Uh so this is why we're getting the

error.

So let's add this env that we need. We

already have um

some of things we need but yeah let's

create an env file. So M

and uh let's go to user service. So get

the first this first and the third one.

So these two these three

and uh we're going to use this going to

be user

so user service port which is on port


the internet token stay the same but we

also need this lab MQ okay

MQ let me add it here

uh yeah for my user service and also

what else do we need as

uh the config we need the user database

URL so user DB URL uh let me add this

here so use DB URL

and for this one I I believe we're going

to be using uh rabbit MQ not rabbit MQ

but u posgress for our users

database.

But for now, that is enough. So, uh

let's go ahead and test this.

See if our server will start up. So,

pinp

um

in URL because we don't have the URL.

Uh

okay.

Uh which year should we add? We can just

for now just to skip this error and

uh I can say postgress

sq.

Let's see if this will skip it.

Yeah. Okay.

So you can see our three services are

running. So first we have the

authentication service. Then we have

gateway service and also the user

service. They are all running. So one is

running on port uh 3003 4000 and 401.

Okay.

Perfect. So this is the basic setup is

working as needed. Uh yeah, let's go

ahead and set up this database actually.

So let's set up uh our database for our

user services. Uh so for the user

services uh we're going to use uh

posgress as we said. So let's go to look

at compose

and um

show you add it just

here.

Let me add it here. Uh I'm going to call

it user DB. So we follow the in the same

format. So user DB

and uh what's the issue here?

All right. Services.

Yeah. Service. So the services and we're

going to use Postgress. So image is

going to be uh post

grace. So this going to be postgrace.

Maybe let's use postgrace uh

16.

And container name. Container name. I'm

going to use um chat app

uh not underscore but maybe can use

um

user db right. So user

DB

and we're going to have the

environments. So environment

and the first one these are the

environment that we're going to be uh

using for this ones. So we have the

Postgress

Postgress

DB. So database not equals but here.

And this one is going to be equals to um

uh so user let's call it user

db

name okay and by default it can have

this so chat app and it's going to be uh

underscore

user

um service.

Okay. So I can copy paste this three

more times. The second one is going to

be for our user username. So user uh DB

and it's going to be

user.

So this is going to be chat

user shut up user

and posgress db password

and it's going to be chat user db

password

and the default one is going to be chat

app

uh instead can just be chat

chat password.

Chat password.

All right. So, that is what we have. And

we're going to do the same thing for the

port. So, let's add ports. And the first

one or only the port we need is this

one. So, which is the user.

Uh let's add this underscore. It's going

to be user DB and port.

Okay. So, by default it will be on the

port

uh 54 and 32 port.

All right.

84 and 32 port.

All right. So, if you don't have the

port this port variable, you can change

it here. But make sure to keep this as

it is.

And for the volumes,

um,

we're going to put it inside user

data,

uh, user DP data. Okay. And we're going

to map this true. Um so f

we can put it the lib

and can call it posgress. So posgress

posgress sq

and get the data.

All right. And uh I think we can go

ahead and add the network as well.

uh will be over here.

Chat app network

and uh yeah

now we just need to create this volume

we just added. So for you, so we have

the authentication data. Let's also add

it here and make it user

data and

going to be DB

just like that.

So make sure it's the same. So user DB

uh we have user DB data,

right? So let's get the URL we need. Let

me uh Okay, wait.

Uh that is fine. Uh let me do

compose up.

Oh, what was that?

Okay.

Uh wait volumes equals to

have this volume created. Use oh user DB

data. User DP

data.

Yeah.

Okay.

So let's open the database. User DB is

running.

Let me open this.

All right. So it seem like it's ready.

Uh now let's go ahead and set up the URL

for our user service. So inside the user

service envir

uh let me put it here.

uh we need to set um this URL for our

user database URL. So we already have

this posgress. So this is the format

actually.

So let me just get this.

So it's going to be posgress and now

we're going to have the uh username. So

username

and we're going to also have the

password.

So with password and it's going to be

running on

local host and the port going to be

542.

Okay. And now finally we can add our um

oh

I'm using the

that authentication database. Uh

okay. Uh, it's supposed to be the user

and also

No, it's supposed to be the user.

Okay. And the password.

Shut up. Password.

And the database name. This This is the

database name.

Yeah.

user password. All right, that is fine.

And this ones can be to false.

Okay. Uh we have this now. And what's

next? So next thing is to configure the

database

uh like uh we did before. So we're going

to use sec as well for the uh for this

one also.

Uh so we can go ahead and do pm

uh pm add

pen pm add

gra

and can do filter

uh

services and user service.

Okay. And let's see how we did it inside

the gateway. So we created this DB file

etc etc. Uh actually brief it's going to

be the same thing.

Um

yeah it's going to be the same thing for

this one as well.

So why not copy the whole file

and change some couple of settings.

So let me go to user service src and

let's create a new folder called DB and

the name is going to be uh secret just

like we did before. So secretize

secret.ts

paste this

and I just need to change this to be the

user DB URL

and this time I'm going to use Postgress

right posgress

Postgress All right

so this is going to stay the same the

same connect database is same but we

just Let's change this to

user database.

User database.

Okay.

Uh, yep.

Yeah. So, this is everything actually

need. We just need to use this inside of

our index. So let me go to index f

and let's use it on top here.

Uh I'm going to do a weight

uh uh initial

database. Where is the name?

Uh initialize database.

Um yeah. So I need to create actually

that initialize database method. So let

me go here.

export cost and I can say

initial

rise uh max light in it.

Okay. Initial. Yeah. Initi initial raise

uh database.

And inside of this one going to be a

sync

and I'm going to have

uh just await connect database.

Yeah. So let's do it this way. That is

fine. Now let's go back to here. I can

do initial database.

And

yep.

So yeah, that is everything for the

database for now.

And now let's try to start this. So see

if they connect

and div.

Okay, we also need to install this

manual as they say.

Uh so let's add this package instead of

user service

pg

let's start this

okay

so we have our user authentication

service learning

have the user service learning as well.

So database connection established

successfully

and uh all all of them are running.

Okay, perfect. This is perfect. So I

think the simple setup for user service

is also done.

Um yeah, we can go ahead and start

working more on this uh user service. So

let's go ahead and just do that.

Okay. Um so we have most of things

ready. We have our database set as uh

needed.

So for our user service for the database

we have this set. Okay. This is fine.

But we also need to create um

uh the models for this. Uh maybe I can

put the model folders inside of this

one. So let me add models inside of DB

folder. And I'm going to create the user

model. So user dot um models.

Okay. And inside of this one, I'm going

to uh import

um

what we need. So from data types and

models and also I think we need to

create the uh types that we're going to

be using for this one. So inside of my

uh src I'm going to create a new folder

uh I can call it types

and I can create a new file which is

user.ts

TS and here I can export and uh going to

be a interface user and inside of these

types we're going to have the ID which

is

string we're going to have the email

which is a string and we don't we don't

have password here because this is uh

this is just uh user service. So

passwords are handled by the

authentication service. So we just have

display name uh they created that which

is a date and as well etc. Let's also do

export and it's going to be interface.

This is going to be created um create uh

user input. Okay. So we're just going to

have the email and as well as the

display name.

Perfect. So now you can go ahead inside

the user model and we can import this

type. So let's do uh import uh let me

say import type from the user we just

created

and I can do import and uh type this

going to be the optional from secret. So

let me get the optional

from SQL

and um now we also need to import the

database that uh we created. So let me

create a new file inside the DB. I'm

going to create a new index so I can

import my database export it. So

index.ts TS and here I'm going to uh so

export

and I can say everything from uh let me

say securize

for now.

Okay. Okay. So now let's go back to this

user model and here I can say uh import

I get that securize from

um okay uh wait let me just do this

actually.

So yeah DB and securize.

Now let's do export. It's going to be

type and it's going to be uh user and

it's going to say creation

attributes. It's going to take in the

optional of user ID created that and

updated that. Okay. And I can do export

and it's going to be a class going to

call it user model. It's going to

extend.

It's going to extend the model user user

creation attribute and it implements the

user. And inside of this one I'm going

to have all of these types that we have

defined earlier. So the ID, email,

display name, create that and update

that. Perfect.

And I can do uh user model. So user

model in it. And inside of this one, I'm

going to have in um um and we can say ID

types going to be AUD.

Okay. And I'm going to have our own

default is going to be false.

And we're going to have the primary key

as uh this one. Okay. So that is fine.

Now let me also do the same thing for

uh let me go outside of this actually

and let me go here.

I'm going to do the same thing for the

display name.

And this is going to have

data types of string I don't know to

force

uh I don't know can we make it unique

let's remove it for now

and we have the create that

which is um

I don't need to add this I don't know

why I'm keep adding this so created that

uh We're going to have so they update

that. Okay. So data types is going to be

date alone at first default is just like

that and we're going to come to the end

of here. We're going to have another so

make a square. It's going just as we

imported and table names going to be uh

users.

Yeah. So, we have this and now you can

go inside of our index and import this

as well. So export everything

everything from and we can say um

DB and

others then the user model

uh we can just say it like this. Yeah.

Doesn't matter that much.

All right. So we have that uh ready.

All right. Um so we have this ready.

That is fine. We can close this. Go back

to the user service.

Now let's create our repository. So we

can just say repo um repostory

or we can call it repositories because

we're going to have different so

repositories and inside repositories you

can say user uh repositories

user.reositories.ts ts and inside of

this one I'm going to import uh things

that we use from the secret

and also we're going to import the

events that we just created the types I

mean

and also let's import so import from

our chat app common

uh we're going to import this uh type as

type so type

type and it's going to be uh our

registered payload, right?

That's what we have.

And finally, we can also input the uh

user model we just created.

Great. Now so the first one con

to uh

domain

user

and we're going to take in the model and

after that the type is

user model

return user

and here instead of this one I'm going

to say the ID is going to be the model

do ID

the email,

right? It's going to be the model dol

going to have the display name going to

be model

dot uh display name going to have

created at going to be model dot created

that we're going to have updated that

updated going to be model

dot

uh updated that.

Okay. So, we have this uh what's the

issue?

Uh take cons. Okay. We are not

returning. Uh come on. What happened?

We are not returning anything. Let me

cut this. I just typed. Let me cut this.

And we go back. Let me remove this. And

I'm going to put them inside of this.

then adding object then I can add this

uh but yeah so just make it this just

like that so to the main user that is

fine that is done and we can now create

the user repository so can do export cr

and this going to be a user

so going to be user repository Tory,

there's a repos repository.

Okay. And inside of this one, I can have

I do a sync uh find by

ID. So, this is what we use to when we

want to find the user by ID. So it's

going to be a string and it's going to

be a promise

of user

or this can be also um

uh this can also return null as well.

So user

or null.

Okay. So let's do con user is going to

be equals to await

uh user model find by P here

and the identifier is going to be the ID

and here we can just return

user and the user is going to be to the

main user getting the user

or just going to be none.

So this is going to be finding the user

and another method we're going to need.

So as sync this is going to be find all.

So, we're going to be getting all the

users.

It's going to be promise

and uh user, but this time it's going to

be of uh array, but inside of this one,

I'm going to say cost users cost us find

all but I'm going to

um an object. Um, so inside of this one,

I'm going to say, um,

well, I can I say I can get it in order.

So the order you want this to be in,

uh, it's going to be, let me add an up

array.

This is going to get from the display

name.

Okay, display name. And it's going to be

the order is ascending.

Great. And here I can just return so

return

uh users dot um map and we can get in

the two domain user.

Okay.

So this is finding all and uh here for

now I think we can stop there and let's

create the method that we create

actually the user when we receive the

event from the authentication service.

So we can call it upset from uh of event

and it's going to take in the payload

and the payload is going to include the

of uh registered payload

and this is going to return

a promise. So promise of a user

and here I can having the kendo cost. Uh

let me get in the user just like this.

So

can get the user and it's going to okay

await

uh user mode user model dot upset.

So I'm going to upset this inside of

this one. I'm going to have in um I'm

going to have in the ID

which is the

payload dot id email payload email

display name same thing but also we need

to created that. So created that but we

don't have to add it because the default

is already the um I mean the default is

already created but yeah so let's let's

use the one receive so created that

and here I can have the same thing for

the updated that so new date

payload and created that

Okay. And here I can also include this

method. This is say returning it's going

to be to true.

Okay.

Yep.

And after this one here I can just say

um return to the main user

pass in the user.

Okay. So we will use this when we want

to create the user we receive from the

uh authentication event uh service. So

now we can export this. So export

con and it's going to be user repository

user repository but with small capital

and it's going to be costing new

user repository

just like that. We're going to come back

and add one more method but for now I

believe these are pretty much enough for

what we need to do.

So now we can go ahead and

um

should we

should we clear the services now or

should we start by

um listening or creating the event

center

for this and use this method and test if

everything is working as as expected.

Yeah, I believe we can just go ahead and

work on the event consumer mean and uh

yeah, the sale that was. So,

uh let me go to my src. I'm going to

create a new folder. I'm going to create

messaging as well.

And inside of this one, I'm going to

create the first one is of consumer. So,

we're going to consume the event we

receive. We're going to import all the

types that we need from this package. We

do not have it.

So, let's uh install it. Um

going to do npm add. And this the

package.

Great.

So, we just added it. Uh this shouldn't

be causing an issue anymore. Uh yeah, we

need also the types as well.

Uh okay, let me open this

and let me add it as

div dependency. Now let's also

import uh we're going to import from

chat common

and we're going to get the of events

exchange

of user register key

and also the type is going to be of

payload.

Yep. And now we can also import our env

uh

import our env.

And also we can import our logger.

Okay. Import our logo as well. So that

is done. And now let's see. Uh okay. So

now I need to create actually yeah we

need instead of creating everything

inside of this folder.

Um

we can go ahead and create the services

folder right now. Instead of creating

everything inside of this one. Yeah I

don't like seeing so much code. So

services I'm going to create the user

dot service.ts

TS

and um

yeah, let me create the method. For now,

we can just create one single method

that I'm going to use and we can then

create others later.

Um, but yeah,

so let me import all of those. And also,

let me import

the types I'm going to need.

Um, yeah, instead of user repository,

what did I call it? Oh, user

repositories is fine. That's fine. And

now we also need to input. So input

uh from it's going to be

uh DB we're going to get

the secret and um

yeah so we have this user repository

and the first one is a type is fine. So

let me copy this again but this time

it's not going to be the type it's going

to be

just normal and also this is going to be

small capter. So this is a small cap and

this is the type with

all right so let's get the class. So

class is going to be user and it's going

to be user service

and inside of this one is going to be

and I can add the constructor which is

going to take in the private or read

only and I'm going to call this uh

repostory

repository which is going to be our user

repository right

and this can just stay like this without

touch

And let's create the method that we are

going to use. So the only method we're

going to use for now uh which is going

to be a sync and we call it sync

from uh of

user.

Uh this going to take in the

payload and this is the type.

So of user registered payload

and it's going to return a promise

and it's going to be a type of user

and inside of this one I'm going to do

con user equals to uh await this

repository dot

um this repository dot

upset

from of event and we need to pass in the

whole event payload. All right. So, this

is what we have to do

and uh we're going to come back to this.

But for now, you can just return uh this

user

just for right now.

Okay. So, that's all we have right now.

We're going to finish this right. So

export

con and we can say user uh service

user service equals to new uh user

service

and uh we can pass in the user posting.

Yeah. So we did not use everything we

need we added but we are going to come

back to that. But this is the method we

need to use to what we added to uh

okay. So let's go to the of consumer

again and I'm going to uh start so I can

say

type and the first type is going to be

manage

uh manage connection

and it's going to be of type of

connection

and

channel model.

Okay. And here I can say channel um F

which is going to be of type manage

connection and it can actually also be

null

and also

channel uh it's going to be type of

channel and it can also be none as well.

Okay, this editor is messing with my

keyboard shortcuts

like

uh so

consumer

um consumer tag. Let's also add a tag

which is going to be a string null or

default uh null and also do con can add

the key um

name. We're going to call this off

uh of service

dot of dot uh event.

So of service of offvent. So q name

connection

let's create crossing connection. So

close connection we go to async and now

I can have in the connection which is

going to be manage connection

and inside of this one I'm going to be

await

connection dot cross and we can set

everything else to null

and uh now let's create a message uh new

method to handle messages post handle So

message

got send the message it's going to be a

sync and it's going to have in the

message which is type of consume message

consume message it's going to have

channel which is type of

channel

and now let me also add so the cost low

it's going to the message dot

uh content

dot to string. So, let's get it to

string

and we're going to use um UTF

UTF uh 8.

Okay. So, this is our encoding

buffer

and here you can say con event

which is going to be type JSON dot we're

going to pass this pass pass in the low

as

of user

uh we have the event user registered

event

uh we need to input that so of user

registered event.

Actually, this is the one we needed.

Registered event, not the other one.

Yeah, of registered the event. Yeah,

that's the only one we need.

And here for handling the message. So

now we can use our service. So await

user service. Okay. User service from

the user services can say sync user from

uh messages

and event dot payload.

Okay. So we want to pass in whatever we

receive from this and we know that is

this type of event

and here we can acknowledge the message.

So channel doagnowledge the message.

All right. So this is the handle method

and now we can actually go ahead and

create a new method I want to use. So I

can do export con and I'm going to

create start consumer. So I'm going to

call it event consumer.

I'm going to be async

and now let me go here. Let me export

this. So if

the event uh we can call the m fire. So

even do that there's not a bit MQL

uh we can say

um so logger

logo one and we can say um and we can go

ahead and as well let done from this

because we cannot do anything and also

if channel so if channel we can go ahead

and return as

All right. So after this let's also

create so con

connection

connection is going to be goes to await

uh connect and we're going to connect

from our m labmqrl

and this can be as uh manage connection

manage connection

perfect so connection reference uh

connection

refer created. Uh

did we create it on top?

Uh this is supposed to be connection

left actually.

Connection

connection left.

Yeah. So it's supposed to be connection

left. So connection equals to this.

And now we can add the connection

uh ref to be equals to uh the

connection.

And we can do con

channel is going to be equals to await

and we're going to wait for the

connection

dot create channel. Okay.

Okay. Perfect. And here I can say the

channel and the channel is going to be

equals to uh just the channel basically.

Okay. Um

so now let's continue with this one. Uh

we're going to go ahead and also uh say

uh await

channel and we're going to say uh asset

exchange

pass in the event exchange

and it's going to be of type topic

and also going to say durable equals to

true. So the same thing we did we're

using the same exchange key and also the

cons Q is going to be equals to await

uh channel dot asset asset Q we pass in

the Q name durable is true as well. So

await is going to be channel and we're

going to say uh dotbind Q. Let me remove

this dotbind Q. So we're going to get

the Q from Q event exchange name and

also event user register routing key.

Okay. So here over here we can say uh

con

can say consume

uh consume

and it's going to be taking the message

in consume message

and we're going to get in uh this also

can be actually let me think it can also

be an array.

Yeah, this can be now as well, but I

know this is messing up my keyboard

shortcuts.

Uh I don't know why I use this actually.

Yeah, it's messing them.

All right. Uh this let me move this like

like on my keyboard. There is no uh

there's no this like it's not just type.

I have I have custom keyboard shortcut I

set to create this. So since I don't

have it and now the editor I'm using

doesn't have them. So, it's kind of

messing stuff up, but that is fine. Um,

message

uh I can say uh tag uh return.

There's no message we're going to

return. But after the return, we're

going to say um um

let's call the handle message. So under

message

creating the message

channel and here I can say that catch

oh just passing the message and the

channel and catch say the catch we

getting the error

error and it's going to be unknown

and here I'm going to pass I'm going to

say uh roger dot um

info uh error sorry

error and getting the

error and to be error

and here I'm going to say a message

which is going to be

par

to process now we can say ch do

um like pass in the message

and

up to is false. And also uh we don't

want to recue this again. So let's make

it to false. Okay. Uh so after this

I believe we can uh go over here and we

can say

um cost we can call this result.

So the results are going to be type of

reprise and we can get this. So consume

and this are going to be to await

uh channel dot consume

and the Q again Q

and here again pass in the consume hand.

Okay.

and consume tag is going to be consumer

tag result consumer tag.

So let's see why this is not working.

Uh so the consume handra is expecting

let me see what we defined here. Uh for

the consume handra actually we have we

don't need the channel there's no need

for the channel. So let me remove this

channel. Okay, perfect. So after this we

can go ahead and say

connection

uh we can close the connection dot close

and here I say cross

okay and here we can just say

um

go one and we can pass this warning. of

consumer

of connection

crossed.

Okay, so connection cross.

Uh what's the issue here?

Uh oh, this is connection on.

It must be a connection on. set all this

to be null and also the consumer attack

to null. All right. And here I can say

connection

on

passing the Yeah, basically the same

thing.

Okay. Um

Okay. Uh so now we have that. Uh I think

we can just add some L gas.

info or info and we can just say uh of

um what message should I say? Yeah, of

consumer started

of event consumer started.

And finally uh we can say export cost

and it's going to be stop uh of event

consumer

and uh this going to be a sync

we get the try catch

con channel it's going to be to channel.

So if we have the channel and and and

the consumer tag,

we can say uh await channel

dot cancel. We're going to cancel this

with this. We're going to cancel this

with this consumer tag. Consumer tag,

we're going to set it to be um null.

Okay. And here I can also say if we have

the channel

and uh await

channel sorry channel dot cross

and um

we can set the channel to be none.

And uh over here we can get the

connection. So cause

connection

going to be connection ref

and if we have connection

we can just say await

uh cross connection pass in the

connection we want cross

and uh the connection is going to be

null and finally for the logger just add

the logger.

All right. So that is everything for us

to consume this event. And now we need

to use this method. So we do need to use

those inside of our index. TS on the top

here. Uh we can do a weight uh start

of consumer. So this will we always be

listening to our events

and um yeah. So let me actually try it

out. So

hopefully this will work. Um

I'm going to start my services.

Okay. And I I'm going to start my

div save as well. So pm learn dev.

Okay, we have everything running. So we

have our of service gateway service and

our user service and they all connected.

So it's saying the of consumer started.

So means it's the consumer is listening

and uh okay and now let's go to our

request

and um actually what what I'm going to

do

to test this. So let me open uh table

press

so I can test this better.

Uh we have the user table

here opened.

Uh let me go to connections.

um

uh connections actually. Yeah. And I'm

going to open a database or open a

connection

and I'm going to add a new one.

It's going to be posgress.

Okay. So, posgress connection. Uh this

this thing again.

uh

new posgress create

and this is going to be um chat

app and it's going to be a user

service.

Okay, create app user service and uh the

port the

host name. Now we just need to get these

uh

uh credentials. So for the

authentication user

uh I need to get the password. The user

is this one. The username,

the password

and the database name.

Test. And I can connect to this.

All right. So let me open these two

databases side by side.

And the tables for user service there's

nothing but for user use user is uh

credentials like for authentication

service we have it.

But here we don't have anything yet.

Okay. So uh let me stop this for now.

Let me show you why. and I'm going to

create three terminals. Okay.

So the in the first terminal I'm going

to start so um CD I'm going to go to

services CD services and of service.

Okay. So I'm going to start pan dev. I'm

going to start just this.

Okay. So this is just the authentication

service. In the second one, I'm going to

cd services and user service

and do ppm run dev. I'm also starting

the user service and in the final one

I'm going to see the services

and cd gateway service and I'm going to

start this as well. PPM

def.

Okay. So the both of them are running.

to the authentication service, the user

service and get service. Okay. And now

let's say the the user service is not

learning, right? Let's stop it. But we

keep the user service running. The

gateway service learning. Okay. But the

user service is not running. Now let's

test what will happen. And now let's

some open my uh browser and

uh let's go to the um

management port.

Uh the password is guest

and also the password is guest as well.

Okay, that is fine. Connections.

Okay, the channel

exchanges we have this. And now let's go

ahead test this. So let me make this

like this. Let me go to the request.

Let's create a new user and going to be

John. So John do and let's register.

Okay. So let's send a request.

It's saying user registered.

Okay. So user is registered

successfully. And now let's check our

tables inside. This is the

uh

of table. So we have new user uh which

is uh let me just check what exactly we

have. Let me move this move this.

Okay. So we have this user and I believe

this is the newest one. Let me just see

their name. Okay. We're not saving their

name but we're saving uh where am I

actually? Um yeah let me in the flesh

tokens that's why. Okay, so we have the

John. So this is the John user we just

created. But in the users table there's

nothing because the user service is not

running, right? And now let's check out

the

uh exchange or labm Q. So let's go to

the queue for example. And here we have

this event that has is being is the

queue is waiting to be consumed by any

uh service. Okay. So this is the event

which is user registered right it's it's

in the queue so it has not been consumed

yet so that's why you can see it right

here right and uh let's also see the

connection okay we still have this

connection exchange channels

fine

but we have this queue that is ready

right now watch what will happen if

everything's working as expected watch

what will happen when I create when I

learn this user service no now let's

refresh the user table again. There's

nothing in the user table and we have

this new user uh inside of

authentication service. Now let's see

what will happen when we start the uh

user service. So let me run pinp boom.

Oh

okay. Uh but you can see it it tried to

uh run it right. It tried to consume it

as soon as we started it but uh we got

some issues. Uh, oh god.

Oh, we don't have the user table.

This is what messed up my

this messed up my my uh demo, bro. Come

on. Okay. So, why did not why didn't the

the user table get created actually?

Uh,

okay. Interesting. Uh, are we missing

something?

Um, yeah,

makes sense. Makes sense. We did not uh

inside the initialize database. We did

not sync this. So

con um

uh let's let's create con uh sync let's

create sync options.

So sync options and it's going to be M

file and we're going to depend on that

MV and if it's go to development

uh we're just going to leave it like

this but otherwise we're just going to

say uh equals to true.

Okay. And finally you can do await uh

secrets

sync and you can pass in this sync

options.

Uh okay

I'm going to see what's the issue now.

info

and you can pass in database

sync

synchronized or whatever. Uh so what's

the issue has no property defined ultra

this not it's uh

yeah ultra to true

okay

so it has been restarted but I'm not

sure if the user got created

okay we don't have the user user again.

Ah, the first one failed. Um,

so this did not create the user.

Yeah, but that's fine. Let's actually

try it again. One more time.

Let's create a new user. Uh, it can be

uh

whatever.

Let's stop the user service again to

test this.

create user. User has been created. And

let's check once again. Refresh this.

Okay, there's in the tables we don't

have the user. We don't have any data,

right? There's nothing.

And also here we have a new user in the

authentication tables. We have this user

Chris. So Chris is not there yet again

in our database. But let's start our

user service. So pin pan dev.

Okay. So this should create the new user

inside of a user table, right? Create.

Wow, look at that. It's just like magic.

Amazing. Um, so we're listening to the

event. So no matter if our user if our

user service is down, doesn't matter as

long as it come back. And also our

authentication service does not care if

the user service is running. does not

care about anything. All it does is it

just deliver the event. So whenever the

user service is ready, it will consume

it. Right? But user service uh

authentication service is done its job.

It's done. There's no need for you to

wait. It's just do that. And the rest

service can handle whatever it needs. We

just give the data we need. And uh yeah,

just like that. As you can see, these

are completely two different databases

that I services working together. one

one database is MySQL, another database

is posgress. So they all working in

different services and um everything

working together right now. Let's try

one more example. And um a new user,

[Music]

right? Uh yeah.

Okay.

Uh let me try uh

okay so this time let's keep all the

services running now let's

post this and I'm pretty sure that we're

going to have two users. Yep. Just like

that. Yep. Just like that. We have and

we have here as well.

Easy as that. And as you can see the ID.

Just look at look at the ID, right? Look

at the ID here. It's the same thing for

the ID we have right here. So this is

the

uh this is just amazing guys. All right.

So I hope you got the idea of how we're

going to be using um uh Labbit MQ to

communicate with our services. And now

uh let's go ahead and um continue

working on this. But this is just pretty

cool. And uh we're going to be even

implementing much much more cool stuff.

So yeah, this is the was the first one.

we see how we're going to be

communicating between our services uh

without knowing each other if they even

if they exist. We don't care about that.

And you saw also that inside the user

service there's no thing that is related

to authentication. So we we just have

email name and nothing else. So all of

those about passwords uh tokens they

don't we don't care about those in

inside of user service. All we care

about is some user tu some user data

such as name, email etc etc and you can

also even add the bio uh but for

authentication it's just for

authentication there's nothing else we

need right and u yep so that was all for

this lab MQ section and uh yeah of

course we're going to still use it this

was just like um you know getting

started with it and showing you how it

will be uh used throughout this project.

So yeah, let's go ahead and keep working

even with more cool pretty cool stuff.

Yeah. So let's go ahead and uh uh let's

continue guys. So for me I'm signing out

and uh I will see you will probably see

a long video but yeah for me for right

now I'm done. I'm going to take a break.

Uh but yeah. Okay. So now let's go ahead

and uh start finish working on our

authentication service. So we need to

add few more methods uh because this we

just have for now we just have the uh

method for logging in. So we need more.

So inside of service I'm going to add

another one. So after the register uh we

need another one uh for logging in. So

before this authentication token I'm

going to uh export and it's going to be

con login and it's going to be a sync

and it's going to take in the input with

the uh login input. So we probably need

to import this but we already created

this and the off response is already

imported. So uh but for logging in we

don't need this. We need actually the of

tokens

which we also have right and inside of

this one I can do a con I can call them

cential

so credential goes to await and this

going to be user um

user credentials dot and we're going to

do find one.

So, we're going to find one and inside

of this one, I'm going to say where. So,

I'm going to check where the uh email

the area the email right the email is

uh was it equal

equals to um the input email.

So, similar thing we did for uh register

I think. Yeah.

Okay. So we're finding this user and if

we have this user or if the so we can

check so if there's no credentials right

so if there's no credentials

uh if the the credential is not there we

can just say uh new http error we can

pass in the 41

and uh we say invalid credentials and

here can say con valid so now we're

going to check if the password matches

so

uh verify password. We already have this

method. And inside of here, we're going

to pass in the input

dot password. All right. And also the

credential. We're going to compare this

with the password hash that we have.

Okay.

So, if it's not valid, so if it's not

valid, if the password is not valid,

what do we do? We just throw a new era

and we say uh invite credentials as

well.

Okay, great. And now we need to create a

new token. So, same thing we did here.

Um, so I guess I can just take this one.

Okay. And here I'm going to token but uh

this time I'm just going to add in the

remove this transaction and also this

going to be credential do ID so we just

need to pass in the ID and also now we

can get the tokens

um so we can create the new tokens so

the access token and also the refresh

token

just right here but for This time uh

instead of it being user uh we're just

going to change this to be uh credential

id credential email. Same thing for the

refresh token and we only return the

access token and refresh token. So this

is the only data we need to return when

creating when logging in. There's

nothing else we need for this one. Okay.

And now let's also create a new method

for refreshing the tokens. So let me go

outside of this one. can say con uh this

is going to be um

or instead just export con actually. So

export con so we can use it. So export

to con con. Okay. I'm going to call this

refresh

token tokens. Okay. And it's going to be

a sync. And inside of this one we're

going to take the token which is uh

token which is going to be a string. And

this is going to return a promise. So

the promise is going to be of tokens.

Okay. And this one is just going to be

so we can get the payload. So con

payload

uh which is going to be cost to verify

um a fresh token. We already have this

method. Pass in the token provided.

And inside of this one, I can say cost

uh token record.

Token record is going to be cost to

await uh refresh token. So refresh token

the method we just have as well. So

refresh token the the model I mean the

model we already have. So find one and

we're going to find it where. So we're

going to check in our database where the

uh token ID is equal to payload uh token

ID and also where the user ID is equals

to payload dot um sub which is user ID.

Okay. Okay. So, we're going to check

this token in the record and uh if so,

we're going to check if uh token record

is not there. If token record not there,

we're going to send for one valid. The

token is not valid. Right? So, I'm just

going to throw new uh HTTP error. And if

this is the message and you can just say

invalid uh token

invalid refresh token we can say also

refresh token.

Okay. And now we're going to check so if

uh token record dot expires at and get

time. So we're going to check if the

token has already expired. So we're

checking if the the token has passed the

it limit and this has expired. So we

also want to throw a new error. So we're

going to await token record

dot destroy. So we're going to remove it

inside of our database.

And also we're going to show a new uh

HTTP error. And we're going to pass in

the 401. And we're going to say uh

refresh token

uh has uh expired.

All right.

And after this one we can say uh const

credential uh credential and it's going

to equals to await user credential dot

bind by the primary key. So we're going

to print by the primary key and going to

be payload dot sub.

Okay. And we're going to check so if the

credential

if the credential is not there can log.

So if you want you can log this. So

logger

yeah logger and we can say one and here

we can pass in the user ID

is going to be equals to payload sub

and the message is going to be um user

missing

for refresh token

but this is just some cases that won't

we won't really be dealing with but It's

good idea to always check those.

So now you can go uh also referral.

We don't want to continue. So FL new

HTTP error and it's going to be 401 as

well. And the message is going to be uh

invalid um refresh

token.

And over here I can just say await uh

token

token record dot destroy.

Okay, since we're getting a new one and

you can say con new um token

record

uh it's going to be await

uh create refresh token and credential

dot id.

Perfect. And here I can just return. So

let's return

uh access token which is going to be

equals to sign access token. And here we

can pass in the sub

uh credential dot

id and also we can pass in the email. So

credential uh email.

All right. So same thing for the uh

refresh refresh token and also we're

going to be sign refresh token

but this time instead of this we're

going to pass in the token ID. So new

token ID

right so that's everything for

refreshing the tokens. So getting a new

one

and u also we need another method which

is the last one uh and this is going to

be so export

con uh it's going to be the revoke

uh refresh token. So we're going to

revoke this refresh token. It's going to

be a sync. We're going to pass in the

user ID

and this is going to be a string and uh

here I can just say await uh refresh we

can refresh token model we can say

destroy

going to destroy which one where the uh

user ID

yeah that's all we need for this so this

is everything we need for our services

and now we and go ahead and use them

inside of the controller. So we already

have few methods already

and inside the controller. So of

controller I'm going to add a new one.

Uh so outside of this one I'm going to

export cons going to be for our login.

So again hundra Andra and this is going

to take in the request and also async

and inside of this one I get the async

then request

request then the response and here I can

just like

get the uh so con payload. So I get the

payload and then from the request do

body as login input right

and also let's get the token. tok tokens

uh is going to be cost to await

login and it's going to take in the

payload

and I can do response for the response I

can just return uh JSON uh

JSON and pass in the tokens.

Okay, so that is everything for logging

in. Uh let me uh duplicate this method

since I don't want to type that again.

So I'm going just going to change this

one. It's going to be refresh

Andra. So refresh Andra. It's going to

take the same thing. We're just going to

change this. So I'm going to say con and

I can get from um request dot body

request.body and I can get it as let me

add the types I need. So refresh

token which is going to be optional of

string

and here I can just delete this refresh

token.

So we can check if the refresh token is

not there. Uh refresh

token if it's not there I can just throw

new uh HTTP

uh error. Right for new HTTP error the

code is going to be 400. And here I can

say um refresh token is required for us

to refresh this tokens.

And here we can just say con uh tokens

and it's going to be cost to await uh

refresh token uh refresh

token

refresh tokens right uh refresh tokens

from our services and pass in the

refresh um

pass in the refresh token then return

the tokens.

Make sure to add this method refresh

token from our services.

And lastly, we have the export con and

we're going to add in the revoke uh

we're going to revoke the 100 revoke

tokens. So, same thing, but we're also

going to get instead of getting the

refresh token from the body, we're going

to get the what? User ID.

Great. So, we're going to get the user

ID, which is also optional string. And

we're going to check so uh we're going

to check so if if there is no user ID uh

we can just return so for new HTTP error

and the uh the code is going to be 400

and here we can just say user ID uh is

required

and over here we can just say await

revoke so we're going to call the invoke

token and we can pass in the user ID

and here I can just say this dot status

and we're going to pass in 204

and here I can just say send nothing

else and uh yeah so these are the method

we need to add in here and now we need

to add them inside of our louds so let

me go to the louds and um so the routes

um routes off louds. We're going to add

few more. So, let me duplicate this. So,

uh four times. The second one is going

to be for login.

So, login v request we're going to have

in the login schema.

We already have that. And also this one

going to be uh uh login

Andrew. Okay. And this is going to be

post. They are all going to be post. And

another one is going to be for revoke.

So the token refresh schema. We don't

have that. And also refresh. We can

import this. And the revoke we can

import this.

So let's create this few we don't have.

Let me check. Did we create them? Yeah,

we have them actually. Uh so yeah, we

have this this created. So these are the

loads that we're going to use for our

authentication service.

These are enough. And um we already have

this here. So we don't need to touch it

here. And I can say that we are really

done with for authentication like um

that is all we need to add. There's

nothing else. um unless I forget

something. But now we can go ahead and

add it inside of our uh gateway service.

So we can start um testing this and see

if it's actually uh all we need to you

do. So inside the gateway service src

services of proxy

we already have most of things we

already have for logging in.

So now we're going to create for

registering uh for logging in. Oh, we're

there for registering. We're going to

create for logging in for refresh and

leave working. Okay.

So uh I can copy this method

down here and I'm going to change this

to um login. The payload is going to be

um

login payload. It's going to turn uh off

tokens. So off tokens

and response going to be await crime.

This is going to be of tokens and going

to be off on login and pass in the

payload and off headers as well. It's

going to return response data. Perfect.

And I can copy this one again.

And this time it's going to be for our

refresh. So refresh

and this one's going to be a refresh

payload. So refresh payload it's going

to return off tokens as well and it's

going to return on the post. So wait

current post of tokens of refresh header

as well. So yeah nothing else. And now I

can also copy this again

for uh revoking. So for revoke revoking

our token and uh this is also going to

use revoke payload

going to return promise. Uh but this

time we just need to pass the await

client.post of revoke. We're not sending

or receiving any data. So we're just

going to return this.

Okay. So this everything for this and uh

I believe now we also need to add it

inside of our LS or no our control. I

mean we also need to go inside of our

controller and create this uh new method

we just added. So controller

and um after this one so register user

we can go ahead and add so export cost.

Actually let me copy the first one so we

can use it. Let me copy this one. And

here I'm going to add in um uh qu login

user. We don't have to async

request. And uh instead of

of proxy is going to use login. Okay.

And this one is going to stay the same

for the response um can stay like this.

But instead response

uh oh yeah uh login.

Yeah,

login schema. I also need to use the

login schema.

So, change this to login schema as well.

Um, wait, what did we call it? Uh,

validation.

Yeah, yeah, it's fine.

So, login schema and um

we can return. Let me call this uh I

don't really need the status though. Uh

let's do send uh we can just say let's

do JSON and let's call this to be

tokens.

So let me call this to be tokens

and that's all we need to do and let me

copy this again

and uh this one let me call it refresh

token. So

fresh token tokens async and this is

going to be uh refresh schema

and it's going to get the tokens of

service refresh pass in the payload and

return the tokens. So the last one is

for reforing. So this one's going to be

revoke um

tokens and uh this one just going to

have in as schema

of proxy revoke payload and we can just

send this status and nothing else.

All right. So we have our controller as

well and uh now we can go ahead and add

them inside the loads from our gateway.

So loud off and uh let's add them right

here. So we're going to add one two

three more methods. So we can just say

offer dot post and this one's going to

be for login right and it's just going

to have so the same thing. So login

schema pass this asynchra use the login.

All right. So let me copy this three

more times. So now this one the second

one is going to be for refresh

and also refresh tokens

reoke schema. Perfect. And revoke

tokens.

Yep. So this is the method we have. 1 2

3 4 four here. And uh brief now should

be working. So maybe we can test this

actually.

Um yeah. So let me close everything.

Let me close everything here. And let's

run our services. Make sure they run

without any issues.

Uh yeah, let me run all of them at once.

So

pan div.

Okay. So our services are running. Now

let's go and make uh the request from

our testing um tool we have. So inside

the HTTP here

actually let me just do something real

quick.

And I'm going to add the base load. So

can get base gateway so we don't have to

always hardcode it like that. HTTP 400

4,000. And over here I can just use this

base gateway. And um this stay the same.

This stay the same. So we can copy this

for others as well.

Uh but make sure to add uh like one like

these three uh where is it? Yeah, this

one. So that is the second one. This is

for uh off and login.

And this one is going to be uh for our

what? Wait, where is it?

Off register. Perfect.

So for logging in, uh, all we need is

just the email and the password. So let

me remove the display name. The content

type is going to be on here. It's going

to be changed from register to login.

And um, we already have this user

created. So let's try to login.

Okay. So, we can log in. Perfect. We're

fine. We can log in and uh briefly don't

have any issues. Yeah. All our services

are running. So, we can log in

and um what's which other one did we

create? Uh the other ones we are not

going to test them right now because

we're going to use them in the front

end. So, yep. So, that's our

authentication service done. And uh just

one last time, let me test something

really quick. For example, let's go to

the authentication service. Let me

remove one later. So I'm going to remove

four. Okay. From our API gateway of

token, no from our internal API token.

And now let me try to make a request to

login again.

Yeah, so it works.

Just wanted to confirm that. Let me pull

it back.

And now if I make a request again, it's

going to work. Uh, no, I'm not landing

there. So land them.

It's going to work.

All right. Um,

this is working as I wanted them to

work. So we have our authentication

service working and uh

I think for now this is done. So we can

go ahead and maybe also uh finish up the

user service uh as well since we have

it. Can go ahead and try to finish the

uh user uh service. So yeah, let's just

go ahead and do that. All right. So for

the user service as well, let's go ahead

and try to finish it up. So inside the

services user service

uh src inside the repository let me add

more uh methods we're going to be using.

So we already have find by ID we have

find all but we need also for create. So

after the find all we need to add the

create method as well. So a sync and

this going to be uh create

and I'm going to get the take in the

data which is going to be to create uh

user input which is going to return a

promise and this is going to be user

okay and inside of this one I'm going to

do con user is going to be cost to await

user model create with this data and

return to the main user dot user.

Okay. And uh also other last method we

need inside of this one which is for

searching user. So let me do a sync

uh search and this going to be search by

query. So we're going to search by query

and inside of this one we need to pass

in the query we need. So the query is

going to be a string

and I will also pass in the options.

So let's pass in the options which are

for example um the limit

right the limit can be optional it's a

number

and also we can exclude ID for example

if you don't want include our self in

the search result so we can just exclude

our ID which is also going to be

optional of

string and this can be an ali can be

multiple ids

and uh outside of this one uh just here

I can also add

this as an empty object.

Uh wait just a second.

Okay. Uh actually here. Yeah.

And now I can do a promise. So

promise

and it's going to return the user and

this an early and instead of this one I

can say con where right get where which

is equals to where options

where options is equals to inside of

this one I can get the or

Okay. And pass in this array as well. So

let's get the display

display name

uh which is going to be also up or is

like

um I like I like and we're going to use

this specific format. So add these

uh two strings and instead of them we're

going to use the yeah just like that. So

we're going to use the query and also

the dollar sign and then same thing for

the email. So we're going to email apply

and the query as well. So this is how

we're going to search our users and

we're going to check. So if options

uh do exclude ids and and and end

options dot exclude ids dotlength.

Okay. So we're going to check this as

well. And inside of this, we're going to

say object

dot assign

uh where

and this time we're just going to say um

of and can say and

here we can just add also another one

get the id

and inside of this one we can get up and

can say not

in it's not here and we're going to

return this options

dot excluded id

just write that

and after this we can just say con

con users is going to be to await

um user model so it's a await user model

user model dot find all and going to

pass in the where

pass in the order. So we're going to

pass in the order and we're going to

pass the display

name

going to be in this order

and the limit is going to be the options

dot remit or we can just make them 10.

And here we can just return user.m map

to the main user.

Perfect.

So we have these and I think this is all

we need to add from here actually. So

now let's go to our services. So instead

of my services user service I need to

add more methods. So on top over here I

need to use the methods we need we

added. So the first one is going to be a

sync and this is going to be get user

and we're going to get user by id pass

in the um

yeah so ID equals to a string promise

user or just user

and here we're going to con user and we

can check if there is no user. So if

they use no user pro uh HTTP

error and this one is going to take in

an um for the status and here I can just

say user not found. All right. Um so we

have the first method to get user by ID.

Uh the second one is going to be for

getting all users. So it's just going to

be straightforward. So as sync uh get

all

users

and this is not going to take anything.

Yep. Like this is literally it we need.

So returning all the repository from

find all. So this is all for getting the

user. Now let's create another method

which is for creating the user. So async

uh this going to be uh create user

and this is going to take in the input

which is type of uh createed

create user input and it's going to

return a promise

and uh it's going to be user uh user

sorry

user

and here I'm going to do try catch

[Music]

I'm going to do con user and await

this

uh dot repos uh repository dot create.

So pass in the input. Okay, return the

user and also here we need to do one

more thing actually. So we need uh to

publish an an event. So

um publish

user

created event

and uh for now this is fine. So yeah

and for the error I can check. So if

let's check if

um error instance of

unique constraint error from z.

So if this is the error we can just

throw a new http error and pass in the

http 49

for conflict.

And uh finally we can just throw this

error. Okay. And uh finally let's uh

uh add last method to

flow uh to such users. So as sync

search users

it's going to take in the params

type of uh let's define the type we

need. So query is going to be a string

and also the riit uh this going to be

like this actually tag and the riit is

going to be optional uh remember and

it's going to return type of number

and also the exclude ids optional of

string and here uh we are going to uh

return a promise of a user and this

going to be an array

and inside of this we can do con query

equals to um balance dot query dot trim.

Okay.

And inside of this one we can check so

if the query

dot uh query.length length

is equals to zero.

And here we're just going to return

nothing. Okay.

And after this we can just do return uh

this dot repository dot search by query

and searching pass in this query. And

here we pass in the limit and params dot

limit

extrude id is going to be params dot

exclude ids.

And also here we need to do the same

thing. So uh to do as well we need to

also publish this event. Same thing.

Yeah. Uh sorry. Yep. We need to publish

this event. All right. So now let's go

ahead and uh set up the this publishing

the event. So uh since this is related

to the user so we need to create a new

inside the packages common and inside of

my uh events I'm going to create a new

user event. So user events

ts and I'm going to let me see what I

added here. So we're going to reuse this

one and I'm going to so same thing

actually. cost except we're going to

send this to user

going to be underscore uh events

and this going to be um exchange right

exchange

and this we're going to create user dot

created

and the second one is going to be export

cost

and it's going to be user and going to

be underscore um

created

going to be underscore and it's going to

be uh nothing

key. Okay.

And it's going to be user dot created.

Actually the first one the exchange is

not is going to be uservents.

Perfect. And now I can do export uh

interface. Let's create the interface.

Interface.

And here I can say user um

created payload going to extend this

extend our event payload. Perfect. And

we're going to pass in this ID image

display name. And you can just say

export.

So export

type and this is going to be user

created uh created event

to outbound event

pass in the type of uh user created

loading key and also pass in the user uh

created uh payload right

yeah so so that's basically ally all we

need to do for this one. Now let's

export it. So inside of our index ts

file so after the of events uh event

types we have event let me add it here.

So export and it's going to be

everything from events and user events

and I think we can just build this uh

again. So, let me just find the command.

Um,

h where is it?

I think should just been easier to run

it. But yeah, so now we have that.

We have events. And now let's also close

all of this.

And um

All right. So inside of my

uh services, I'm going to create the

event publisher for our user service.

So let me see what I have inside of of

gateway services s

no inside of service s messaging.

Um I think it's going to be uh same

thing for this one.

Um,

let me copy it. I'm going to change it

if it's not the same. Let me go to user

service the messaging. I'm going to

create a new file. I'm going to call it

event and going to call it publisher

publisher.

TS.

Paste this.

And uh yeah uh already we can change

this to be user uh created routing key

uh user created created letting here and

also this ones can be user exchange

event and the type can to be um we don't

have the type uh let me remove this

and now we can import this. So um these

one are fine.

Uh okay just maybe maybe to avoid

confusion let's remove all of this

uh let's keep also let me yeah for this

one let me just import it. So m uh m uh

kp library

and uh uh we need to import the types as

well. and keep it. Yeah, let me import

the types. Uh this time I'm going to

import them in this way. So

type

and I'm going to get the user created

event

user created payload.

And also I remove the types that we

wanted actually to use.

Um

uh but yeah that's fine. Let's do it

this way. So uh it's going to be also

the type. So type

and it's going to come from uh am

library

and I'm going to use the channel

I'm going to use the channel model and

also

connection. Okay.

And now let me just do uh so type and

I'm going to say managed

connection.

Managed connection is going to be equals

to connection

or can say P uh where is the P

and we can say channel model

and we're going to add in cross. Okay.

And also it can be um what is the name?

Uh create channel. Yeah, create channel.

Exactly. Yeah, create channel. And also

let's say that connection

is going to be equals to type of manage

connection

type of channel or null and also the

channel channel or null.

Now let's do con and can say messaging

uh enabled

and we're going to say cost to

boo

and we're going to say mv and get rabbit

mql. So we're just doing the different

but the same thing. I'm just showing you

different ways you can do this if you

want. So con we're going to ensure uh

channel. So ensure the channel is there

and I'm going to say as sync

say promise

pass in the channel

or this also can be um null. Should we

make it null as well? So we're going to

make it null as well if needed. So let

me add null here.

And here I'm just going to say

um if uh messaging enabled if it's not

enabled we're going to return

null right and over here I can just say

if

uh

channel I can just say

uh return

channel right

Okay. And we can again check if we don't

have the AMV

um

uh just like we did before. So we can

check if there's no EMV

and we can say rabbit mqurl.

We can return

none.

And over here I can say a con

uh amp

uh connection. So we're going to create

the connection equals to uh await

mqp

connect

mitrl

and this going to be as unknown and also

as managed

connection.

All right.

So there is that and now you can say

connection it's going to be equals to

MTP connection

and we can say MQP connection on

and we can get the cross okay close here

we can

uh sorry yeah can get this one and

instead of this one I can just say uh

do one.

We got that one. And we can pass in the

message. The message can be a bit MQ

connection closed. Connection set null

and also the channel set null. After

this one is MQP connection on going to

check the error. So you already saw how

we're doing all of these.

So uh MQP error pass in the error.

And here uh we can just say uh basically

just uh log. So logger dot uh error. And

here I can pass in the error of type

error.

And here it can be um

a bit MQ

connection

connection error.

And uh after this one uh I can just say

con

mp

mqp

channel is close to await

mqp connection create channel and also

the channel is going to be equals to

MQP channel

and Um going to await MQP channel asset

exchange

passing the user event exchange going to

be

topic and as well

to true

and here we can just return MQ channel

okay

and now uh let's initialize our

messaging. So

outside of this one you can say export

con uh init

messaging

uh messaging is going to be a sync and

inside of this one we're going to say uh

if uh

if messaging is not enabled

and we can just say

dot

info

and we can say um a bit

MK URL is not configured.

Uh configured.

So messaging

messaging disabled.

Yep. Messaging disabled. Then we can uh

do it. We can just return.

And over here um

uh we can just wait

insure channel. Got it. And also we can

just log dot info and we can add a

message. So user service let me keep

initialized. And now let's add another

method to close the method to cross the

messaging.

So export con

messaging

going to be I think

and inside of this one

I'm going to say try catch.

So if

channel and inside of this one I can

just say con

current

channel. So let's check the current

channel of type

channel

uh is going to be to channel. Okay. And

over here I can say the channel is going

to be close to none

and await uh current channel is going to

close

right. So over here after this one let's

say if we have the connection.

So if there's connection

uh I can go inside of this one

and I can say con as well. So current uh

connection.

So same thing we just did go to managed

connection connection connection none

await connection cross inside the catch

we just log this error.

Okay. And now let's go ahead and publish

the user created event.

Uh

yeah.

Okay. Now finally let's explore our last

method. So export con and this is going

to be con uh publish

uh user

created. So publish user created

event

which is going to be a sync

uh

taking the payload

payload of type user

created payload

and over here I'm going to

um con channel

to await

ensure channel. Okay.

And if there is no channel,

we're going to say rugger

loga debug. This time we haven't used

debug at all. And pass in the payload.

And the message can be um

uh we can say

skipping

user.

event

publish, right? And say just say

messaging

disabled.

And over here we can just hit done.

And here if everything is okay, we can

say event it's going to be to user

create

user created event.

And inside of this one pass in the type

going to be user uh outing key

payload

add going to be new date.

So we're going to say to iOS string

pass in the meta data uh the version is

just going to be one.

Okay. And uh after this one I can say

try catch and there I can just say con

success is equals to channel dopublish

and inside of this one I can just say um

yep basically passing the user event

exchange user routing key and buffer

from JSON string file event content.

Yep. Yep, everything is as I wanted it.

And also if it's not success, logger one

publish user created.

Okay, so we need to use this one as well

inside of uh we need to initialize our

lab mq inside of our index.ts.

So uh just here I can say await

uh init messaging

and let's use this

and now we need to do to where we left

uh some of to-dos we need to publish

those event. So inside the services user

service we have two todos. So let's go

here. Let me remove this now. And we can

say uh void

um publish

publish user created event. And inside

of this one, I can just add in the data

that I need, which is the ID. It's going

to be user id. And also I'm going to

have the email, which is going to be uh

user image. I'm going to have the

display name. Uh I don't have this. So

just display name it's going to be user

dot display name I'm going to have

created that going to be user dot

create that and to else string

perfect so let me copy this and I'm

going to do the same thing for when user

is synced.

Okay.

Yeah. So this is all we have to do for

this one

and um yeah. So let me start the

services to test of pinp.

Okay. Uh user service user database

database sync user key publisher

initialized. Perfect.

Perfect. Perfect. All my services are

running.

Okay, so this is the um user service

most of the stuff done.

Uh now we should actually go ahead

and start uh using it inside of our

controllers

and also create the allows that we need.

So yeah, let's go ahead and uh do just

that.

Okay. Um, so let's go ahead and start

adding our user controllers.

So, uh, I'm going to go inside services

user service.

I'm going to create a new folder. I'm

going to call it controllers.

And inside the controllers, we're just

going to have so user controller

this.

And uh um now the first control I can do

is getting the user. So you can say uh

export cost and you can do get

user and we can either do it

as a type. So let's do it. Let's assign

the asynchra

just like this. Um but we need to

say type or we can do it the other way.

Um yeah we can do it different way. So

I'm just showing you different ways you

can use this as well. That's the try

catch. I'm going to have con status.

Let's get the status equals to await

uh user service

user service dot uh

uh I know the status what am I doing uh

cost supposed to be

let's get the user ID

let's get the user ID from the request

dots

right

supposed to be cost and request params

and let me cast it as unknown and also

as um uh with ID.

Uh but I don't like this. So I think I'm

going to create uh validation for this

one. So we have a good types. So inside

of my CSC, I'm going to create a new

folder. I'm going to call it validation

and I'm going to create a new fate to

call it user schema.ts

and right here we can import

[Music]

uh and we can get it from our chat app

command.

So this is our internal library. So

let's do export

con

uh

created or create user schema. Let's

just create the all the schemas that

we're going to be using. So we have the

email which is going to be sort of email

um

okay string

and also

and email yeah this is what you need

display name string minimum tree and it

can be this way

and let's do export con

uh let's say get the user the ID

param schema. Okay, schema. So this is

what I'm going to use actually

and I'm going to have in just the user

the ID which is type of UU ID and here I

can say cost

we can call it exclude ID. So exclude

uh exclude schema what you want to

exclude and this is just going to be z

dot uh union

inside of this one I'm going to have in

uh sorry uh yeah I'm going to have in

this z dot array okay so dot array

inside the array I'm going to have in

this s

dot string

And this one's going to be type of UU

IID.

And outside of this, I'm going to have

another Z

dot string as well.

And this one is going to be as well UU

ID. Okay. And uh we can transform this.

So let's do transform

taking the value

and this value is going just to be a

value.

Okay.

So we're getting this and let's make

this as

optional.

Optional.

And outside the optional uh let's also

transform again. So transform

get the value

and

just value

otherwise

just in.

So this is for our exclude schema

and that is to export post. Uh we can

get the

search

uh search users

query schema

and this one going to be say dot object

and instead of this one I can just say

query

set dot string

string dot trim

dot stream dot min

and uh can oh we need to pass in the

minimum it can be two three or yeah just

whatever you want and for the limit

I'm going to have it so let me just make

some space going to do union again so

union inside of this one

we're going to have in

third

so do string

and this one is going to take in uh just

string and so it's text dot number

okay

and outside of this I'm going to say

transform

here I can just say for you

for you

and make this a number

perfect. And I can just refine this. So

define

take the value

and here I can get the number.

What we can check is integer

and here pass in this value we got

and end. We can select the value right

the value zero and end value

uh 25

and it's still inside of this refine

actually see inside of this one we can

pass in a custom message. So say message

and here we can just say uh like the

limit must be between 1 and 25.

Okay.

And here it's going to be

uh optional.

Here I can say uh screwed

it's going to be equals to exclude

schema.

Uh yeah just add this here

and finally we can export all these

types. So export type uh

search

users query which is going to be equals

to Z.info info type of search query

schema

export uh type which is going to be for

our create user body and also also there

is close type for our user ID params.

Okay, so export

type and this is just going to be the

user ID params.

Yep.

So this is everything for our validation

and I can go back here and create this.

So forgetting the user instead of using

this uh let me now get the correct uh

user ID params. So user ID params

perfect and I can just get in this ID

and here I can say cost user going to be

equals await

user service dot

um

uh get user by ID pass in the ID

and here I can just s dot JSON

pass in the

data which is going to be user.

Okay. And inside here I can just return

next error. So that means we also need

to add next over here.

Perfect. So let me just copy this and

we're going to do the same thing for

getting all users.

So here I can just say con

get all get all users.

So we're going to instead of this one,

okay, so we remove that

and here I can just say cost um

uh users. So let's get the users going

to be to await

user service get users pass in the JSON

data return the users. Okay, now let's

copy this and paste it here. And this

one going to be for creating user. So

create

user

and this time we're going to get the

payload. So get the payload and also

import this create body user it created

user wait user service create user pass

in the payload return the data as the

user.

Um you can also maybe add the status

which is 2011

and uh finally we can add the search

users. So

can just say search users

and here we're going to use

uh different we're going to use the

params. So we can say equals to request

dot query sorry I mean the query and as

unknown can say as unknown and also as

such users query

and inside of this one I'm going to pass

in the query and I'm going to get the

remit I'm going to get in the exclude

okay and now for the

search users. I'm going to pass it this

way. So as an object passing the query

pass in the remmit and also the exclude

ID is going to be to exclude.

Yep. And we have to just return this

with all the status.

So JSON and um yeah this is pretty much

it that we need and uh I believe now we

can go ahead and create our loads.

So let me create loads

loads folder and inside of this one I'm

going to have user dot loads dot ts

and here I can just input the

router

uh from express

and also I can just get this. So just

the same thing we did before. Let me

import uh from the

uh internal package which is a sync uh

hander and also the validate request.

Okay. And uh now I can do export cost

getting the user loads

which is type of router

and it's going to be equals to router

uh router. Yeah.

And here I can say user allows dot get

this going to be getting

uh our all users. So it can be on the

slash

and you can say async

equals to get

uh all users.

Okay. So this is all for uh getting

users. So let's create this down. The

second one is going to be uh also a get

and this is going to be for the search.

So search

going to be async hander

but we're going to validate the request

here validate the request and pass in

the search user query schema but we need

to pass it as an object.

So pass this as query

and then pass in the method we created

to search users. Okay. So this is for

searching the users. So we've added the

request, we pass in the query.

Now I can duplicate this

and uh this time it's going to be uh

forget as well.

that is going to just be the ID. Yeah,

the ID.

Yeah, passing the param.

And also it's going to be get a user

just single user. Okay,

perfect. And uh last one is going to be

for post

which is on just on the slash and this

is going to be for the create. So we

pass in the body and create user schema.

Yeah. So this is all we have

and

Yep. So this is all the loads we have

for now.

Yeah. And um we can go ahead and create

the index file as always.

So inside the loadouts I'm going to

create a new file call it index.ts

and I'm going to um

so maybe I can just import the we

created or I can get the types

for this. So let me go to the express

and this time it's just going to be the

type

and here I can say export

cost

uh register create register loads

and it's going to take in the app of

router

and inside of this one

I'm just going to return this is going

to equals to and I'm just going to use

app dot use

and just dash users

then uh user

loads.

Perfect. And now we can go ahead and

start using it inside of our app.ts.

So inside the app.ts Yes. And after this

middle area we can say uh register

routes and pass in the app.

Okay. So this is coming from routes.

Yep. So we have these louds

and next thing we need to do is use them

inside of our um API gateway. All right.

So before we go ahead and start using it

inside of our API gateway, uh we need to

create a method to authenticate or to

verify that the user is actually

authenticated.

Okay, so this is what I mean. I'm going

to go inside of my shared packages

and inside HTTP I'm going to add one

more method and I'm going to call this

off.ts.

Inside this it's going to be very

simple. So I'm going to say export

interface

here. I'm just going to export the

interface. Now I'm going to call it

authenticated

authenticated uh user.

And here I'm going to just get the ID

string and also the email. This one is

optional.

And it's going to be a string. And also

I'm going to export

con uh export con. I'm going to get in

the user

ID in the header. So user ID in the

header and it's going to be called X

user

um ID.

Okay, so that is all we need to do and

now we need to export it. So go inside

of our index and I can put it uh maybe

here. So let's do export

everything from our

uh HTTP

and then of

okay and now let's build this again.

Perfect.

And uh now we can go ahead

and uh

start using it inside of our API gateway

since this is the press we'll be uh

validating if the user is authenticated

or not. Um yeah, so let's go ahead and

actually uh use that there. I think

we're going to be using it inside of our

services. um

or our controllers. So let me go inside

of my services

and inside of us gateway service

s

and the utils I'm going to create a new

method which I'm going to call of uh

of thets

and here I'm just going to import what

we just created and also I need

a few more threads from common So

uh this supposed to be

import okay

and it's going to be http error and also

let's get the type we created. So

uh authentic get it. Um

it is not get the new step we just

created

authenticated user.

Um

did I view this correctly?

Okay. Type

authenticated user. Yeah, here it is.

All right. So, we don't need the head

the header right. Now, let's also input

uh type of request. So port type

request from express

and here I can do export con

uh get user

um authenticated

uh get user authenticated

user. Oh just get authenticated user.

Get authenticated user make much more

sense. Here we pass in the request which

is going to be type of request

and here it's going to return this type

of authenticated user

and over here we're going to check so if

there's no request dot user okay we

don't have this user on the type request

we're going to add that I'm going to

flow new

HTTP error and this is going to be 401

and the message can be um unauthorized

and over here we can just return request

dot user okay

now this type is missing so let's add

this user on the request so inside I'm

going to create a new folder I'm going

to call it types inside of this I'm

going to create Express

t.ts.

So this is how we attach types to our

express

and here I can just say get the type as

well from authenticated user. So type

okay and here again can declare

and let's make it global

de global and here I can get the name

space

name space of express

and here after this I can attach the

interface. So let me add the interface

on the request. This is where I want to

add it. And on the interface I want to

add the user which is optional and it's

going to be authenticated user.

And uh you can just make export.

Okay.

Uh let me close all of this. Let's go

back to our gateway and instead of uh ut

and now we don't have the error anymore.

Okay. So now let's go ahead and create

the services for our user. So same thing

we did. So user dash proxy

and uh dot service.ts.

Okay. And here we're going to have

basically the same start settings. So

for the header and also for uh so let me

just show you. So this one here is going

to be the same.

So let me add this here.

And let's import what we need. Let's get

the all of these. So all these inputs

are these here

and we need to change this from off

service URL to user service URL. So

let's change it here. It's going to be

user service URL. That means we need to

add it. So let me go to the config file

and we can add this. So config

m and after the getway port let me add

it here.

And this is going to be uh just same

thing as the string and URL.

And after that we need to add it inside

of our index. So our M file I mean and

here uh I can add it on top. So here you

can just be local host 3000

and one.

This is where our of service is user

service is learning at. So we have that

now

and um

uh we can go ahead and continue. So back

to our

service and uh here we can create the

the interface. So export interface this

going to be user DTO.

So user DTO is going to have in just the

ID of string and the email of string the

display name of string

and I created that

created that of type string and for

updated that

type of string.

Okay. Now next we're going to have so

export

interface. Uh next we're going to have

user response. So what we get when we

make a request user response is going to

be just the data if you remember return

the data that contains this user dto.

Okay.

So after that we also need for the user

when we listing the user. So export uh

interface. So, we're going to have user

list DTO or not user list DTO but user

list response

and inside of this one I'm going to have

in data which is going to be user DTO

but this time it's going to be an AL

and here is adding so export

interface this time is going to be when

we create so Create user payload.

Create user payload. And email it's

going to be type of string

and display

name is going to be type of string.

Display name. Yeah. So here also let's

do export interface.

And this is the last one for searching.

So

such users

uh prance

and inside of this one I'm going to have

the query

query uh sorry query type of string. We

also have the limit

uh type of number

and we also have the extrude. So extrude

which is type of string and ali.

All right. So that is all we have. Now

let's also get one more thing inside of

chat service which is this one for

handling the errors right

so

message and handle xus message so let's

get this

handle xus error and resolve message

so we can use it here as well

and yeah so it's going to be the name.

Yep, this is fine.

Uh we can change this to user

user

user service.

Okay, so we have the user service and um

now let's go ahead and keep using this.

So over here uh the first one going to

be export con and this is going to be uh

user

proxy user proxy service that's how

we're going to call it and inside of

this one going to have all the methods

we need. So the first one async is going

to be get user by id going to have in

the id of type string and this is going

to return a promise

of user

uh response right user response

and inside the one we have try catch

inside the try catch you get the

response.

Go to await

client dot get inside of this one. I

expect this user response

and uh the request is going to be on

what's wrong with this keyboard, man.

uh users and it's going to be on ID

and also we need remember we need to

pass in the of header so of headers or

header

and here I can just return response

dot data

and on the error we just need to handle

uh um

done under

and express error and pass in this

error.

Perfect. And um next one is for creating

or getting our users.

So let's copy the first one.

It's going to be get all users

and it's going to having the

payload with this

um

or we actually don't need anything when

we're getting users. So get or user

doesn't need anything but the type is

going to be uh the user list

user list response

and on the end point it's just going to

be on uh slash users

pass in uh the off header only and the

return this now for creating the user.

So create user taking the payload of

create user payload promise user

response we're going to be on users

payload and off header return this one.

Now for searching users as well. So for

searching user is going to be a bit

different but the response is good. So

for the response for example await

client get user list response is fine

and uh

going to be on search

and for the params I'm going to change

them. So inside the params let's uh

change it. So we're going to have

headers okay which is going to be of

header dot headers.

Okay. And the params

under the params also I'm going to add a

few more. So I'm going to say query

and I can say params dot query

and I'm going to say

split disk uh sorry

I'm going to get the params dot remit

and this is going to have in the riit

of uh params dot remit it

otherwise it can be empty

and after this I'm going to have this

like

params exclude. So if we have this as

well going to do params

dot length

to zero on

exclude exclude make sure to spell it

correctly parsrude

and here we can just repeat this empty.

Okay. Uh so this is for the search and

here we can just return this response

and uh that's basically everything we

have for the users

and um

yeah now we need to go inside of our

controllers and we need to create a new

controller related to this. So inside

the controllers let's create a new file.

It's going to be user dot controller.ts.

And here I'm just going to create the

first method which is for us to get the

user.

So yeah, we can import uh

so export con or let's see what we have

inside the user of controller.

Okay.

So, async, we're going to need this

async.

And let's import it here.

And uh we can say export

export con

get user

type of

async

going to be a sync

request.

Yeah request and um

yeah it's going to be a bit different

but for the error is fine. So inside the

tray catch I'm going to con I'm going to

get the id which is equal to user

uh ID param schema

we created that I'm sure we created that

said the validation of schema or we

created it but it was inside of the user

service

um we also need to create the same thing

inside of our of service. So let me go

inside the user service inside the

validation user schema. Uh let me copy

this content

inside of our gateway service. Create a

new um user schema.ts.

And here let me remove stuff that I

don't need. So search user query is

going to be the same but for the types

uh I'm just going to export

this one. So search user query string

but uh the rest is

yeah the rest is the same thing. There

is nothing we need to change here.

So we can go back to this one and search

say search param schema dot pass and

pass in the request dot

uh params

and we can get the ID

and here I can say cost response

that's response cost to await

user

service

and we can say get user by ID pass in

the ID

and here I can say is dot

JSON it's supposed to response

okay and for it can just be like that so

let's copy this down so we can add more

method we have so now we have also for

get users so get

get uh we can say Get all users.

Get uh get Yeah, get all users. That's

how we called it. Async request. And uh

this time we don't need really anything.

You just get say get all users pass in

the response as the results. And now

let's copy this down. Another method we

have is for creating the user. So create

user which is just going to be uh

create user but um instead of passing

this request body like this we have so

con payload it's going to create

user schema

pass in the request and the body

then passing this payload inside of our

user service create user.

Okay. And also since this is a create,

we can add in a status of 201.

And pass this again.

And the last one is going to be for

searching users. So search

users.

And uh we're going to

change it a bit. So let me remove this.

I'm going to say con and it's going to

come from con user. We're going to use a

method. So get authenticated user pass

in the request.

And over here I can just say con

first um query.

It's going to the type of uh search

users query equals to search

uh users query schema dot pass pass in

the request dot

query. Yeah, we're getting the query and

inside of this one we can get a cost.

Let's get the from the first query and

here we can get the query and get the

limit.

We can get the exclude as well and over

here we can sanize this. So conisized

uh sanized

exclude

I exclude and inside of this can say

array dot from pass in the new

set and inside of this one I'm going to

spread this

exclude then the user id

And after this one I can say con users

equals to await

user uh prox service dot

so got such users and inside this one I

can get the query the limit and exclude

then return JSON but we're going to

return as data then use Yes.

All right. So, this is everything

everything we have. Now, we need to add

in inside the louds. So, inside the

layouts, let me add a new layout. It's

going to be user

loud.ts.

And here all we need to do is um

is so we're going to import from

from our

internal library and we're going to be

creating getting the async

uh validate request

and also let's import

the lo

from Express. And here we can just say

export

con

export con user uh router. And here I'm

just going to say

router and then router.

Yeah, got it.

And then I can say user router dot get

and on the first.

We're going to use the

uh a new method that we want to create.

So um

we can

validate if user is logged in or not.

So let me go inside the middleware in

our gateway service. I'm going to create

a new file. I'm going to call this

require

of. So user need to be authenticated. So

ts and inside of this one we're going to

create a new method and with that we're

going to need to get if user is

authenticated.

So let's check our package.json and

let's see if we have JSON web tokens.

Perfect. We have JSON web tokens. So we

can go ahead and import JSON web tokens

and also we can go ahead and import

uh from

uh our internal package and we're going

to get

uh the HTTP error and also the type of

uh authenticated

user

and let's also import

type and this is going to be go to a

request and request

100. Yeah.

and uh resource input our EMV

just small EMV

and interface we're going to use for

this one is uh so the access

access tokens token claims

it's going to be our sub which is a

string

our email which is optional

of string. Okay.

And now let's pass the authorization

header. So we're going to say con pass

pass

author

authorization

authorization header.

And inside of this one I'm going to get

the value of string.

And this one can also um be undefined

I'm sure. Yeah, we can also be undefined

for this one.

So actually let me move this. So it can

just be undefined

not none but it's going to return a

string

and I'm going to check. So if there's if

there's no value right if there's no

value we throw a new HTTP error 401 pass

that's in the message and this can just

say anized yeah that is fine and I can

say con and we're going to get

the scheme

and also the token

and this is going to come from the value

dotsprit

uh value dotsprit and I'm going to split

by an empty space

and we can check so if the schemas

to the right case yeah to case and

and check the here PLL because you need

to make sure that the user who make

request to this authenticated loads are

actually um authenticated.

So yeah, we're going to add and also

check if there's no token. We're going

just going to check unauthorized. Then

finally, we can return this token.

Okay.

And now we can go ahead and

say so con

to authent to authenticated

uh user. We're going to get in the cr

which is the access token cre.

We're going to return the authenticated

user

inside this one. I'm going to check. So

if

the gra sub is missing

uh we're going to return and a new error

http one unauorized otherwise we can

just return this id crimes sub email crl

and here I can just say export conquire

of and it's going to be of type uh

request Andra

inside of this one I'm going to get in

the request

the response and also the next

and this here can do a try catch

and I can just say con token

to be across equals to

request header. So request dot header

headers request headers dot

authorization.

Okay.

Conra

is going to be equals to JWT

dot uh verify. So we're going to verify

this token

and also pass in the M dot

uh JWT

secret.

We do not have this as access token

creams.

Okay. So we don't have this JWT secret

and we can go ahead and add it. So

inside of our env. And uh after maybe

here,

let's add this. It's going to have 32 uh

as the characters.

And we need to add this inside of our

env.

So after this here, I can add uh JWT

secret. Uh this is not going to be the

same but uh

we can use this for now.

And uh also we need to make sure

actually that's the same uh token that

we have inside of our other services.

So such as for example the

authentication service I brief. This is

the most important part that we have the

same uh key inside of.

So we can go inside of our uh

authentication service. Let me close

this authentication service env. Yeah,

this is the key we need. So I copy this

key W secretway

service inside the envir

verifying this keys and pass in this

secret.

Okay.

So now go back to require

and we have the the the now. So can say

request dot user can attach

this uh to authenticated user and pass

in the crs

then to next

then otherwise if there's an issue so we

can check if the error is

uh uh if the error or if error instance

of

HTTP error.

We can just say next then error

otherwise we just return or here we can

yeah we can say next

and pass in the new HTTP error

and say unauthorized.

Yep. So this is all we need for the

requiring the authenticated user.

So let's go back to user loads.

And here we can just say require

of

going to async and we can say get all

users.

Okay. And the second one is going to be

for

Yeah. So we're going to have the second

one. Let me actually put the second one

for such. Let me put it on the second.

Let me put this schema.

Okay. I did it again. Okay. Let me put

it the schema and also search users.

So for searching users we need also the

authenticated it's a get method require

of and uh remember that this is need to

be inside the object and this is need to

be a query right

yeah so we need to require a request now

we can also for the getting a user we

need to import this as

And we need to update the second one as

well and import this schema

and also import the create user.

So the last one is the only post method.

Second one is the ID. We're getting the

user with the ID and um

yeah actually also for getting the user

brief we have the params. Let's use

those. So we need to pass in the params

for getting the use of the ID. So

everything here is validated

and um yeah I believe that's basically

all we have to do now. We just need to

pass it inside of the main loads. So we

can say app

dot use pass in the users

and we can say user loss

user allow. Yeah.

All right. So, we have this um

I believe we can go ahead and start

maybe working on the um chat service,

right? Let's go ahead and working on

chat service so we can be able to move

on and go to the uh front end

application as well.

All right. So, we're going to start

working on the uh chat service, which is

going to be a bit more uh complex than

the other services that we have. Um, so

let me add the database we're going to

use for this one. So, for our chat

service, we're going to be using MongoDB

service. MongoDB database. So, let me

call this

and the image

going to be Uh we can use this

version or let's use version seven

and the container name chat app

the ports it's going to be this one the

volumes environment

okay K

so password Jup network

and also we need to add in the data

actually so

um H

yeah let me add the data so volume I

mean MongoDB uh can say data data

DB and now I can go on the bottom and

create this um data. So let me go over

here and I can just add in this

data.

Perfect.

Okay. And now let's go ahead and start

setting up or let's run it first. So uh

docker

compos

hdong

pulled right now.

So this is the MongoDB running.

Great.

So we have this. We can close uh all of

this. And we can go inside of our app

and services. Create a new folder. And

this one is going to be our chat

service. So chat

service folder.

And here I'm going to add in

um the finger always create. So get

service. Let me copy the TS config.

So this is the like we literally did

this two or three times already. So copy

the TS config. Uh this is not going to

change at all. We're always going to use

the same thing as I said. And also we

need the let me get the the CRC folder

and let's initialize this as well. So CD

services and chat service pm in it.

Great.

Should we install the packages we need?

Um yeah, we're going to need a bit uh

too much of packages for this. Uh but

for now, we can add the packages that

I'm going to be needing.

So um

set the package JSON.

Uh let's add the packages that I'm going

to add. So p add. And the first package

is going to be for my um IMQP

uh lib for our uh rabbit MQ. So MQP lib

great. Going to have course going to

have express

going to have hermit.

We're going to have uh IO IO radius

since we're going to be using radius in

this one for caching. uh JSON web token.

JSON web token we're going to use

MongoDB

and also going to need socket.io.

Okay. So, PNP add all of these.

Great.

So, we have them. And now we also need

to add their types. So, I'm going to go

over here. say types for this one

and uh for MongoDB I'm not sure that we

need any right now let me remove it

and also for JSON web tokens

uh I don't think so for IO rad this

sure I don't think we need this one as

well and for the hermit

yeah we probably

uh types. If we're missing something, we

come back to this. So, I just want to

set up my uh server.

So types

uh types

and as well as mash

d and then

types. Okay.

Okay. So we have this

and uh now let's also go back to our

gateway service inside the package.

Let's copy the scripts.

Go to our chat service package.

Replace this script with this one. And

also we need to add our package

our internal package. So let me add this

one.

And uh I'm going back to chat service

and I'm going to add it

um just on top here.

Okay.

Okay.

And um can do PNP PNP install just to

get it PNP install just to make sure

that we have everything that we need.

Yeah.

Okay.

Uh let me close this. And now let's go

ahead and do the thing we always do. So

creating the app.ts.

And um inside here let me create app.ts

and also let me create a new one which

is going to be index.ts.

So these are our main entry files and we

can start with the app.ts. Uh it's going

to be like literally the same thing for

the gateway. So let me copy the app.ts

for our gateway chat service apps.

Okay.

And we're going to still use the same

error handling. So get to a service

middle

uh let me copy this fileandra

chat service src create a new folder

call it window

paste in this file

and we need to create the logo as well.

So gateway service let's copy the whole

config folder chat service src paste

this config folder

okay and inside this config folder we

need to change some stuff so instead of

getway port we're going to change this

to be uh chat and service

port

okay no DMVs can say the same we don't

need other services ports since we're

not using them here. We don't need the

we need the GW2 secret. We need the

internal API token

and also we need um datab MQ URL. So we

can add that as well.

We need also the latest URL and also the

MongoDB URL. So after this one,

so I read the MongoDB URL and this URL

and I can put the uh MQ here just so

they are together but yeah it doesn't

matter. Okay, so the internal EP token

JW token also put it on the end here.

Okay,

JWT secret. And uh this is all the

environment variables that we're going

to need for this one. So we can close

this check our herandra. Yep. And also

need to add in our logo. So

yeah, actually let's copy the one from

um the

uh user service

logo

or is it uh where is it?

Yeah, let's copy this for now. Uh but

I'm sure inside the it is

yeah let's copy this one since we're

going to also let's copy the one from

gateway the whole folder we're going

also need going to need this

authentication

util so inside the chat service and

inside the src let me paste this util

and here

um yeah we also need to add the types

but other other than that this is fine.

U and let me go to the

getway folder again. Types. Let's copy

the whole folder of the types from

gateway and you can paste it inside the

SRC of the

um yeah so it's going to be the same

uh for now. We can always remove this

route

but yeah remove it here as well.

And I don't know why it's not. Yep, this

should be fixed.

So, yeah, this is all we have inside the

app.ts. Let's check that we don't have

any errors.

Yep, good.

Oh, yeah. Let's change this. Yeah, thank

you for suggesting that. Going to change

this to chat service. So, let's go ahead

and change stuff to chat service.

Okay. and inside the middle error.

Good.

Okay. Config. We also need to change

this to chat service.

Great. Let me close all these files.

Let me go inside of my um index file.

And now let's also set up our index uh

file as well. So let's go back to the

gateway

index.

Let's copy the whole content inside the

chat service index. Let's paste the

content. We only have one single error

which is for should be chat uh chat

service port.

Great.

Uh I just need to change this to chat

service

and also this one to chat service and

also this one can be changed to chat

service

and other than that everything will stay

the same. We're just going to add some

more more a few methods uh for example

for uh initializing our MongoDB database

starting our radius and also some uh

consumers from

the user service.

Okay. So other than that all of this is

good. We just need to add in the NV file

with all the secret that you need and I

believe we can get the one from getway

service. So let me just copy this since

we also need the JWT secret. So let me

go to chat service and paste this env

file. Let's just change the chat service

going to run on port um yeah chat

service ports going to run on port 402.

We don't need to add in these two

but we need to get the rabbit mqurl.

Why did we use that instead of the

services?

Yeah, we have this rabbit mqurl. So go

back to chat service

URL and also uh we need to add in the

 URL and as well as the lad this

URL.

Great.

So we need to fill in the MongoDB URL as

well. So for MongoDB

uh let's check what we have.

Um yeah. So for radius it's going to be

this way for local host and passing this

and but for MongoDB since we have a

password actually I'm not sure the

username is going to be root

right and also uh the password

I don't remember about MongoDB for

authentication

don't know if this is the way

And at uh the I hope it follows the same

structure as it does. And

yeah.

Okay. Uh let me just check that out.

And I'm going to say MongoDB

uh URL.

Okay. Let's see. Let's see what it will

show us.

Yeah.

So, this is the exact same format that

we are following. So, we have the um

MongoDB, the username, the password, the

host, the port, and the database.

Okay, great. Um, but we create a

database, but I think MongoDB it will

give us the database by default. If we

don't create one, it will create it

itself as long as we specify it here.

Yeah. And also just remember that we

don't have the uh radius database

configured. So we should as well maybe

just do that.

Uh so let me make this over here

after the liab before MongoDB. Let's

also add in radius. So this going to be

just radius. And here inside the

services I'm going to have in the image.

It's going to be very simple. The image

the container name

and uh we're not going to have any

volumes. So we have the radius 7 chat

radius port. So this is the port the

network and yeah that's that's basically

everything

and we already have it right here.

So let's do uh let me go to the root

folder. Let me say the docker compos

app dashd also get the radius. We can

check if that is the case.

Yep. So we have radius ready as well

and uh let me close this.

So we have all the URLs ready for us.

Let me close this.

And for now just to test. So let me

close just all of these. Go to the chat

service. And for now just to test let's

run this chat service. So ppm ban dev

chat service is learning on port 402.

Great.

And the next thing we should do is

probably go ahead and set up our

database connections right for ladies

and as well for the MongoDB. Okay. So

already have the packages we need.

inside the chat service chat service s

I'm going to create a new folder this

time I'm going to make it clients so

this is where I'm going to initialize to

create all my connection for MongoDB

let's start with MongoDB so dot

client client

ts

 ts and I'm going to start by

importing importing the MongoDB client

so from MongoDB

from MongoDB and I'm going to get the



Cryant, right?

 CR just a Cryant.

Okay, that is there.

And now let's also import our env as

well as our logo.

So I'm just going to import them here

and let's initialize. So let client

equals to client it's going to be

null by default it's null and we can do

export con

to uh get

 client right create client

it's going to be async

inside of this is going to return a

promise

of client

And here we can check. So if

if grant

can go ahead and return

and inside of this one can say a con

can get the MongoDB URL. So url

 url is going to be equals to m dot

 url

and here client is going to be equals to

new

 client pass in the url we

just added on top

and here I can say await client

dot connect

And then we can say logger

logo.info

logo.info and we can pass in the message

that verify we want to start like I say

 connection established

successfully

and then on the bottom here we can just

return the client MongoDB client. Okay

so this is for getting the MongoDB

client now resource close it. to export

cono

client

uh which is just going to be like this.

Yep. So we have this and we can go ahead

and use it inside of our index ts. So on

top here

I want to connect to my databases first.

So await promise

r

pass in

the get client

call it

for now. This is all we have

and let's try to start this up. Let's

see

um what is it saying? Authentication

failed.

Authentication failed. Okay.

Uh, did you do something wrong?

Let me check my env

MongoDB.

What did the URL say?

Um,

let me check this out.

[Music]

Okay.

Um

uh maybe we need to add

this.

Okay, I'm trying to see why

connection string.

Yeah, this is is this the format?

Uh let's choose this.

Um don't remember about this.

Okay,

we have the database user, the password

and the host.

Maybe also need to add

this.

Okay, let's try it.

Um,

so you do do okay.

They're saying uh this is type so here

definition you don't know to install

okay similar so we don't have to install

the types for the socket io so we can

remove those

so let's uninstall this

ppm

uninstall

but why is it failing

the gateway it's is it's fading.

Um

okay.

Yes. MongoDB maybe.

Okay. It works. It's just MongoDB. But

also at the end, make sure to add

offsource sost to admin.

Yeah, that was the issue.

Great.

Uh let me close this.

So we are connecting to our MongoDB

client. Now also let's do the same thing

for this.

So inside the client folder

I'm going to close this create a new

file

call it radius

client.ts

and instead of this one I can import the

radius. So import

um maybe just radius from IO IO radius

and also need to import our two

NV and de log as well.

So import this

can say that radius

going to be cost to radius

or it can be null as well.

So the idea is going to be similar. I'm

going to say export

cost get.

We're going to get the client. So get

rid this client

it's going to be go to return type of

radius

and over here I'll say say if

if there's no radius

I'm going to return

this um I'm going to return

Instead of this I can say rad this going

to be equals to new

read this right

and here I can pass in the empv dot read

this URL

and this URL so we create a new one and

here is connect is going to be close to

true

yeah so only this

initial connection to the server is

immediate to establish. So this true we

generate the connection.

Okay.

And after this one so outside of this

um we can say

uh we can say checks already do on get

some for some errors and some events. So

the error event

getting the error

uh this can return

uh rug

error

going to be cost error. the error

message

and the message can just be uh

read this connection error and also

return this error and also it's recent

to a few more methods. So radius dot

like for the connect one you can say the

connection for radius is connected and

for the cross one. So this cross

um yeah

great or we can just say close.

Let's make it one.

Okay.

And uh finally here we can create the

method. So export cost

and we can say can call it connect

this I'm going to be a sync

and then

you can say con client

equals to get this client. Okay

and here we can say if client dot

status. So we're going to check the

status it goes to ready. So this test

series is ready. Um

we can also check we can also check if

the status

is like

uh connecting right. So we can check if

grant dot status is equals to connecting

connecting.

We can do inside of this we can return

and

and after you can say await

dot

connect.

Perfect. And finally you can create a

small method to cross export cost

cross

radius going to be a sync

and here we can say if um

there's no radius

we return we don't need to do anything

if we don't have radius other we can

just say a wait

do quit and we can set the radius to be

null.

All right. So that's all we need for

radius and the MongoDB. So let me go to

index.

And after the get client, we can

also say um

connect

conne trade this core this

and uh yeah

so these are all we need

and for cruising we get the cross radius

and also we can get the cross

client as well

perfect Um,

so we have this. Let's start this and

safety lands

this connection established. MongoDB

connection established. Perfect.

Perfect. So we have both connections

ready and they all working

and um

yeah.

Okay,

this works as expected. So,

let me see what will be our uh next step

before we go ahead and create some more

stuff.

All right, so now let's go ahead. We

already have set up a consu uh a

publisher. So whenever we uh like

whenever we register user the

registration authentication service will

publish to user service and also the

user service will publish to the uh chat

service. So we can have the user in the

chat service as well. So let's go start

working on that actually start listening

to that uh event. Uh but let's create

our repositories first inside of our

chat service src. I'm going to create a

new folder and I'm going to create this

repositories. So this is where all our

repositories will be add. So

repositories

and inside of this one they're going to

start with the user dot repository. We

are not going to have so much cuz we

already have our user dedicated server.

So user repository.ts

and inside of this one uh we're going to

just uh import the type we created. So

input type going to be uh from our

internal package

right and it's going to be the user

created

not event but payload

and so to import

uh type

and this is going to come from

it's going to come from the MongoDB

And this is going to be the

correction.

Okay. So here we can also put our

client. So input get

 client. So we can use it and we

can create the correction name. So con

correction

um give it a name. It's going to be

useless.

And now let's get the con get

correction.

It's going to be goes to async

promise

and it's going to have in the correction

and also um

let's create an interface that going to

need to interface

Um

let's fix this issue first. Let me just

make it like this and just create

interface interface

create user document.

User document and inside of this one I'm

going to have in theore

ID. The MongoDB always has this which is

a string.

Uh what's the issue here? Uh

let me just do this so we don't have

those error. So to have this we're going

to have the email which is a string as

well

and uh let me just close this. So let me

also have the this spring name

which is string.

And we also have created add

she's a string and

deleted add she's a string.

Okay. So inside the correction also we

need to have this user document

and uh inside of this one we can get so

con client is going to be equals to

await

get MongoDB client

and then we can use the client so DB

equals to correction and you pass in the

user document then the correction name

great

And here we're going to create the me

the only method two like one or two

methods we're going to need. So export

con user we're going to create user

repository.

User repository it's going to go here

and let's add the method we need. So the

first one is async going to call it

upset

upset user

taking the payload

taking the payload and I'm going to

select this user created payload and

inside of this one I'm going to have so

con

correction

equals to await

get correction and here I can just say

await

correction dot update

uh one and inside of this one going to

have where the id id equals to payload

dot id

okay and here can just say can set so

use the set

in the inside of the set we're going to

say underscore id

go to payload payload

dot id

also the email goes to payload email and

for the same thing for the next ones.

So uh this one updated that it's not

assignable to type string.

Uh what did we pass in as

we do have updated that let me add it

updated that as well.

Okay so we have the payload as well for

updated that and outside of this let's

set upset to be equals to true. Okay. So

this will just when true creates a new

document if there's no document in this

one. So if you don't have this, it will

create it. But if it has it, it will

update it. So that's how this works. And

outside of this one, let's also create a

new one. So async

find user

by ID. And we're going to pass in the ID

string

and use promise of user document.

And this one can also be null. Perfect.

And this is all we need.

Okay. So this is the method we actually

need for us to get started. So now we

can go ahead and start listening to

these um connections. So

instead of this one, I'm going to create

a new folder. Again, call it messaging.

This is for a bit MQ. And I'm going to

call it uh Rabbit MQsumer.ts.

And uh after this one uh let me see what

I have inside of our user service CC

messaging

the consumer.

We're going to use most of this stuff.

So yeah,

I can take

this

these three. Go to rabbit M consumer.

Let's use this. And also we can u

maybe import the types that I'm going to

need

on top here.

Let me close this.

And um for this one for connection, let

me just create connection. And it's just

going to be channel model.

channel model on nal cost to channel

um yeah

consumer tag and this going to be the

chat service

and then this is going to be user

events.

All right. Uh let's also get the these

keys

but we're going to change them to match

what we need.

So instead of it being it's going to be

user

uh create routing key

user events exchange and also user

created event.

Okay. And um let's see what else we

have.

We have for closing the connection. So

let's have this close connection.

And this one I'm going to call it um

event

of

Q.

Okay.

And here I can just say paste this cross

connection

pass in the channel model and just do

that. Let me just close the connection.

Close connection or we can call it

crossmp

key

mp key connection. Yeah, that works as

well.

And also let's add a little method to

create. So you can call it con and I can

call it handle

handle user

created

and the user created going to be a sync

get the event of user created event

and here I'm going to get the await

uh user

repository dot upset set user pass in

the event dot payload.

Okay.

And after this I can start the consumer.

So let me start the consumer. We need to

import the env. So import the env

from our config

port the logo

from our

logo as well.

So this is the third time repeating

this. So I'm going to go a little bit

faster

and also we're going to create the

connection.

So outside of this start consumer

or no stay inside of the start consumer

sorry I'm going to add these methods. So

this is just for connecting. We already

seen this so much times. So creating the

connection the channel as well. And now

we're going to attach this to the as. So

we're going to exchange this. We're

going to use user events exchange pass

in this as well. So just like we did

before.

And now we can go ahead and also create

the consumer handler. So after this

pass in this consumer handler.

Okay. And I can go ahead and log some

messages if I want. And uh make sure to

so consume use consume over here.

And the last method is for us to stop

the

consumers.

Yep. So we did this a lot of times.

That's why I don't want to repeat myself

again and again. And um now we can go

inside of index.ts

and we can actually do um

start

consumers.

All right.

Now we need to test this out. So we need

to make sure that our services are

connecting are communicating as

intended. And for MongoDB, I'm going to

be using MongoDB compass to start to

connect to my MongoDB database. You can

also still use the table press to

connect to your database, but uh MongoDB

compass is not bad at all. Uh you can

just go ahead and download it if you

want.

So

yeah, let me just MongoDB MongoDB dogs

uh we can search for the products I

think and it's on compass compass. Yeah,

you can go ahead and

download it for your operating system

uh whatever you are using. Um, yeah. So,

go ahead and download this.

But for me, I already have it. So, I can

just go ahead and add new connection.

Let me copy the connection that we have

in our editor. So, inside of our envy

connection right here.

So, URL, paste the whole thing. We can

give it a name. It's going to be uh chat

app and I'm going to call it

uh chat

chat service.

Um

yeah, whatever.

Save and connect.

Okay, so we don't have any database yet.

And now let's go ahead and start our

services.

Let's start everything. So npm and dev.

We are starting up the services.

So we have both of them running

three of them such as service of service

get service and uh user service and we

don't have any error. So user service on


get service 4000 is of service 403 and

chat service 402.

Okay. And now let's create a request.

Let's register new user.

And this time we're going to create a

random user. Um

okay. So now let's send a request.

User created. Let me check the user

service. Chat service.

Okay. So we should have users in both of

as well inside of MongoDB. So let's

refresh this.

Yep, you have the database, you have the

users and the user is here.

Great. And the ID is the custom one that

we set which is your ID and the name.

You can see that we have the correct

name that we got from our authentication

service. So all our services

are communicating as we expect them to

and um yep

that is great that is perfect that is

what we actually needed.

So yeah yep let's go ahead and keep

working on this. So this is working this

is fine. So we can go ahead and uh

keep working on this. Yeah, I still have

time. Uh what else can we do?

Let me close this.

I'm thinking is what else can we

actually do for this? Okay. Um so let's

go ahead and uh before I start working

on the conversation

um repository, let me create inside the

chat service. I'm going to create the

types I'm going to need. So, inside the

types folder, I'm going to create a new

file. I'm going to call it composition.

TS. It's not going to be very

complicated,

but uh sorry, do uh export interface

interface and it's going to have

conversation.

Let's have conversation

and inside this one I'm going to have in

the ID of string

title

string

and this also can be a null.

I'm going to have participant id. So let

me just get this name participant.

I'm going to get use the ids actually.

So which is a string of array.

So participant ids going to have created

that type of date. I'm going to have

last

message

at right last message at which is a date

and it can also be null. I'm going to

have last

message

preview.

Okay, which is going to be a string or

it can also be null. Okay, so that's the

first one. So export interface

this going to be create uh conversation

and it's going to be conversation input.

So what do we expect? We expect the

title which is uh optional and this can

be a string or null. We expect the part

participant

id or ids and this can also be null by

the way. Um yeah

and also let's do another one. So export

interface this going to be conversation

conversation uh filter

we're going to use all of these so I'm

going to have participant ids title we

don't need the title just the

participant ids

and this is not optional

and I'm going to have export

type it's going to be equals to

conversation summary. That's I'm going

to conversation

summary. It's going to equals to

conversation.

Great.

So that's the first thing we have.

And um what else can we add?

Um

let me check.

Yeah. Okay. So, let's go ahead and

create the repository actually for the

conversation.

Um, yeah, let's create the repository.

So, inside the repository, I'm going to

create a new file. I'm going to call it

conversation

uh repository. So, repository

ts.

And inside of this one, I'm going to

import what I need. So we need object ID

and random ID from node crypto. I'm

going to import the types we just

created.

Okay. So these are the types that we

just created. Right now I'm going to

import um another types from MongoDB.

So with ID and also the document and

also I'm going to import the get client

that we already have created.

Okay.

And I'm going to have two collection

names of this. So I'm going to have

conversation collection and also

conversation

the conversation collections I'm going

to put it inside the conversations and

message collections. I'm going to put

them inside the message. Okay. And now I

can do so con I'm going to have to

conversation. So just like we did for

the domain user to conversation. This is

how we need it look like looking looking

like to conversation I'm going to have

in a document which is going to be with

ID

document

okay and this one is going to return

type of conversation

and inside of this I'm going to have the

ID

okay so I'm going to have the ID but I'm

going to make hit a string which is doc

uh doc

id

over here and I'm going to have in the

title.

So the title I'm going to check if is

type type of doc

but um

doesn't have title. Uh but let's let's

add this title course equals to

string

and

here we can say doc

[Music]

title again

going to set this to null.

Okay.

Um let's have the participant ids which

is going to be an array and we're going

to check is array and then inside this

one I'm going to add doc dot

participants participant ids. So let's

take this participant ids otherwise

string is going to be so same thing now

just the doc

okay do participant ids and they're

going to be as a string of an array by

default is array and also we're going to

have created that

um created that is just going to be

new date.

Same thing for updated that. So going to

be new date

move this. So create that equals new

date create that and they can be as

string

or so they can be type of

number or they can be

um this one can actually also be number.

So, let me add number as well.

All right.

And for the last message, uh, this one's

just going to be dog

of doc not type of, but remove type of

doc.ast message. It's going to be code

last message at new date last message.

Same thing. And I'm going to add them as

this one.

So as string or

as number.

Okay. So this is what we have. And this

one's going to have type of for last

message preview type type of it's going

to be doc last message preview equals to

string or do last message preview equals

to null.

All right. So this is it. And we can

also have to conversation. So con

to conversation

summary which is going to be a simple

one. So doc dot with id pass in the

document.

And here we can just pass in the

conversation summary

conversation summary.

And this one is going to be to

conversation pass in the doc.

And here I can just say export con.

So

conversation repository right

repository.

And inside of this one, I'm going to

have in sync

create. I'm going to create this pass in

the input. And you can say create

uh conversation

input. And instead of this one, it's

going to return a promise of

conversation.

10.

Let's go ahead and

uh con

client is going to be equals to await

get client

and here I can just say con db it's

going to be cost client do db

right and I'm going to say

con cor collection equals to dbc

correction get the conversations

collection. Now you can say cost now. So

get the date of today which is going to

be cost to

new date.

And uh finally here we can go ahead and

say

con document. So let's get the document

going to be equals to um

id which is going to be random id

the title

which is going to be input

dot

title or or can be also an r

and participant id. So participant

um participant ids

yeah

participant ids input participant ID

created that now let's message null and

finally here we can just say

um let me do this instead. So let me say

await

correction dot insert one

set one goes to document as

as sorry as as unknown or as the

document.

Great. And here we can just return

the to conversation with this document

and let's cast it the same thing.

So to conversation as unknown and with

ID actually so with ID and the document.

Okay. Um

let's add

one more method or

yeah for summaries let's also add that

one

just to finish up a little bit

and let me add this one. So this one's

going to be find by ID and this ones can

just nothing complicated

and it's going to still be inside the

user repository.

So this is for finding by the user ID or

finding the conversation by ID and also

let's add another one for finding the

summaries.

So find summaries

and it's saying participant ID is not

defined.

Uh this conversation filter did you mean

participant ID?

Participant ids. Um

okay

available on the type

conversation fe. They do not

add participant

ID on the conversation filter.

This is just supposed to be the

conversation ID actually.

Yeah, convers participant ID and this is

not supposed to be an array, just a

string.

Yeah, that was my mistake.

Okay. So, yeah, let me add more methods

that I'm going to need. Uh, so after

this one to conversation, we can also

add two more which are going to be

super easy as well. So, I added this to

conversation conversation ID

or touch conversation I mean and also

for removing all this if needed. Okay.

Yeah.

All right. So, this is all for our uh

conversation repository. And now, let's

go ahead and uh continue. Okay. So,

let's go ahead and uh keep working on

our chat service. And the next thing I'm

going to do, I'm going to create um for

caching. So for our caching, we're going

to cache our conversation. So I can say

conversation

dot cache.ts.

Okay. And I'm just going to show you how

you can implement caching. So we're

going to import the type that we already

created of the conversation and also the

get client that we already have. So we

already have this and now we can go

ahead and also define our caching prefix

and also our TTR seconds. So this is our

caching prefix is going to be

conversation.

And now I can go ahead and do so I can

say con serialize. So I'm going to

serialize this. So CD here lies going to

take in the conversation. So

conversation

take in the conversation and it's going

to be of type conversation

type of conversation. It's going to

return a string

and inside of this one I'm just going to

say uh return and it's going to be JSON

uh sorry capital JSON. So JSON string

file pass in the conversation but not

like this. I want it to have some more

options. So I'm going to split this

conversation and also I'm going to add

created

at

created that which is going to be

conversation dot created that and pass

into iOS string

and same thing for the updated that.

Okay, so that is all I need for this.

And here I can also create another one

for the serialize this one. So I can

just say con and I can call it the

serializ. So the slis

the serialize and I can take in the low

data. So we're taking the low data which

is type of string and this is going to

turn type of conversation.

And after this one I can just say uh con

past it's going to be equals to JSON dot

JSON.pass pass in the row data and I can

pass it as conversation

and here also um

uh let's also make it let's also add the

created that and updated that as well.

So created that and updated that. Great.

And after this one I can just return. So

return and we can spread the past and

also add the create that and updated

that as new dates

and updated that.

Okay.

So great. And now let's create the

method we need. So for conversation

cache, we're going to do export

con conversation

uh cache is going to be to this. So I

can just say async create get sync get

this is for getting the caches. So

conversation we're going to pass in the

conversation id which is going to be

type of string and uh this is going to

return a promise a promise of

conversation and it can be also null and

inside of this one I'm going to get the

ladies against ladies equals to get uh

ladies client all right and after this

we can con payload

cost payload is going to cost to wait

radius dot get.

Yeah, we're going to get based on that

um cache. So inside of this one, I can

just say cache prefix

pass in a cache prefix and then also

attach the uh conversation

ID.

So we're going to get this related cache

for this conversation. And here I can

just return

payload.

We're going going to use the method we

created pass in the payload or it can be

null.

Okay. So this is for getting and also

let's create another one for set.

So for set I'm just going to inside of

the conversation cache. I'm going to

async. I'm going to call it set and this

one is going to take in the whole

conversation. So conversation type of

conversation

and uh we have the promise and this is

going to return void

and inside of this one I'm just going to

say con radius it's going to get radius

client

and here I can just say await radius

uh dot set let's use set x and inside

this one we're going to pass in the

cache prefix with conversation do ID

cache d the seconds and also serialize

the conversation and finally we can just

add the treat one which is just going to

take in the conversation ID

so this is all we need for caching so

we're going to be caching all of this

and now we can go ahead and start

working on our services okay so let me

go outside of this and inside of my chat

service. I'm going to create a new

folder. I'm going to call it services

inside. Make sure it's inside SLSC.

And I'm going to create a new file. It's

going to be conversation

conversation uh service.ts

conversation.ts.

And we're going to import the HTTP

error. So import uh this is going to

come

this is going to come from the http the

our inside the package we created. So

this is going to just be the http error

and after this one I'm going to import

all the types that we have created for

conversation. So we already have this

ready and also let's import the

conversation repository and as well the

cache we just created right now.

Okay, so we just created all of these

and now I can go ahead and start working

on the method we need. So export

cons and this is going to be

conversation

uh service

conversation service and inside of this

one I'm going to say async and uh create

conversation.

So async create conversation. We're

going to create a conversation. going to

take in the input which is going to be

create conversation input returns the

type of conversation promise of

conversation and inside of this one I'm

going to just pass in the conversation

so conversation

and I can say await uh conversation

repository conversation repository dot

create and we can pass in the input

okay and after that we can say await

conversation cache so we're going to

cach is go do set and here we pass in

the conversation.

Great. And finally we can just return

the conversation.

Yeah. So this is how we're going to be

creating the conversation. And same

thing for the create. So for uh get

sorry for get conversation by ID we pass

in the ID it returns the conversation.

So we check um con conversation. We

check the conversation that is cached.

So if there's no conversation that is

cached

um

actually instead of doing it this way.

Yeah. Let me remove this. I'm going to

say con

cached. It's going to cost to await

conversation conversation uh cache dot

get pass in the id but and also we're

going to say if so if cached so if of

the cached conversation we're going to

return uh this cached

yeah

but

outside of this I'm going to say

response

conversation. So we're going to get

conversation await uh conversation

repository dot find by ID pass in the ID

and if there is no conversation so if

you don't have the conversation we can

flow a new uh HTTP error and pass in the

port of 404. So it's not found and the

message can just be a conversation not

found. Great. And outside of this if

there's no conversation we can uh just

say await conversation cache set reset

the conversation we return this

conversation.

So this are going to do it.

Okay.

So we check first the cached version and

if there's no cached version then we use

our uh database. So now let's also get

uh a sync. It's going to be list

conversation.

So we're going to list all the

conversations that we have. Pass in the

filter

and the filter conversation filter. Let

me remove this conversation. FTA

return the array of conversation

summary. And inside of this I'm just

going to return

uh conversation

repostory dot find summaries pass in the

filter

that's all we need and uh also here we

can say a sync

uh we can call this touch

conversation

and here I can pass it the conversation

uh ID Okay, which is a string and also

we can get the preview

which is a string and this is going to

return a promise of void

and here I'm just going to await

conversation uh repository

dot touch conversation and pass in the

conversation ID and also the preview.

Okay. And after this we can invalidate

the cache. Uh so I wait. So we can

invalidate the cache so that the next

read will include the new uh preview. So

conversation cache dot create and pass

in the conversation ID.

So that's pretty much it for creating

our conversations right here. And we can

go ahead and create the controller.

So inside the our SIC chat service,

let's create a new folder. Going to call

it controllers.

Create a new uh file conversation.

TS. So we have the conversation

controller and we can go ahead and

import.

This is going to be coming from chatab

common async

http error and also the type of uh async

async.

Okay. So we have this and uh we need to

also get the type from express. So let

me import it from express. We need to

get the conversation service that we

just created. So let's add that. And uh

we also need to validate this

conversation when creating it. So we

need to add some type of validation uh

schema which is going to be very simple.

So inside of SCC let's create a new

folder call it validation.

And inside of this validation, I can

just say uh conversation

dot uh schema.ts.

And I can just paste this in. And this

time it's going to come from our chat

app common. And so this is all we need.

So the title, the participant ID is uh

participant ID. Basically that this all

we need for this to work. So now we can

go ahead and import this schema that we

just created inside our controllers.

Let's just add it

and um

yep

also uh let me see if we need to create

something else. Um

let me create one more shared. So I'm

going to call this shared schema.ts.

And here I'm just going to have in the

ID. So, and I can import the Zord

from

uh chat app common. And this is the ID

we're going to be using all over again.

So, yeah, just have it. And we can go

ahead and uh import it as well. So, over

here, just import this

Um yeah, let me import it directory.

Okay.

Uh let's get start let's get started. So

let's create con

past and we're going to call this past

conversation. So first conversation

and this is going to take in the params

of type unknown

and this is going to be get the ID uh

inside of this one. So let's do con and

we're going to come from the

conversation um

conversation id param schema dot pass in

the params. Okay.

And here I'm just going to get it the

ID. And here I can just return the ID.

Okay. Now let's create the first method

for creating. So we can call this um can

say con

create

conversation

which is going to take the type of async

and

um uh should we make it request?

Let me see this. No, let me just make it

like this and say async

then instead of this one I can say

request or

let's use it directory here async handra

pass in the async

and here we can just get the uh request

respon request sorry request

response

and inside of this one we can just get

the user So con user going to request to

get authenticated user taking the

request

and over here I can say con

payload

to be equals to uh create conversation

schema dot pass inside here we can pass

in the request dot body

and after this we say con

uh we can get a unique unique um

participant id

just participant ids okay going to be an

array so let's call it array dot from

here I can say new set and inside of

this one I can get this as split this

payload okay and after this I can get

the part participant

ids and then the user id as well.

Okay. So user id and here I can check.

So if unique participant ids dot

length

two uh here I can just throw new http

though so it must include uh at least

one

participant ID. So it's going to be 400

and I can just say uh conversation

atrist

atrist include

um one other

participant right so we need particip we

need two participant to be able to

create a conversation

because we don't we don't we don't want

to start conversation with ourel right

so con

conversation is going to be to await

conversation service. Let's get the

conversation service dot create

conversation. Inside this one, I'm going

to pass in the title which is going to

be equals to pillow.title participant

ids. It's got to unique participant ids.

And then here I can just do this dot

status and pass in the 2011 then the

JSON. So going to go to P get the data

and we're going to create conversation

just like that.

And uh what's the issue here?

Uh

well let's export this. So export cost.

Uh let me remove this async hand. See

yeah request hand actually not async

handra. Yeah request hand. So usually

request hand type for this

and um

which one is next? Which one is for

listing the uh conversations?

So let's list the conversation that we

also have.

So I can copy this the first one

over here and I'm going to call it this

uh call this list

conversation

uh list conversation

and also let me call this

create conversation handra

and also this I'm going to call this

conversation.

Yeah, I like it better. So this

conversation 100 and here let the

minimum all of this I can leave the

response I'm going to change it later

but I can get the user. So con user

equals to get authenticated user and con

the filter is going to list conversation

list schema.

I'm going to pass this

taking the request query

and here we can uh check. So if the

filter

dot participant id

and end the filter dot participant id

uh

we can just if it not with this ID we

can throw new error that can say like

cannot list a conversation for another

user. So we're just protecting this or

we can just say unauthorized that is

that also works uh or free as the type

and here we can just say conversation

equals to conversation service and uh

this conversation and we need to pass in

the participant id which is equals to

user do ID. So we're just making sure

that these conversations actually

belong.

They have access to it.

Okay.

So this is for listing the conversation.

And now let's also create a new one for

getting the conversation. So let me copy

this.

I'm going to paste this here. And I'm

going to say uh get conversation

and get conversation and equals to this.

And I can remove this for now. Left the

response.

And um I can start by saying

um getting the user should have left

that uh equals to get authenticated user

pass in the request.

Yeah, I should just have left that.

Okay, that is fine. Let's get the

conversation ID. Conversation

ID.

Go to course to past conversation

request.pams alarms and here you can get

the conversation. con

conversation it's going to go await

conversation service

and we can say get conversation by ID

pass in the conversation ID

and here we can just

um

return yeah but let's check also if

there's the conversation is there so if

there's no conversation

um

dot participant. Let's check this. So if

there's no conversation participant ids

dot includes

the user

dot id. So if the conversation we're

trying to get doesn't include belong to

us, we're just going to throw that is

unauthorized. We don't have access to

that. Uh otherwise we can just return

this conversation.

Okay. Um, yep. And for now, this is all

we need for us to create the

conversation. So,

yep. And I think now we can also go

ahead and create the louds.

Uh so inside src I can create a new

loads folder

and get the conversation

uh louds.ts

conversation.loads.ts

TS and we're going to get the express LA

and um here we're just going to create

the LA that we used to do as we did

before. So let me just export cons

conversation L is going to be equals to

this and here

um I'm going to attach authenticated

user to all these louds. So instead of

adding it to single one, let me go

inside the middle here, I'm going to

create a new file. I'm going to call it

uh authenticated

uh user.ts

and I'm going to add a method to

validate this uh user. So it's going to

be very simple. This is the method

and we can get this. So import

uh and say from

chatab common and here I'm going to get

the http error the user ID header

and also the request handler from

express. So that is everything we need

and um al as well. Uh let's say import

sword

and this is going to be a type.

Oh yep. Great. So this is good.

We have this as we needed. And now we

can go back to our conversation route

and we can attach this conversation

router to all of this. So we can just

say conversation louder dot use and we

can pass in the attach authenticated

user.

So this will check. So now let's

conversation loud dot post. The first

one is going to be at this one. So let's

validate the request. So validate

request. Here we're going to pass in the

body

and we're going to pass in the create

conversation schema. Create conversation

schema.

Great. And outside of this vate request,

we're going to pass in the create

conversation from our controller.

Create uh conversation handra. Yeah.

Great.

So create the conversation handra and

the second one is going to be

um yeah let me just accept this for now.

So we have the get for getting

uh the listing the conversations. So

this conversation let's import this

conversation schema. So this is

conversation credit schema and let's get

this conversation handler as well.

which is going just going to go to get

and another one is going to get the id.

So conversation schema id conversation

param and get conversation handler

which is get and uh another one for

okay this is quite not what I want.

Um so the this ID one is fine. Let me

leave us some space. So these two are

correct.

And another one for um

update conversation. We don't have this.

I don't think we have the update

conversation. We only have three

methods. Let me check. So we have create

conversation, list conversation, and get

conversation. Yeah, we do not have this

more.

So we just have create conversation

conversation and create conversation

for now. Okay. And I think that's all we

need for this one. So let's also create

uh the middle here inside the loads. I'm

going to create index.ts.

And here I'm going to get our

conversation and also the louder.

All right, great. And uh we can just

create the uh app that as we used to do

before. So export cons register.

So register louds going to go to app and

you can say router

and here we can just

get so app dot use. So we're going to be

on

conversations

conversations and we can pass in the

conversation router.

Great. So now let's go ahead and use it

inside of our um app.ts. So app.ts

I'm going to have this after um after

this one and also we need to add in we

need to protect this actually. So let me

add this of middle. Yeah.

And the simple the MV we already have

this.

Yep. So we need to create the middle of

middle. Yeah. And let's also register

the loads as needed.

Perfect.

So that is done and um yeah that is

pretty much it for the conversations. Uh

we just need to add it inside of our uh

gateway service so we can be able uh to

uh authenticate or test this out. Yeah.

Actually, let's go ahead and do that.

So, I'm going to add it inside of the

gateway um services and loads and

controllers, etc., etc.

All right. Uh so, I'm going to go close

everything here

and I'm going to go inside of gateway

service s.

Uh let's start by creating

the service. So inside the service I'm

going to create a new file. It's going

to be the chat block cy dot service.ts

and uh the first things are going to be

pretty similar. So let me go for example

inside of service

uh the create client. These ones are

going to be the same. So let's take

everything here. Let's paste this here.

But uh this time we're going to be

getting the chat service right

chat service URL. That means we need to

add the chat service URL inside of our

config m and after the uh of URL we can

add it here as also a string and URL

but make sure to also add it inside of

our env file.

So after this one, after the

this one, let's add it as local host and

it's running on port 3,00 4,000 and two.

Okay, great.

So we have the services here ready. Now

let's go back to the chat proxy and uh

we can keep working on this. So, let me

close this. And uh we have the Axio

client. Um

yeah, of header.

Maybe I can do something different for

this one. Just

why not? Uh instead of doing it this

way, let me call it like this, let me

put this. So

let's create conf create client and I'm

going to create pass in this as here

instead of creating it as the of header

we're going to pass in directory like

this I think this will be much easier

but uh yeah you can go ahead and uh

modify it if you prefer this. So let's

also get in our uh error hander. So

let's get this side here.

Uh let me copy this error handing

paste it here.

Yeah. So this is fine.

And now we can go ahead and create our

conversation interfaces. So to say

export interface and it's going to be

conversation

uh DTO

and this one is just going to take in

the ID type of string. It's going to

take in the title

type of string and uh this can also be

to null. So we can also set it to null

if you want or maybe for now it's fine.

And it's it's getting

uh let me just add in all the types that

I need. So it's much easier that way

without wast

creating uh these types of our

conversations.

Um

yeah. So I'm going to add all the types

I need the even the ones for the

messages.

So we don't have to worry about those

anymore. So let me remove this

and these are the types. So we have

this. Let me go on top or the

conversation DTO we have in the ID the

title participant ids created that rest

message R message preview and reaction

DTO emoji user ID created that interface

message DTO

export interface

conversation response message response.

Yeah. So there's no need to uh spend

much time creating that when

can just do this. So let's do export con

and I'm going to say um uh chat

proxy

service. Chat proxy service is going to

be equals to a sync

create

conversation. This is the first one we

need for creating conversation. And I'm

going to pass in the user ID which is

equals to string.

We need also the payload

which is type of create conversation

payload.

And this is going to return a promise

of

conversation

DTO.

Okay. And it's this one I can do a try

catch and I can get the response. So

const

const response equals to await

client dot post and I can just pass in

the conversation

response conversation response and it's

going to be equals to um

uh let's put it on the conversations. So

we have this conversations

conversations then you pass in the

payload.

Okay. And here let's also pass in uh the

headers. So inside the headers we're

expecting to receive this user ID in the

header. So user id header from chat app

common is going to be equals to the user

id.

Okay. So expecting this header when we

send the request and here we can just

return response to data dot data then

return rand xios error.

Perfect. And now let's copy this down.

And this another uh just inside of this

one. And another one is for listing

conversation. So I can call it list

conversation.

And this one is only going not going to

take it's just the user ID since we need

the user ID. Um conversation detail and

it's going to be an array and cost

response conversation list response as

well. and just on conversation pass in

the ID and uh yeah that is pretty much

it. So let's copy this down

and another one is for getting

conversation.

So that's all we have for now. Get

conversation

and it's going to take in the

conversation ID type of string. Uh let

me put it here. So string

leave the user ID there and this one's

going to be response get conversation

conversations pass in the ID pass in the

header of the user and uh we're still

returning just this

perfect so this is all we have um

we can go inside of our controllers and

also create them.

Okay. So, inside of my controllers, I'm

going to add a new one which is going to

be conversation

conversation dot controller.ts

and uh

we need to add some schemas for creating

uh the conversation. So, we already have

this actually. So,

Instead of the validations, we're going

to add in the conversation

schema.ts

pass in this. So this is what we need.

Can import from chat app common. So we

already have created these types before.

There's no need to write everything

again.

And um

yeah, so let me go inside of my

uh way chat conversation controller

and I'm going to import while I need to

use. So I need to import the request

handra and also uh the the the schemas

we just created.

So let's import this

get authenticated user and also the

schemas we just created.

Okay.

So now let's do export

con and this is going to be for creating

the conversation. So create conversation

that's how you call it get conversation.

It's going to be case the request handra

and instead of uh this one I can use

also um the async actually. So let's use

async

going to be async

response uh we don't need the next.

So just like that

and inside of this one I'm going to get

the user. So con user go to get

authenticated user

pass in the request

and here I can do con payload it's going

to create conversation uh body schema

dot pass and pass in the request dot

body.

And here we can do the same thing we did

in our uh services.

Uh let me check inside of my chat

service. Chat service controllers

conversation controller. So we're

creating uh we we're checking this. So

we're going to do the similar thing

here. So let me get this. So it's pretty

much the same but yeah we just

doing the same thing inside of uh this

one

and that is what we have and uh we can

go ahead and outside of that. So

conversation

um we have this we can also get and

create the conversation.

So con

conversation right

let's create conversation it's going to

be cost to await chat service proxy

create conversation pass in the ID

um the payload I want to make sure it's

the one I want. So I'm passing the title

which is the payload title and

participant ID is called unique

participant ID. then we can respond with

this data conversation.

All right. And uh we're going to do uh

same thing for

uh listing the conversations.

Okay. So let me copy this down.

And here I'm just going to call this to

this conversation.

So this conversation handra and inside

of this one uh it's going to be pretty

easy. So all I have to do is

get this. So this conversation

uh conversations actually this should be

conversations. So this conversations

okay and uh next one is get forgetting

conversations. So let me copy this down.

And we're going to call this get

conversation.

Then the method is also pretty easy. So

yep, you get the idea.

Uh get authenticated user chat proxy and

um yep.

So that is all for now. we can go ahead

and add in inside of our louds.

So for the louds again, it's going to be

pretty much same thing. So let me close

the chat service actually so I I don't

get confused. Instead of loads, I'm

going to have the conversation

loud.

TS

and here

um I'm going to add the uh types that we

need for the conversation and also the

for requiring authentication.

So require off and also the one we need

here. And uh can go ahead and also

import the

type for

so import this and also import

the

validate request

from chat app common.

And now we can go ahead and create the

LA.

So create the router and also let's

protect all our apps

right here

and um

yeah

so the first one we need is for creating

the route for creating and also the

gate. So these are just the three one

that the main one we have. So I can just

add them here.

Get conversation

um

here. Andra actually get conversation

Andra.

This conversation

Andra

get conversation Andra.

All right. So that is all and we can go

back inside of our index file and we

need to add in this conversations

here. So after the users or maybe after

the off let's add it here.

Okay.

So that is all we have. Um

we can go ahead and

try to test this out and uh see if what

we have uh created

works.

Right.

So uh I'm going to create a Postman file

that we're going to use to test this out

since we don't have the front end yet

and that will be in part two of this

video. So

I'm going go ahead and create a postman

file. Then we can be able to test this.

All right. So let's go ahead and uh uh

test what you have created. So make sure

you have docker running and also just

make sure that your services are up and

running. So let's just do docker compose

app

uh can do app ht.

Okay. look like it's pulling

the images for some reasons. Um,

even though I already had those, but

that's fine.

Let's wait for this to finish.

Can open uh Docker comp docker file

desktop, sorry.

And uh it's going to start this

Let's just see.

Okay. So, it has started the name. My

services are up and running. Now, let's

learn our services. Pinpm then dev.

Okay. So, there's no errors here.

Great.

So they are all running.

Now let me go to the Postman. So I have

Postman with the documents I told you

that I'm going to create. So this is all

we're going to use to test this API. And

let me register with participant number

one. I'm using the API gateway as the

also I have the script. So whenever I uh

register this one, it will automatically

add our refresh token to refresh token

number one. It will add it inside of our

uh authorization. And also if we create

a new user, it's going to create a new

one with the collect refresh token. So

let me go and send this request. So

participant one, let me send the

request.

Okay. Uh I think the user with this may

already exist. Let me change it. Let me

add two.

Okay. So I have this user created

and uh I should also have them inside of

MongoDB I believe. So we have

participant. This participant is here.

Now let's also login as participant

number one.

Okay.

We logged in and let's register

participant number two. So let's change

this email to be three. So yeah, you get

the idea.

So we created this new user. We should

have two users now. So we have

participant number one and also

participant number two. Great. And now

let's log in as

participant

um number two.

So I logged in as this participant with

this number two

and let's create a conversation.

Inside the headers we have the

participant one access token

and uh let's create project with this uh

participant to id. So this is our

participant ID. So this is the

participant number two ID. So the

participant number two ID is going to

create a a new chat uh conversation with

participant number one in it. So let's

try to create this. So create

conversation

uh no okay participant number one let me

login as participant number one actually

so that we can create a conversation

with the participant number two ID.

Okay, that's the idea.

All right. So now I'm going to uh click

on

send.

Okay. So now I have two participant

inside of this. So I have participant

number one and also participant number

two. So participant number two,

participant number one created the

conversation. So let's refresh this

whole page.

Refresh. And now we have the

conversations. So we have the

conversation here with this participant

in them. Okay,

great. So now let's list conversations.

So we we still logged in as participant

number one access token and we can list

our data with this participant and our

conversation. Yeah. So uh let's also

check our ladies database. See if the

caching is actually working. So inside

the chat service NV file let's connect

to this ladies server database I mean

and let's see if it's working. So inside

of data press I'm going to add uh

connection new

uh I'm going to choose ladies create and

here I'm just going to uh close this

again uh

create connection sorry create

and here I'm going to give it a name of

chat

uh chat app and it's going to the

uh chat

service

radius

and um this can be the same

default default we can test. So connect

right we're connected. So seem like we

don't have any data for some reason. We

don't have any data at all. So let me

try to create the new conversation. So

let me create conversation.

Uh create a new one. Okay.

And

we should have Yep. Yep. So we have a

conversation we cached it and um now if

you try to list conversation

conversations

so let's claim we get two

and I'll get the cached one but we also

have another method to get conversation

by ID. So let's check our code again and

let's see where that is. So inside of

the gateway

ts

conversation louds we have the get by

ID. So we just need to pass in the ID as

the params.

So

uh let me add it here. Let me see.

Let's add conversation ID uh here. Let

me get

anything. Let me get the first one.

There's no Okay, so let's get

um Okay, we got an internal error. So,

let's see what's the issue.

Um

okay, I cannot see the message query but

inside the gateway service.

Uh what happened?

Um

yeah,

what's the issue? I cannot see the

message query. Okay, let me actually fix

this. So,

let me go just to the conversation

gateway. So, I'm just going to start the

services that I need. So, see the

services

see the um user service

npm and def.

Okay.

CD of uh CD services

and of service

ppm run

ppm rundev.

And here I can go also to CD services.

Then

the chat service

pm and dev.

Great. And here I can go to CD services

then the gateway service ppm and def.

Okay. And now let's try again. So get

this.

Cool. We got the them. And now let's try

to get the just with the ID.

So let's use the ID to get the

conversations. So conversations

then the ID. Right.

Okay. Okay, we got the error

and uh the issue is saying

inside the HTTP intensive error st um

can it be that we have

the ID are not converting as needed. Uh

so let me go back to the chat service.

Let's check our repositories. So

repositories

uh conversations

repository

uh let's see how our ids for find by id.

So find by ID we're saying

u

ID

to be equals

to new object ID.

Um

okay.

So maybe we don't actually need to pass

this as new object ID. It's just use the

ID.

But uh

same thing here.

Uh

yeah, let's just test this. I'm going to

see if this is the issue.

And uh can I start the gateway service?

Same thing for where's the chat service?

chat service.

Let me start it

and let's try to connect to get again

with the just ID.

Okay. So, it's the ID.

Yes. Yeah. Yeah. Makes sense because we

we are storing the UID as a string as

just this underscore ID. Um

yeah

so we already uh we as a string so we

don't have to convert it to to an object

ID. Okay, makes sense. So that is the

fix. But now we have this issue that we

need uh to also fix. Um so this one we

can cast try to cast it. Uh wait come on

I don't want this. can cast it as

unknown

and also we can cast it as object ID.

Yeah, this fixes it. So let's do the

same thing as unknown and also as object

ID. Great.

Okay, so now let's test it again.

Yeah, so this still works as expected.

Everything's good. So, we're getting the

response from the cached response.

That's why it's also a bit faster this

way.

Okay.

Yeah.

Okay. So, now it's all good. So, let me

go ahead and uh try to continue this and

we can so we can finish we can finish

this, right? Okay. Uh let's go ahead and

uh can start working on the message

creation and also listing the message.

But the first thing we have to do, we

have to create the schema. So inside the

chat service inside the validation, I'm

going to create a new one for message.

So message

dots schema.ts

message.s schema.ts.

And uh here I'm going to do export

cost and it's going to be for create

message um body schema.

So this is what we expect when we create

so import from object and here I'm going

to have in the body

and Z dot string

dot string

and here I'm going to say minimum

going to be one and the max can be 2,000

or whatever I want. Okay. So let me add

more as well. So this is uh the second

one. So create message

need the conversation and also list

message by query schema.

Okay. Um that is done. Uh now let's go

ahead and create the repository for our

message repositories.

So inside of my uh repositories I'm

going to create a new one. It's going to

be for message

dot repository.

So message dot repository

ts.

And inside of this one uh we're going to

input what we're going to to use. So

import the uh node crypto MongoDB get

 client and uh yeah let's also

create the types for the messages. So

I'm going to add those. So inside of my

types I'm going to add a new file that

is called messages with all the type of

messages that we're going to need for

now.

Okay.

All right.

So, I added this

and now we can go ahead and start

creating our message uh repository. So,

uh it's easier for us to get started.

Now I'm going to have the collection

which is going to be messages

and I'm going to have a domain I'm going

to call it to message.

Okay,

now for now let me remove this reaction.

Yeah, let's keep it that I'm not really

going to use it. U but yeah, so I'm

going a bit faster because we already

did this couple times. So, and I don't

feel like uh keeping typing all of this.

So, you can go ahead and

copy them from my repository as well.

So, let's close this.

Now, we have just few methods. So, we

have the create for creating a message

inside of a conversation ID. You pass in

the conversation ID, the sender ID and

the body. Okay.

And after that we find by conversations.

So we find the messages by conversations

and we add these options and find uh by

ID. Okay. So that is all. Now we can go

ahead and also create our message

service.

So this is going to be first as well.

services. I'm going to add

uh message dots service.ts.

So message service.ts.

Uh the first thing we have to do is

import our repositories and also our

types. Okay. So import our repository

and the types.

And after that going to create the so

let me just do export

con and we're going to call it message

service and this is going to be equals

to a sync. The first one is going to be

for creating the message. So create

message and it's going to take in the

conversation ID and also the body

just like that. So conversation ID and

it's going to return type of uh message.

Okay.

And inside of this one, um, the sender

ID, the body, and inside of this one,

we're going to, uh, ensure that the

conversation exists before

creating it. So, let's get this HTTP

error.

So, we're going to ensure that it exists

before creating it. And we're going to

check if the conversation participant ID

is there. So, if the user is not there,

we press the error. And finally, we can

return uh this message.

And also let's create another one for

listing uh the conversations.

So we can do that by just say over here.

So list messages we're going to use this

as just for listing our messages.

And uh that is about all for now. And uh

we can go inside of our controller as

well. uh we're going to still use the

conversation. Uh there's no need to

create a new separate file for this one.

So let me go ahead and create a new one.

So we just have two methods. So for

creating and also for getting uh the

message. Okay. So we're just going to

have another one for creating message.

So I can say con

create

message uh

hundra and this is going to

take in the request hundra a sync hundra

and inside of this one I'm just going to

pass in what we need. So get

authenticated user

and past conversation but they already

created this

import this import this and uh

yep that is about all and also we should

actually export this export con create

message and run and we can copy paste

this one and we can say uh paste

message

and

it it's going to be a bit different. So,

let's just

paste this and

schema and

let me what do they call this

past conversation?

Yep. And uh finally I can go inside of

my louds and I can add this as well. Uh

so

inside the

louds conversation loud uh we can add

this for messages. So after the get

conversation

we can also add for the messages. So I'm

going to call this

um

let me copy paste the first one and this

one is going to be to the ID then

messages

and this going to be uh past message

handra. So this is just for getting our

messages

and also let's add another one for

uh post which is going to be equals to

also ID messages and this is going to be

for create message handler

create message handler and this one is

going to be for the uh um

Actually, we're going to have two. So,

we're going to have the params. So,

conversation

param ID and also we're going to have in

the body.

Okay. So, we're going to create

uh message for the schema.

Okay. So, this is what we have. Let me

put the post before the get

just like that. So editing the request

create a message handler and um

yeah so still inside of we are still

using the the method of conversations.

So I don't think we need to add inside

of the the now. We can just go ahead and

use it inside of our

uh use it inside of our gateway.

So let me close this

and I can go inside of the API gateway

s

the validation first create the type. So

I'm going to have the message

dot schema

ts

pass in the type and let's import the z

from the correct place. So

uh chat app

and this is what we need.

And also for the types there's no need

to use them here but we need to add the

services for our chart. So inside of my

uh services chat I need to add more

services that we're going to use for

example the create message and also for

getting listing the messages.

Okay. So let me add the first one. So

here this one is for create message pass

in the uh conversation ID etc. We

already have the types defined on top.

Okay. Conversations, conversation ID,

then the message. And another one is for

listing the uh

messages.

So over here we can list the messages

just like that. And let's go to the

conversation as well for the uh

controller

uh controller inside the conversation

controller. Uh we can copy and paste

this one.

So copy paste this one. And I'm going to

call this

create uh message

Android.

And this one is going to be also simple.

So let me just add it. There's no need

for me to keep adding this so we can get

to more interesting part.

Okay. So get message body schema

and uh let's copy and paste this list

image uh list message controller.

And here I can just also

uh add what we need

and uh just import this

and uh yeah now let's go ahead inside

the louds. So the conversation louds we

need to add in this layout that we just

added.

Um so we already have four messages

know for conversations. Now let's add

also for listing messages. So let me

copy paste this

and this time it's just going to be to

messages. So list message

ID messages

and the query is going to be

like this.

And uh another one is for post to add

the message.

Let me just add it like here before the

get

and here. So the post

and uh can have body or the params.

Okay.

Yeah. So this is about it. And let's

check what we added inside of our uh

chat service and inside of the um uh

routes. I want to see what I added. So

inside the

let me close this chat service

um loud conversation layout.

So we added for getting

the for the post message

we added just the

params and the body and for getting the

message we also need to add the query

actually. So let's also add the query uh

list message schema.

Okay. Um so that's basically it. So I

can go ahead and test this.

Uh my services are running. Let me just

start the chat service just in case.

Uh authentication service. There's no

need to we didn't touch it. Get toway

service. Let's restart it in case.

And uh let me pin pan dev.

Okay. So let me open postman

and uh we have this conversation.

So let's get it again. Yeah, we have

this conversation. Let's get the it ID.

Okay. And let's create a message.

So inside the headers we are logged in

as the uh user one participant number

one and inside the body we need to add

the conversation ID. So let's add the

conversation ID we just copied. That is

good. So I'm going to post this message

inside of this one. So hello from

participant number one. Let's create.

Okay we got some error. Let's see what

it is.

Uh and let's just close this. Let's see

what's the issue it is now.

So it's saying uh

create object uh object create message.

Uh I think it's the same issue we had

before.

Uh let me go back to

uh chat service s

repositories and the message repository.

So let's see when creating

um do are we using the MongoDB ID?

Yeah, we're we're trying to create this

as new MongoDB. Let me just use it as

random UID. Okay, let me see if this is

start test. Okay, is starting.

Let me uh test it again.

Yeah, so it was the ID. Um,

okay. This is

done.

This is the message we got. Hello from

participant number one.

Let me see the I uh the messages here.

Let me refresh this database.

Have the messages and we have

the sender ID, conversation ID and also

the body.

So let's log in as participant number

two.

We logged in as participant number two.

Let's try to post a message as

participant number two. Okay. body and

reply from participant number two.

Okay, so we have this. Let's refresh

this.

We have messages. And now let's go to

conversations. Let's refresh.

And you can see that for this one, we

have the last message preview for the

participant number two, which is the

latest message. And uh the

conversations, this is the conversation

we're using.

And the messages are here.

Okay. Uh so let's just fix these uh two

errors then uh uh I think we are good

with the

uh conversation service. Okay. Uh so you

can do the same thing we did. You can

test as unknown as uh document

as unknown

and as with ID.

Yep. So, we're done with this. We can go

ahead and close this up.

I think we're good with this services

for right now.

Um yeah, so let's go ahead and continue.

Okay. Um now comes the interesting part.

So we're going to be hosting these

services and we're going to selfhost. So

I'm going to show you how you can get

your own uh VPS, how you can set up uh

selfhosting um uh options and uh etc.

So, but first of all, we are going to

use Docker to host all of our services.

Uh, so that means we need to also

include our services inside of our

Docker compose. But before we can do any

of that, uh, we need to go to each of

our services and create a Docker file

with and define what we need. So, let's

go ahead and start with authentication

service. I'm going to create a new file

and this is going to be docker file.

So this docker file and inside of this

docker file in this we're going to be

defining what we need. So I can say u

syntax and I'm going to give it the uh

equals to docker file one and this I

think this is experimental future. Uh

don't I'm not sure though why my uh

I'm not sure why my code is giving me

this error

my editor I mean

so what is the issue here

okay I need to provide from okay so now

uh this is going to be from the base

image is going to be node and I'm going

to use 22 two and let's use the alpine

version.

Uh I think this is the lighter version

of this one. So this is just our base

build. So we're going to have uh some

multiple stages when building and inside

the base one we're going to be uh

installing uh installing our packages

first. So we're going to no I mean not

our package but install the what? PNPM

since we're using PNPM. So let's go

ahead and say learn and let's say core

packs uh core pack enable. I'm going to

enable it and then we can and end we can

just say core pack once I've enabled it

we can say prepare.

So we're going to prepare.

Okay, prepare

um PNPM

and we're going to get the version we

are using in this project which is

version 10.14.0

and here we can just say activate.

Okay, so run quapac enable and end

quapac prepare pnpm version 10. And here

we're going to have a working directory.

So our working directory is going to be

just on the app.

Okay. And uh let me just be here. So

this is the base one.

And uh here we're going to go and we can

install uh the dependencies. So this is

the stage to decide the dependencies. So

let's say from uh from we're going to

use the base

and here we can say as deps. Okay. As

deps. And inside of this one here, we're

just going to copy uh our workspace

configurations. Okay. So, copy workspace

config. And here we're just going to

first command is going to copy. And

we're going to copy the uh let me remove

this. We don't have this.

And I'm going to copy the package

to JSON. Right, I have the package.json,

the ppm uh workspaces

workspacey

and also the pnpm

um lock yammo inside of going to copy it

to our loot. So we have the copy the

package JSON pork spacey ppm log yaml.

Okay. And the second one we need to do

we also need to copy the test config.

So the test config base we have this

base JSON. We can going to copy also the

test config.json

over here.

So copying the test config base and also

test config to our root. And here we can

also go ahead and um um copy our

packages um the package JSON that we

have inside of our shared library. So

our common packages. So copy workspace

um

or we can say copy package

package dojson

and uh files for all needed packages.

Okay. And here we're going to say copy

and we're going to say package. Our

folder is inside of package. Inside

packages we have common folder and

inside the common folder we have

package.json

and we're going to copy this to our

package js

then the common

and slash.

Okay. Um

just like that and uh also let's copy

the whole service. So copy

services

inside here uh we have the off service

of service we're going to copy the

package the JSON to our services and of

service

great and now we're going to install the

dependencies right okay so let's go

ahead and install the dependencies so we

just copy this Now, now we can go ahead

and install dependencies. So, we're

going to learn and we're going to run

pen pam uh small pam install and this is

going to be frozen

uh frozen log file. Okay.

And so this is what we had on these

stages. And now we're going to go to the

stage where we actually need to build

this application. So we have our

installation, our packages ready. And

now we can go ahead and build. So we can

say from and I'm going to use the dips

stage as

builder. Right? We're going to call it

Juda. And now we need to go ahead and

copy the source code. So copy source

code. And here we're going to say copy

copy the command command copy. And we're

going to copy the packages.com

inside the packages common services of

service inside of services of service.

Okay. And now here we can go ahead and

uh build the common library. So since we

have that one we need first. So build

common package

first.

Okay,

we're going to build this first which is

our library and we can do run pinpm

filter

and we're going to if you remember our

app is called chat app then common

on we build this

build. Okay. So building our common

library first and now we can also build

the services. So build services. So run

pmppa

chat app uh of service and we build it.

Okay.

Okay. And now let's go ahead and go to

the production stage. So which will use

a minimal time image. So let's do from

I'm going to use node

22 and let's use this image alpine as

production.

Okay, as production and here we're going

to install ppm for our uh uh install

ppm. So we already have that pinp

can say pm and we can use this uh just

like the same thing we did over here but

this time it's for production. So crop

pack enable crop pack

and activate it. And here we also need

to create a nonloot user because by

default it will use a loot user and we

don't want that. So, we're going to

create a non um

uh loot. How can I name it? Yeah, non

loot

user. Okay. So, for just for security.

So, we can say learn

add group. So, we're going to add this

user to a group

system. I'm going to say system

G

permissions

and node JS

and end. We're going to say add user

to system

and UID

if this

and then you can call this user whatever

if I want. I'm going to call mine node

user but here for leaving a space make

sure to use this.

Okay. So this will create a non user and

we can go over here and we can walk

directory. So work directory it's going

to be on the app uh app.

Okay. And now we can go ahead and copy

the configuration settings. So we

already have the the configuration

settings we have here. So copy the

configuration settings. We already

created this on top just like here.

over here. Okay.

So, we're copying the package the pock

JSON and we're going to do the same

thing also for copying the package JSON.

So, uh with the off service which is

this one. So, let's do the same thing

here for production as well.

And we're going to install the packages

as well. So, we already have that on

top.

and start production dependencies.

But yeah.

Okay.

And now on bottom here we can go and say

copy

um our like we're going to copy all our

build artifacts.

So copy

artifacts and uh from the builder stage.

So from Juda and I'm going to say copy

and I can say

from so from the which stage from the

stage build the on top we have this and

I'm going to go on up then packages

then packages

common

and this

and here can just say um also the

packages inside that we're going to copy

on this destinations common

and just on this right same thing for

the services

uh of service dist and services of

services

uh this

okay and here on bottom we can change

the ownership so change ownership

ownership and it's going to be uh to the

nonlutter that you to the nonloot user

we created

on non loot. Okay.

And here I can just run this command to

do that. So shown

l node user. So the user created the

name you gave it and uh you can say

nodejs then the app

and over here I can say user

uh node

user

and here we can set up uh our

environment that we need to expose

uh that are not very important. So like

for example we need the node M

these are fine you can put them here

production and also the M which is for

the port. So of

service

port and this is going to be on 4,000

and string. So these two are fine other

ones are going to put them in their own

environment variables. So and we can

expose the port which is 4,03

and working directory

is going to be on app

services

and of

service

and last three we can also run command

and inside of this we can use node

and list

index.js.

Okay, so this is basically it for us to

uh use this. But there's still some few

commands and changes that we need to

take care of before we can go ahead and

uh get started. So for example, inside

of packages.json,

this brute command uh will fail. Uh so

we need to change it and let me say uh

let me add and end. We're going to use

TS

areas. So you already know that we're

using some areas when we are importing

stuff. So this will not work in

production and we need to make sure that

they are not there when we run the build

command. So they come they came back to

normal. So resolve

uh we're going to resolve the full path.

So can say full path and we need to do

this exact same thing inside of all our

uh uh services. So let me check the

command if it's correct. So tc project t

config json t areasp t config json and

resol full path. So we need to install

this package obviously

uh but we're going to install it as dev

dependency.

So I'm going to go inside of my

um

of service. I'm going to say ppm add-

and I'm going to say

areas.

Okay. And also let's see what other

packages we have.

Um

sure what is this? I don't need this.

Yeah, move that. Uh, also this one.

Yeah, don't know why it was came there.

We have the TNV. That is fine. So, let's

add this.

Great. So, we have this. And also before

we can do that, we also need to make

sure that uh we have some kind of hair

flouts. Uh, this one is going to be like

very simple hair flouts. So it's going

to be the same through all our services.

A very simple one. Instead of loss index

jsds,

uh we can add this little hair flout.

Okay. So this is just the hair flout

we're going to use for this one.

Yep. So we can check if our services is

running or not. Perfect. And uh we have

that now. So that means we can go ahead

and uh start adding it inside of uh our

docker compos u file. Right.

Okay. Um, so I'm going to go inside of

my Docker compos file and after all our

structure. So after our databases radius

user DB of DB I'm going to go over here

and I'm going to add the of service and

I'm going to say build and this is going

to take in the what we're going to use

uh context.

So the context is going to be on dot and

we're going to have the docker file. So

where our docker file is at? So our

docker file is inside of services

on of

service

and it's called docker

file. This is the name of our docker

file. And we can give this uh docker a

container name. So container name is

going to be equals to chat app

um of service

and here I can also give you the ports.

So for the ports

um

I'm going to give it this one. Let me

remove the network for now. So for the

port I have the off service port. By

default, it's going to be on 4,03.

This is where our port is running. And

now we need to add in some environment

variables that we going to be using.

Okay,

so for the environment variables, so we

have the

node

M. Okay. So, I have the node M and this

is going to be on uh let me remove this

part. So, node M and uh here I'm going

to set it to production.

Okay. And uh now we need also let's

check what we have inside of our off

service. So, get the correct services.

Uh okay. Let's close this. Let me put it

on the side.

Um so we have the node EMV. Uh we can

also have the offservice port right.

Let's have service port.

This is going to be offservice port is

going to be running on this port.

Um we can also have our off the base

URL.

And for this one, uh, we're going to

use, since we're using MySQL for this,

um,

we can say my SQL

then let me close this.

Yeah, let me accept this for now.

So,

uh, so this is the database. So my SQL

of DB user

and we're going to have in

this as the default user of DB password

of password of DB um

so instead of using this host this way

um

let me remove this. So on the add sign

I'm going to use this internal uh so we

called it we gave it a container name of

of DB. So using it directory and the

port is going to be um 33806.

Okay

remove this money sign. So we are using

this directory. So

uh we're using it inside of here. Um,

we're using it here. Yeah. So, we're

using this as the name

and it's going to say of DB MySQL. So,

let me check everything is correct. MySQ

of DB user and make sure that's the same

thing we have here

of DB user chat. You can give it

whatever you want of DB password. chat

of password, but make sure there is the

same one you add over here.

Okay,

great, great, great.

Yeah, seems all right. And next one we

need to add is our JW2 secret. So, let

me add all the secrets that we have.

Then we're good.

Okay. So we have the JW2 secret. We have

the JW2 expires in. We have the JW2

refresh tok secret. JW refresh in elab

internal API token.

Okay.

Yeah. And also for rabit MQ we already

have this as the password.

Yeah. We already have this guest as the

password. So you can change this to

whatever you want and uh this will

depend on so let me say depends on the

service

uh which is going to be our off

database. So we need to make sure that

our database is running first before we

can go ahead and uh start

connecting to it right and also it's

going to

depend on lab mq

so bit mq as well we need to make sure

that it's running

and our network is going to be chat app

network

Perfect.

And uh we added a health check. So we

added a health check. Let's um let me

add the command that we're going to use

to check this health. So this is the

command we're going to use when testing

when the the server is testing itself to

test if it's running health or not.

Great. So this is all we have for this

service. We have all the services

defined

and uh

yeah

maybe we can test that out. So let me

add let me start docker and see what

will happen.

Um

it's let's starting

okay and close this

I can say I can go to the loot file can

say docker compose

app

dashd

uh wait not what did not do we give it.

Oh, this is supposed to be capture it

and not small it.

Uh, so let's set this again.

Uh, okay.

Compose

app.

Okay. So, this is going to go ahead and

build our image. So, it's running all

the the commands that we have set in our

Docker file. As you can see, it's

running all the commands. So now it's on

the command to to add the services

and why did uh control has no health

check configured. Okay, so let's add

health checks on our raid MQ as well and

as well for uh the our database that we

need to add. So let's add the ref check

for rait MQ. So after the network,

let me add this health check.

So let me just put it here.

The health check command is needed for

this. And also uh we're going to be

adding also for our uh authentication

database health check. So where is the

authentication database

here? We need to add this health check

as well.

This is the command we're going to use

for checking if the system is running.

So let's try again.

It's waiting

to be healthy.

Okay. So they have all started. Now

let's go inside of our docker and see if

uh it's starting. Okay. Seem like

there's some issue.

And um where's the issue?

So for new error

no module found cannot find module

packages common list env.

So env is not being found here. Why is

that the issue?

So I think also for the uh the common

folder we also need to to change the way

we build the packages. So we need to add

the same command that we added in our

service. So I can go over here close

this

and I can go to the packages.

Yeah, we need Yep. We need to change

this. So it's not it's not building. So

still building with the

uh old command. So I need to change this

to the new one. And now let's try to

land this again.

And uh let me check my docker compose.

Uh

yeah, let me let me stop it actually. Uh

so

uh do compose

down.

Okay. uh

took a compass

build and let's build

our uh what did we call it

of service sorry of service.

So I'm doing this

What is the issue?

Yeah, TS car is not found. We need to

add this of course. Uh let's go to the

so you can do pm add

uh sha

basic area no shter

inside of the uh packages

contain the common and we can add this

package

as div dependency

and now we can go ahead and try to Run

the build command again.

Okay. So let me start the command

upd

is waiting

staying pured successfully.

Uh we still have an issue.

Um JWT fresh token. Okay. So it's not

finding this settings, this uh

environment variables. Um yeah, what I'm

going to do, I'm going to create a env

file in our root directory. Okay. So I'm

going to have a new side of here. So we

can call it env.

And when you build I brief it will use

this uh to use this. So I'm going to add

all the packages all the environment

variables that we're going to need.

So these are all the packages that we're

going to to need. Okay. Now we leave

this in the settings

repository as well. So you can easily

get access to these. So these are all we

need to add for all our services. So

each service has its own settings. Okay,

great. Uh let's try this one more time.

Hopefully we get some success with this.

Actually, I'm not sure if this

will fix our issue.

Um, let me check this out.

Okay.

Oh, yeah. It's it's actually fixed it.

But, uh, we have issue with um

connecting to the MySQL.

Okay. Why did it fail?

Um

I using different settings. So

for my database I'm using

for the of database. Let's make sure

that we have the the correct settings.

Okay. So for our off service, let's

check this URL once again.

Um, so we have the database. So we have

of DB URL. MySQL equals equals to of DB

user.

Okay. So the of DB user is chat app

uh chat app of user. Same thing here.

And also same thing for our

here. So chat app of user right.

Same thing here. And after that uh we

have of DB password which is chat app of

um password.

Um yeah we don't have the same password.

So for now we are in development. So we

can go ahead and use the same password.

So chat app of password.

Let me change this to this one. And also

for the database name chat up of service

that is fine. Uh for the loot password

as well. Let's go to the off DB. Let's

change it to this one.

Okay. Great.

So now this is good. Let's go ahead and

build the service again.

Let's run the

thing again. And this time um let's

check what will happen.

Okay.

Yeah, perfect. Our off service is

connected to all our databases.

But uh we seem to have also another

error.

Uh which one is this this time? http

message annotize tag

uh package common

error occurred.

Uh we we where are you getting this

error from unauthorized?

Okay. Um

let me see uh our

docker compose

uh service.

So where we checking?

Okay.

I'm going to see why this issue is

happening.

Um,

HTTP error and error cured. Uh, that is

the issue that we don't have.

that our database connection was

successfully of service ramp keeper

share was initialized

and uh just here we have unauthorized

um is it can it be the uh API token

uh yeah I think I know what's going on

here so since here we have different

kind of we have different type of uh

yeah So this one here.

Yeah. So actually the easy fix is to

build the command the the whole services

again. So we need to let's build the

whole services again but this time

they're going to build with this uh with

these keys. Right. So I think it make

much sense to build everything with

these new uh tokens and stuff. Okay. Uh

so let's go ahead and actually uh learn

the Jude command. So make sure to turn

off all the uh stuff you have running.

And now you can also go ahead and learn

the be command and the same add no cash.

So it's do it from scratch.

Okay,

good.

And uh let's try to learn it again.

And uh hopefully this will fix our

issue.

So authentication service is waiting.

Let's see the message we're going to

get. Yes, we're going to get some uh

Okay, we're still getting these errors.

Um,

okay.

What is the issue?

Let me stop it again.

And let's do this again.

Um,

but I wanted to build it first.

Um,

yeah.

Okay, we're still getting the same

error.

So, let me try um do one thing.

Let me try to add the same API gateway

API internal token that we have here

instead of our NV here. Internal API

token. Let's try to add this same just

just to see. Um but I'm pretty sure this

is just will be okay if we deploy our

things to production.

Um,

but

just to be safe,

[Music]

I'm sure this will be fine. This is just

uh since we're already in development,

so it's giving us some issues, but uh

yeah, I think we can go ahead and move

on and

we're going to test this beta in

production. We are deploying to our VPS.

So if getting if it give us an issue

again uh I'm going to just ignore it and

go to other services.

So let me open my docker compose.

Yeah. Uh so we can ignore this property.

Let's ignore this. Uh let's take

everything down.

Perfect.

So, let's go do the same thing for our

other services. So, we're going to add

we already have this Docker file for

this service. All we need to do is

change uh change the names of this. So

instead of of service going to be for

example the chat service and uh uh yeah

it's going to be pretty much uh the same

thing for all our uh uh services. So uh

let's go ahead and work on other

services as well.

Okay. Um so let's go ahead and start uh

working on the uh gateway service as

well. But uh let's make sure we have the

correct stuff. So make sure to add this

new build command we have added inside

of our of service and also make sure

that your main file is set to this. So

just the same thing we did when we

started. So we are going to add this to

all our uh services and as well the

module like this. And also make sure you

install the package that goes with the

build command and also the NV if you

don't have it already.

Okay. And um inside the of service uh

the thing that was giving us error

inside of apps uh inside this one. So

you see we have an uh we have an health

but we are also uh preventing it from

making request to our to this one. So

let's add this so that it will bypass it

the hair flout. So we're going to be

using this.

Okay. And now let's go ahead and copy

the

uh inside the yeah let's copy this

docker file. We're going to change this

and inside the gateway service. Let me

paste this docker file that I just got

from off service gateway service. Copy

this. Paste this I mean. And now let's

change stuff. So uh we're going to

change anywhere that we have gateway

service. We're going to change it to uh

off service. Okay.

Uh let me just start here actually. So

let me change this to get way

service. Uh for the build command uh the

copy the source code going to be for

gateway

and this one package is okay but also

building the service. So let's make sure

inside of config the name this is the

name we have to give so get this correct

name

and uh you can just say gateway service

build

okay so create a gateway service build

and where else do we have get uh of uh

here so let's make sure to change those

to gateway

and over here as well we need to change

this to gateway way

and uh finally right here we need also

to make it to gateway. Now let's check

our env. So the port is called gateway

port

and it's running on port 4,000.

So I'm going to add this and expose it.

Okay, so that is all we have. So now we

can go inside of our uh docker compose

file. So inside the docker compose let

me add it on the top here and this one

is going to be gateway service.

Um okay uh yeah

so let me accept this for now. Let's see

what we need to change. So the gateway

service debuted is the same thing we did

for this one.

Give it this name

the gateway port environment variables

this one

and we have the service of service URL

which is using this as the name since we

are inside of the net to same network so

we can use this is fine and uh we have

the JW token internal API token token

yep and now finally you can add the uh

health check endpoint point

we have the health check. I mean so this

is all for our gateway service.

Uh we are not connecting to any

databases or anything like that. So this

should be okay. And um yeah let's go

ahead and start it. So I'm going to run

the build command.

So do compose build.

Let me accept this.

Okay, they have been viewed. Now let me

try to learn my services.

Okay. So, it's saying that the ports uh


are available are not available. Okay,

that is fine. I know what's causing

this. I can just go to my settings.

And uh I can just go I have this my SQL

server is probably running on my

machine. So let me close this and also

let me uncheck this.

Let me add the password.

Let me stop this.

All right. So, I stop this now. It

should be okay.

Okay. And let me start it again.

Let me check my Docker compose uh Docker

desktop. Sorry. So, our MySQL is now

running. So, you authentication database

is running. Authentication database is

running as well.

Great. So we don't have any more issues.

And now the gateway service is having

some errors.

Um

yeah, because we need to add the the uh

user service URL, the chat service URL,

etc.

That's why you're getting these errors.

Okay,

but that is okay. Now we're going to add

more services and this should be okay.

So let's go ahead and do the same thing

for other services as well. So it's

going to be similar thing. So I'm going

to go to the let me copy this gateway

docker file.

Go to the uh let's do user service.

Let's paste this docker.

And uh this time we're going to it's

going to be so let's check the name of

this chat app user. This time I'm going

to use this as the name. Let me just

change it right here where we build it.

Okay.

So change this as user. And now let's go

ahead and start changing. So start here.

Change everything to user service user

service. And make sure you don't forget

anywhere to change that.

And we can also go here change it to of

user user service. go over here as well.

Change it to user service.

And uh for this one, let's check the env

file. This is going to use a service

port

and it's running on port 401.

Okay. And also change this over here. So

user service

and make sure in the package JSON you

have this as well. And also let's not

forget to add the build command. So let

me go to get to a service. Let me copy

this build command. Let's go back to uh

user service package.json. Let's add in

this command.

So let's just paste this command here.

And also we need to install this uh tsh

areas command uh package.

So let's just do inside of the user

service. I'm going to pinp add as de

dependencies.

I'm going to add this TSA carriers.

Great. And uh yeah, so let's go ahead

and also build this inside of our Docker

compos. We need to add it as well.

So after the gateway service and also

after the off service

uh let's add this user service

and uh this one is going to be the user

service. So it's going to be like

similar thing. Let's just accept this

and change what we don't need. So for

the user service we have the build

command. This is going to be the same

chat up user service. This is the user

port is fine. No DNV we have the user

service port user DB URL fine it's using

what we have defined

and JWT secret

uh we don't have this inside of user

service we don't have this uh let's

check actually so inside user service

yeah we don't have all of those we just

have the internal API token ram URL and

user DB URL okay so let's remove this uh

uh JWT related stuff.

Okay, internal API token is fine. LiTMQL

is fine and uh checking the hair float.

So that means we also need to add in uh

the hair float. So inside the app, we

already have this, but let's just keep

it on /herf

and we can go ahead and add in the hair

rout uh inside of our our user service

in the uh louds index.ts. So we can be

able to check this one. So inside the

layouts index, let me add

this little check.

Okay, great. And uh let me make sure we

are not forgetting anything else.

So let me cross other files are actually

uh cross others. So we have the node env

user service port user during

ql API intern API token.

And now let's go back on the gateway

service. So let's add also the uh user

service URL. So user service URL we have

it. Now we can go ahead and add this.

Okay.

So that is fine. And also for the

condition. Yeah. Let's make sure to add

user service and mant is ready. Uh yep.

And uh while still here let's also do

the same thing for let me copy this

docker file.

So we have the we have the off service

ready. We have the user service ready.

We have the get to layer. Now let's do

the last one which is the chat service.

So let's add this one. Let's check the

name of this package JSON. This is just

chat service. So copy this name inside

the docker file and where we are

building this one and just change it to

user service and let's go on top and

start changing this. So this going to be

chat service

over here as well. It's going to be chat

service.

over here as well. It's going to be chat

service. So just change anywhere you

have. It's not related to the service

you're working in and it should be

straightforward. So inside AMV, let's

take the chat env.

And let's change this one to be also

chat service.

Okay. And um let's check inside the app

index. Yeah, we have the hair flout and

uh we need to add the build command that

we are using inside of other services.

So package JSON uh let's take this build

command

and let's go back inside of the chat

service package.json.

Let's add this. And we need to install

this package as well inside of here. So

let me go inside of chat service. Then

do pm add ht

test t areas.

Great. And uh the env as well for the

chat service. Not going to be very

complicated. We just have delete this

URL. And also uh let me go inside of my

docker compose

and uh after this one after the other

service we can also add the uh chat

service as well.

Okay.

Yeah. So let's check if this is what we

need to have inside of our chat service.

So for MMV we have the node MV chat

service port URL radius URL abit

URL GWT secret

API token and it depends on this

radius and labmq network and health

check. Great. Now we can go back here on

the gateway service and we can finally

add this

uh chat service URL

and also let's add maybe let's add them

in order. So let's start with this.

Okay. Uh let me remove this space and

let me put this on the top

just to make much more sense.

Okay.

Yeah. So, we have the user service of

service and the chat. And also for the

condition check, we're going to check if

the service is healthy. Okay.

All right. So, this should be okay.

And let's go ahead and build this again.

So, let me go on the loot. Let me run

the build command again.

Okay. Uh so shut up. Uh user service uh

did not complete.

Let's see what's the issue. So user

service tok compose

um

chat up. Oh this supposed to be uh yeah

this is user right? Which one failed?

Uh sorry let me run the build command

again. See what's failing.

Um

the user service was running right

before like

okay uh it said shut up user service

let me check the package JSON uh the

name is this one is correct

docker

um view the let's say the

user service.

Okay. Uh, user service. Am I missing

something?

Use a service. Use a service.

Yeah.

feet viewed.

Oh, it's some it's some errors. Not the

not uh user service.ts

um is not assignable parameter type

because created that uh

okay uh let's check that this error. So

instead of

uh let me see inside the user service.

So services user service and it's saying

oh

uh yeah we we updated this but we did uh

we did we updated the the event that we

created but we did not uh add this

inside of our uh services. So that's why

it's giving us this error. So all we

need to do is just add the updated that

updated that and it's going to be the

same thing for the user updated that ISO

string. So let's also do the same thing

here. So we just need to add the updated

that when publishing this

and this should be good. So let me

deploy this again.

And this hopefully this should fix all

our issues we have.

Okay. services has been built. Now let's

try to run in them.

Uh what's the issue?

Uh MongoDB URL is not set.

Why is that?

Um,

do we not have it in here

MQ?

Abit MQ URL should be set in here.

Did I not set it?

Okay.

Um

yeah

so MongoDB URL this URL and labq I think

we need to change some uh on our

services we need to change how uh we add

this

uh for example on the uh read this URL

let me check this so let me close

everything

instead Docker compose. Let me check the

URL.

Uh this is this should be okay. I bet QR

should be okay. We have the password.

Have the guest as guest.

The volumes. Uh do we have volumes for

this one? Yeah, we're also not setting

up the volumes for this. So it's

probably a good idea to add the volumes

as well for this one. So volumes raid MQ

data

runs on this one and also for

uh radius as well. Actually it's already

this data we are not adding anything.

And let's also add a health check for

radius.

And for MongoDB we also uh need to add

the data and also the health check.

So let me add health check for MongoDB

which is going to use this uh run

command

and um yeah.

Okay. And um

actually uh what what database are we

using for a premium QRL is not running

for our uh

chat service. So our chat service is the

one giving us all these errors. So let

me close this. Go to chat service.

chat service. Um, yeah, yeah, yeah. This

is not how we're going to set it up.

That's why we get got this error. So,

it's going to be okay. MongoDB. So, just

like the same we did. So, MongoDB,

but we're going to add in so user

uh instead of this one actually, let me

just accept this for now. So this is the

format

and uh

same thing for the raid MQL but for the

MongoDB we're going to use the this so

let me close this service user service

of service let me close them for now and

also the gateway service let me close it

so for the database of we're going

to use this so name

and here so use instead of

we're going to use the root so in

user root here and also init root

password

and we have the database

um yeah we probably don't have database

but

uh let me try to fix this so MongoDB

password.

We're going to set that as well. And

then it's going to be on The port

is this port. And here I'm just going to

use the uh name. So chat

app and going to be of source is going

to be to admin.

So this is the

URL and for radius for radius is going

to be very simple. So radius uh user

uh read this password uh don't think for

radius we have any authentication

uh let me check. Yeah we just have the

port.

So for now that is fine.

We just have the port for our ladies.

Um, mobile ladies user. Should we add

authentication?

Um, let me check my env.

So, this Yeah, this is just a port.

Okay. Uh so let me go here and I'm just

going to add in the radius

going to cost to

uh at this right

so radius is equals to radius then this

port lab we have the labmq user labq

password guest and that is fine jwt

secret. Yeah.

Yeah. Yeah. That is good. Leave it like

that. And uh hopefully now uh we should

be okay.

So let me run the mute command once more

again.

Oh yeah, let's also add the data we just

created.

Um so over here on the data, we're going

to add more data that we have. So

data we have um lab MQ data and also

lead this data and also for lab MQ we

add add that as well.

All right. So let's run this and

hopefully this works and let's start

them.

Okay. Uh, we got an error.

I'm not sure what's the error is.

Shut up user DB.

Shut up.

Why isn't that chat up user DB? Why is

the user database

not working?

Yeah, that's the problem we want to be

having.

Yeah. So, I'm not sure uh what is the

problem here?

Okay.

Uh what's going on for our services?

So,

the chat service, this is the chat

service. Let's go through it once more

again.

Make sure everything is okay. MQ rabbit

user ghost

password. Okay. The URL

as MongoDB pass in this initb username

nov

what is 2002.

Now let's check the user service. So the

user service is also having the node

env.

port is 401

the user uh user DB URL it's going to

user DB user

and also user DB password

chat app

and uh it's running on user DB and the

port is just like that and also for the

database user DB

name

right so same thing for the rabbit MQ

uh impq rabbit MQ user

and uh rabbit MQ password.

Okay. Um

our service is running well.

Uh gateway service.

I'm not sure what's causing

what's causing these issues. Um, do we

have not the same thing as another

databases? So, let me check the env.

Okay. Um, yeah, we need to change this

actually.

Uh, but we shouldn't have to change

them.

Um,

yeah,

let me see.

So for the bit MQ we're using guest as

guest

right

chat user

let's use guest as well it's fine.

So guest

guest the port

the port is correct

and also let's check our uh chat

MongoDB database

it's salute

and also this one is password

and the port is correct.

Uh user database

we have this the user DB name

you have the chat user the data uh the

user

and the password is going to be chat

password.

Yeah,

from my SQL.

So, we have the database

and the user,

the password,

the password.

Okay, so hopefully this should fix our

issues.

Um,

so I see my off data service is running

as well, but other services are not

starting at all.

Okay. Um,

shut up. is waiting.

Why is it waiting?

Um,

is it the command you are learning

to check the health

for the MongoDB? Where is MongoDB?

Uh, yeah, I think this command is long.

So, it's a command.

uh let me use let me add in the correct

command actually. So for the test

this is the command we're going to use.

So make sure to add this command. And

now let's try this again.

And um

yep. So that started but failed to shut

up DB has no check. So health check for

the user database we need that as well.

So user DB we need to add in the health

check. So let me just add this health

check. And I'm going to just add this.

So

over here

this is how we're going to check it for

our user database.

And uh let me start it again.

Okay.

Chat app chat service is unhealthy.

Yeah. I don't know what's going on

anymore.

Uh we are we don't havev. Okay, that is

fine inside of the chat service.

But what about the user service?

Um

it's not connection error for the user

service as well.

Okay. So let me go to the chat service.

It's so that we don't have thev.

So ppm add

nv

and also where do we have the user

service connections are failing. So

let me go to user service. Let's check

the the user DBR is failing.

So this is where the things are not

working for us.

So we have posgress

user DB uh chat user chat password

user DB.

Let me check my env.

Okay. So user DB

user DB name

user DB user user DB password

let's check the database we have so user

DB

chat user user

chat you chat app user

see correct

chat app password

and the port is that port.

I don't get it. I don't get why it's not

um

I don't get why it's not starting.

Do I need to build again?

Let me just do this so we see what's

causing all these errors.

Okay, so we have those viewed. Uh, let's

try to start them again.

Uh yeah,

not sure what's going on. Uh

a disconnection if service

authentication a fade.

Um,

okay.

Afraid to start your service

authentication phase. So, this is all

errors related to our database is not

working.

Um,

yeah, let me go ahead and try to fix

this.

So, what I'm going to do, I'm going to

try to uh remove everything with the the

their volumes as well. So, I'm going to

run this command to compose down with

their volumes. So, maybe this will is

still caching and using the old data.

So, let's try again. And

hopefully this can fix our issue.

If not, we're going to try and see what

we can do to fix this.

Let's just wait. Okay, so the off

service is seem like

getting fixed. The chat service is

waiting

but uh seem like the other services are

healthy

and uh the chat service is still

waiting.

Okay. Um yeah, but I think that was the

actual issue.

Okay. Uh chat service

Yeah.

Okay. So here we have this success

message.

Uh increments

it JS is not specified. It doesn't pass

it as common.

Yeah. Okay. So okay that was the first

issue. So we just need to remove was

using the old cachings but inside the

chat service do we not have

do we not have the uh oh yeah we don't

have the index. Yeah this is a mistake.

So let's make sure to add this

these ones inside of our chat service.

So add this

and also just in case let's also add

this module and this private.

Great. And uh let's

turn down them with the their volumes.

Let me try to start it again.

Let's see what will happen. And if it

doesn't work, we're going to remove and

build it again. But I think should be

okay. So let's see the user service is

running.

Okay, user service is running.

Chat service.

Yeah, I think we need to remove the and

view this again because we just changed

the code. Yeah. So let's turn them down

and uh let's build this again from

scratch. But I think this should fix all

our issues we had. So do compos build

and um hopefully this will fix the

issues we had uh with these services.

Okay, great.

And let's try to run them again.

Okay,

so our services now

are running. Chat service again is not

healthy for some reasons.

Um

yeah I'm not sure why it keep not being

her right now

of service is running right.

Uh what is the health check for this

one?

Do we even have health check?

Yeah, we have the hair, but do we have

it inside of our layouts?

Yeah, this was the issue. We don't have

it inside the ours. Uh so that's why we

was getting it was not uh starting

because we don't have the uh the inside

of our chat service that we check if we

we return the response. Okay, if there

is a success response.

Yeah. Let me stop this. Um,

let me add it here.

Yeah.

Um, let me build it again. And but

hopefully this is the last time I'm

going to check this. Then we can move to

our cloud. So we don't want to move to

the cloud if you don't we know that

things are not running on our local

machine. So

that is better.

And now it should return a hairful

response

for us to see. Perfect. So now it runs.

So let me check. So seem like our

services are running. But let's go

inside of each one. So let's start with

authentication service.

Okay. So seem like it's running.

Good. Let's go to the chat service.

It's running. It's connection to

database. MongoDB RTMQ.

Great.

Let's go to the user service.

It's running as well.

Let's go to the gateway service.

Gateway service is running as well.

Perfect.

Yeah, this took a while, but it's

working. Now, let's test some moment of

truth. Let's go open Postman and uh

actually see if this is running. So, we

got everything running from our Docker.

So, let's just make sure I don't have

the gateway is not running. Yep. Nothing

else is running. Nothing else is

running. So, let me go ahead and test

this. So, we're still going to use the

local host 4,000, right? And uh let's

get a hairful out. So, let's check

get service is okay.

So, we're getting the response. Let's

register a user inside of this database.

Let's send a request.

Registration is working.

We can log in. Right.

We logged in successfully. Now, let's

check our database.

I'm just making sure that everything

still works as expected.

Uh so, chat up user.

Yeah. So we have new data.

Let me refresh this. So this is the user

we just created right now. Uh you can

see the date. This is the day date.

Let's go to the user service. And we

have the new user as well. Perfect.

Okay. Uh so we logged in as participant

number one. Let's create a conversation

as participant number one. But you know

let's also register a participant number

two. So just participant number two. Now

let's create a conversation with

participant number two in it. It's

created and we can start deploying this

to our cloud environment. So let's go

ahead and start working on deploying

this to the crowd so we can add our

custom domains etc etc. So let's go

ahead and do that.

So let's go ahead and host everything to

the crowd and we're going to be

selfhosting everything. So that means we

have to get our own VPS uh so our own uh

virtual machine. So there's too many

options when it come to selfhosting but

the two most important ones are or most

um known one or famous ones are these

ones. So, doproy and cool. So, all of

these are open source. So, you can check

their code on GitHub and you can

self-host this, which is what we're

going to do. So, for me, you can choose

KFI if you want. But for me, I'm going

to choose Doc Pro. So, why? There's no

specific reason. I just like I I mean,

I'm used to this. So, and I'm feel more

comfortable with working with Doc uh

with Doc Cry. So if you want to if you

are comfortable with cruy that's fine go

ahead and do that and the next thing you

have to make sure you have you have to

come with your own virtual machine. So

you can create one on Google crowd on

AWS but make sure to have uh the OS or

the operating system as Ubuntu and the

LTS version. So Ubuntu is the

recommended uh operating system for

this. So make sure to have an any LTS

version. You can literally get the um

the machine anywhere you want but make

sure to meet the requirements. So make

sure to meet the 2 GB of RAM and 30 GB

of disk space. So this is the minimum

requirements. Okay. But we can also um

get a bit more just to be safe depending

on our applications. And I'm going to

get my own oninger.

So let me go ahead and choose Ubuntu and

I'm going to choose the LTS version

and I'm going to generate the password.

Okay. So I have the password. Click on

next. And also I can add SSH key if I

want. I'm going to add this later. But

for now I'm click on next. Next again.

And I can see that this has 8 GB of RAM

and 100 GB of disk space which is more

than enough for our doc pro to start

working. But this will depends on the

services that you are hosting. So if

you're hosting something that needs a

lot of more storage and RAM, make sure

to go and upgrade this. But for me, I'm

going to choose these options. So the 8

GB of RAM and also the 100 GB of disk

space which is more than enough for

this. So go ahead and get your own VPS

wherever you want. You can use Hna, you

can use AWS. Just make sure to get your

own VPS and once you have that you can

come back and we continue. So I will see

you once you have your own uh VPS. So

perfect. So my VPS is ready and I hope

you also have your own VPS and uh once

you have your own VPS the finger that is

rest is to SSH into the VPS. So whatever

method you added to uh and go inside of

that just go ahead and do that. So and I

can paste this

uh can say yes. And now I need to

provide the password that I have uh

added when creating this VPS or whatever

method you're using to access your uh

VPS. Okay. So now I'm inside of this VPS

which is onto VPS. And uh the first step

we have to do is the first step before

uh doing anything is making sure that

our packages are up to date. So we can

run this command. So up to update and up

to upgrade

SLY.

So this is we're going to make sure that

everything is up to date. Okay.

So this the Y will just confirm

everything. So any prompt that you get

to confirm it will just confirm

everything for us. Okay. So let make

this full screen.

Let me zoom in a bit. Perfect. So let's

wait for this to finish and we can

continue as well. Okay. So this is done

and uh the next command we need to run

is to install the carry command. So you

get I will put everything inside of the

description so you can um access these

commands easily and um we can also add

some more utils but there is no needed.

Now let's go ahead and install the doc

dock pro. So let me go back to my

browser.

So doproy. All I need to do is copy this

command. Go to the uh domain or to the

terminal. Paste it. And this will go

ahead and start installing the doc pro

inside of our virtual machine. So this

going to take a while. So let me go

ahead and wait for this to finish. then

I will see you once this has uh done uh

installing.

Okay. So, Doc Pro has finished

installing.

So, we can now go and access it to the

this URL that are giving us. So, let me

try to open this.

Yep. And this is do pre interface. So,

this is how we can uh access this. So

here we can create the root account, the

admin account. So go ahead and fill in

your details and make sure to create

something that is uh safe. Um yeah, so

let me go ahead and fill in my details

and I will see you once we have done

that. So make sure to do the same thing

as well.

Perfect. So now once you have your uh

details set uh we can instead of keeping

keep accessing our uh dashboard to our

uh IP we can go ahead and add our

domain. So instead of doing this let's

go ahead and add domain. So let's go to

the web server

and this is where we set up an email or

an domain in this case. So also make

sure you have a domain. So I have a

couple of domains I use. Uh I'm going to

use this one. So this is the domain I'm

going to be using for this one. So I'm

going to go and this is inside of

crowdfl. So let me go to DNS records.

And I can go ahead and uh uh add a new

record.

So add the liquid. And this one is going

to be uh a liquid. And uh since I want

this to catch like if I add any other

applications to my uh dock pro I can

just give it um a domain and it will

just attach it to this website this

domain right here. So and you have to

give it the IP of your uh virtual

machine. So over here I can go to

managevps

and uh let me skip this. So I don't want

this. Skip this. And uh here I can copy

the IP. So this is the IP. Let me copy

this IP.

And I can add it inside of the DNS

record as the target. Uh we can keep

this proxy status turned on or also we

can turn it off. But I'm going to keep

it this way. So,

um maybe we can

Yeah, let's leave it this way. Um

yeah, let's leave it this way. Or maybe

we can give it the name. Yeah, let's

leave it this way and see what will

happen. So, I'm going to give it as

asterics. And now let's go to the doc

pro. So, inside the dog ploy and I'm

going to give it a name. So this one

going to be doc pro. Okay. Uh so add

your domain

this subdomain and also the email and

also make sure to confirm your uh https

and use this encrypt and save this. And

now we should be able to access our

panel or our dashboard through this. So

let me paste this here.

Yeah, perfect. So now we're accessing

our

domain, our panel to this domain, our

custom domain that we have set instead

of using that uh dashboard.

Great. Um

so now let's log in with the details

that you have set when creating the

account. So we'll go ahead and set those

in and we can log in. Okay. Um so now we

have this um ready. Before we can go

ahead and do anything else, we need to

push our code to GitHub. Yeah, because

whenever we push changes to this our

code, we don't have to do anything. It

will automatically build our services.

So let's uh start uh pushing this code

to GitHub. So we're going to add a g

ignore file. So inside the loot file,

let's add a new g.get get ignore.git

ignore and add in all these details and

this env file is going to act as our

env. And only I can copy this paste this

or I can just copy this paste it here

and I'm going to call this dot example

so we can access this easily later

and uh make sure to change all of these.

So actually um

let me change them maybe. So let me go

inside of this env

setting it for our production. So we're

going to change everything here inside

of this env file uh to meet the

production requirements. So first of all

let me initialize this as the GitHub. So

on VS Code you can learn this initialize

repository

and uh this

NV example it's fine. You can push this.

There's nothing much that we want. We're

going to change all of these anyways for

production. So this should be fine. But

what what you don't want to commit is

this env. And you can see it's grayed

out. that means to not be pushed to any

of the GitHub as same thing for all of

these ANV files.

Okay. So now let's go ahead and start

generating secure keys for our

production. So I have my uh code pushed

to GitHub

and we are on the main branch.

Okay. So now what I'm going to do I'm

going to go inside of Doc Pro. Right.

Okay. So how this work? The first thing

is creating the project. So you can

manage different projects. So I'm going

to add a project and I'm going to give

this a name. Uh it can be anything. So

this is the name. You can also give it a

project. So now let's create a project.

And now we're inside of this project.

And you can see that you can also change

and add environments as you want. Okay.

So now what we need to do is creating a

service. So let's create a service and

we are going to use a compos service

since this is a docker. Okay. And this

is going to be um

what can you call it? We can call this

uh chat app

back end right since this is a back end

and uh

let me do it like this. Shut up back end

docker compose. We're using Docker

Compose. Give it a description if you

want. I'm going to go ahead and create

this. And inside of Docker Compose, the

back end we just created. Let's go ahead

and attach in the GitHub. So, go ahead

and connect your GitHub. So, click on

settings.

And now you need to connect your GitHub

account. So, click on GitHub.

And if it's an organization, you can

turn this on. But if it's just your

personal account in in that case, mine

as well. I'm going to go ahead and

create GitHub app.

Okay, so it's authenticated, but it's

not done yet. What you have to do is

click on this button right here to

authorize and give it access to the

repositories that you want. I'm going to

give it all uh all repositories for now.

And now we have connected it. So go back

to projects, go to self hosting, shut up

back end. And here choose your account.

So I'm going to choose my account and

also I'm going to select the repository

that I have all my services and the

docker compos in. Okay. So I have

selected the repository that I'm using.

The branch is going to be the main

branch. It's the only branch we have and

this going to trigger whenever we push

changes to our GitHub it's going to

trigger this again and it will build

with new code and the docker compos buff

where it is in the loot. So we can give

bit like this and uh let's save this.

Let's go to the environment and this is

where we need to add our environment

variables. So let's go back to our uh

editor

env. This is the environment that we

have set up. So let's copy everything

and let's paste them here. So this is

everything we need. Okay. So make sure

to change this to production and save

settings as needed. So I'm going to save

this. So these are saved now

to the domains. Uh we can add a domain

later on once our services has bu

now everything seems good to me. So go

and go ahead and click on deploy

confirm and you can analyze this. So

let's view and see what is happening. So

it's going to do the same thing that

happened when we deployed on our local

machine. So it's going to build the

docker compose and pull some images from

the docker hub. So let's go ahead and

wait for this to finish. Okay. So it

seem like we got some issues

uh inside of the chat user service is

unhealthy.

Okay. So let's go to the logs

and uh let's click on chat user service.

What is the issue now?

Uh it's saying MQRL is invari

[Music]

MQRL is invari.

Okay, interesting.

Um,

let's check also the of service.

So, they all saying invalid URL. Which

one? Labbit MQRL is invalid.

Okay. So, rabbit MQ is invalid for of

service as well. Uh,

chat service. Let me check the chat

service.

bit MQRL is invari

okay um

size

so it's all about limit MQRL let's see

what's the issue what's causing this

okay so the possible uh fix I can think

of right now uh is

instead um instead of using this this

way Okay,

I can do one thing. So, let's start on

the uh

authentication service

and here

on of the URL I'm going to remove this.

Okay, so of the URL I'm going to use

move this and I'm going to use

as

of DB URL. So just like that. Same thing

for Leit MQ. So I'm going to use Lebit

MQL

DB URL.

Okay.

And also for user service

I'm going to use user DB URL lab MQRL.

Go to chat service

pass in the MongoDB URL and also the lab

MQ URL as the same thing.

Okay, so have URL this URL MQRL.

Now

we should just have this as URLs nothing

else.

Okay.

So this way we don't have uh to

complicate things for us. But now we

need to update this env to just have the

URLs um instead right.

So we need to update this to have URLs

and we can build this once over uh

again. Okay. Um

hopefully this will fix our issue.

So let's go ahead and push these new

changes and uh we'll see what will

happen. I'm going to copy this, right?

I'm going to go to the docker compose

for our deployments and

I'm going to add these environment

variables

at this.

And I'm going to try to start this and

see if it will start. If doesn't we

delete this and we add it one more time.

So just to see if this will fix the

issue that we had before and if there if

it fails I'm going to delete this and

I'm going to add it one more time. So

just making sure that there's no caching

that is making it use our old services.

Yeah. Yeah. I think I'm going to remove

this.

Um,

okay.

Yeah, yeah, yeah. I'm going to remove

this.

I'm going Yeah, let me delete this. Let

me remove this.

I'm going to also check this volume for

associated with this one so we can build

once more time. So, let's start over.

Let me add the compos file.

And I'm going to call this name.

Create. Go inside of this.

Select main.

Go to save.

Go to environment variables.

Let's add this one.

Uh let's the add the environment

variables that we have here. So, copy

this.

pasted them here to save them.

And now let's deploy

so that we start over again. So now

let's wait and hopefully this will fix

the issues

that we had.

Okay. Um seem like does not fix it.

So what could be the issue right now?

User service.

Okay, but it finally created it.

So it's running

of database connection is running.

Shut up is running as well.

um

just the gateway service that is waiting

for these them to be ready

but I think right now they are running

so let's go to docker right let's go to

docker and I'm going to

um

then way can just restart this

it has been created but it's Not

or it think that we our services have

failed when they're actually running.

Okay,

let me reload.

I go to the logs.

Yeah. So reloading this, it made sure

that our services are running.

Yep,

finally our services are all running. Uh

let's go to the domain so we can add a

custom domain and uh I'm going to select

the gateway service and this is going to

be on API

with codewise.com

with codewise.com the path is going to

be this one and our port is 4,000

and use https this. Let's encrypt. Let's

create this. So, validate this. Wait.

And hopefully this will fix the issues

that we had.

Okay. um seem like does not fix it.

So what could be the issue right now

user service?

Okay, but it finally created it.

So it's running

of database connection is running.

Shut up is running as well.

um

just the gateway service that is waiting

for this them to be ready

but I think right now they are running

so let's go to docker right let's go to

docker and I'm going to um

then we can just restart this

it has been created but it's Not

or it think that our services have

failed when they're actually running.

Okay,

let me reload.

I go to the logs.

Yeah. So, reloading this, it made sure

that our services are running.

Yep.

Finally, our services are all running.

Uh let's go to the domain. So, we can

add a custom domain. And uh I'm going to

select the gateway service. And this is

going to be on API

with codewise.com.

With codewise.com, the path is going to

be this one. and our port is 4,000

and use HTTPS.

Let's encrypt. Let's create this. So,

validate this.

Let's open this

and let's try to go to health.

Let's try to go to health routes.

Okay. Um,

where is it? Here.

So, our domain is saying not found.

I wonder what's causing that.

Um,

I wonder what's causing this to say that

this domain is

not found, right? Maybe we're not we did

not expose this port on our settings.

Um

yeah. So if you get an some kind of 404

errors, what I suggest you do is um

comment out this networks on the gateway

service and um hopefully this should fix

your issue. So if you got your domains

and uh this one

and uh now this time should give us the

correct domain without some kind of

errors, right? SW

uh let me close this. Let me open it.

Okay. Uh let me copy just this domain

and then let me go here and then go to

the hair files.

Yeah. And that should give us the that

it's her phone. Okay.

Yeah. So, I think this will be all and

uh I'm going to probably check out and

test some other stuff, but there will be

part two of this video which will go fix

more stuff and also start talking on our

front end. So, I hope you enjoy this and

um thank you so much. This video took so

much time to make and if you made it to

the end, well, congratulations and uh I

will see you guys in the future videos.

Yeah. And thank you so much for

watching. So, see you soon and take

care.


